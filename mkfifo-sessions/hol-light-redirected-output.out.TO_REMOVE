        OCaml version 4.00.1

# val hol_version : string = "2.20++"
val hol_dir : string ref =
  {contents = "/home/mn/Developer/working-copies/hol_light"}
val temp_path : string ref = {contents = "/tmp"}
- : unit = ()
- : unit = ()
val use_file : string -> unit = <fun>
val hol_expand_directory : string -> string = <fun>
val load_path : string list ref = {contents = ["."; "$"]}
val loaded_files : '_a list ref = {contents = []}
val file_on_path : string list -> string -> string = <fun>
val load_on_path : string list -> string -> unit = <fun>
val loads : string -> unit = <fun>
val loadt : string -> unit = <fun>
val needs : string -> unit = <fun>
- : unit = ()
- : unit = ()
val quotexpander : string -> string = <fun>
- : unit = ()
- : bool = true
type num =
  Num.num =
    Int of int
  | Big_int of Big_int.big_int
  | Ratio of Ratio.ratio
val ( +/ ) : num -> num -> num = <fun>
val add_num : num -> num -> num = <fun>
val minus_num : num -> num = <fun>
val ( -/ ) : num -> num -> num = <fun>
val sub_num : num -> num -> num = <fun>
val ( */ ) : num -> num -> num = <fun>
val mult_num : num -> num -> num = <fun>
val square_num : num -> num = <fun>
val ( // ) : num -> num -> num = <fun>
val div_num : num -> num -> num = <fun>
val quo_num : num -> num -> num = <fun>
val mod_num : num -> num -> num = <fun>
val ( **/ ) : num -> num -> num = <fun>
val power_num : num -> num -> num = <fun>
val abs_num : num -> num = <fun>
val succ_num : num -> num = <fun>
val pred_num : num -> num = <fun>
val incr_num : num ref -> unit = <fun>
val decr_num : num ref -> unit = <fun>
val is_integer_num : num -> bool = <fun>
val integer_num : num -> num = <fun>
val floor_num : num -> num = <fun>
val round_num : num -> num = <fun>
val ceiling_num : num -> num = <fun>
val sign_num : num -> int = <fun>
val ( =/ ) : num -> num -> bool = <fun>
val ( </ ) : num -> num -> bool = <fun>
val ( >/ ) : num -> num -> bool = <fun>
val ( <=/ ) : num -> num -> bool = <fun>
val ( >=/ ) : num -> num -> bool = <fun>
val ( <>/ ) : num -> num -> bool = <fun>
val eq_num : num -> num -> bool = <fun>
val lt_num : num -> num -> bool = <fun>
val le_num : num -> num -> bool = <fun>
val gt_num : num -> num -> bool = <fun>
val ge_num : num -> num -> bool = <fun>
val compare_num : num -> num -> int = <fun>
val max_num : num -> num -> num = <fun>
val min_num : num -> num -> num = <fun>
val string_of_num : num -> string = <fun>
val approx_num_fix : int -> num -> string = <fun>
val approx_num_exp : int -> num -> string = <fun>
val num_of_string : string -> num = <fun>
val int_of_num : num -> int = <fun>
val num_of_int : int -> num = <fun>
val nat_of_num : num -> Nat.nat = <fun>
val num_of_nat : Nat.nat -> num = <fun>
val num_of_big_int : Big_int.big_int -> num = <fun>
val big_int_of_num : num -> Big_int.big_int = <fun>
val ratio_of_num : num -> Ratio.ratio = <fun>
val num_of_ratio : Ratio.ratio -> num = <fun>
val float_of_num : num -> float = <fun>
val print_num : num -> unit = <fun>
- : unit = ()
val fail : unit -> 'a = <fun>
val curry : ('a * 'b -> 'c) -> 'a -> 'b -> 'c = <fun>
val uncurry : ('a -> 'b -> 'c) -> 'a * 'b -> 'c = <fun>
val I : 'a -> 'a = <fun>
val K : 'a -> 'b -> 'a = <fun>
val C : ('a -> 'b -> 'c) -> 'b -> 'a -> 'c = <fun>
val W : ('a -> 'a -> 'b) -> 'a -> 'b = <fun>
val o : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
val f_f_ : ('a -> 'b) -> ('c -> 'd) -> 'a * 'c -> 'b * 'd = <fun>
val hd : 'a list -> 'a = <fun>
val tl : 'a list -> 'a list = <fun>
val map : ('a -> 'b) -> 'a list -> 'b list = <fun>
val last : 'a list -> 'a = <fun>
val butlast : 'a list -> 'a list = <fun>
val el : int -> 'a list -> 'a = <fun>
val rev : 'a list -> 'a list = <fun>
val map2 : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list = <fun>
val can : ('a -> 'b) -> 'a -> bool = <fun>
val check : ('a -> bool) -> 'a -> 'a = <fun>
val funpow : int -> ('a -> 'a) -> 'a -> 'a = <fun>
val repeat : ('a -> 'a) -> 'a -> 'a = <fun>
exception Unchanged
val itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b = <fun>
val rev_itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b = <fun>
val end_itlist : ('a -> 'a -> 'a) -> 'a list -> 'a = <fun>
val itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c =
  <fun>
val rev_itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c =
  <fun>
val splitlist : ('a -> 'b * 'a) -> 'a -> 'b list * 'a = <fun>
val rev_splitlist : ('a -> 'a * 'b) -> 'a -> 'a * 'b list = <fun>
val striplist : ('a -> 'a * 'a) -> 'a -> 'a list = <fun>
val nsplit : ('a -> 'b * 'a) -> 'c list -> 'a -> 'b list * 'a = <fun>
val replicate : 'a -> int -> 'a list = <fun>
val ( -- ) : int -> int -> int list = <fun>
val forall : ('a -> bool) -> 'a list -> bool = <fun>
val forall2 : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool = <fun>
val exists : ('a -> bool) -> 'a list -> bool = <fun>
val length : 'a list -> int = <fun>
val filter : ('a -> bool) -> 'a list -> 'a list = <fun>
val partition : ('a -> bool) -> 'a list -> 'a list * 'a list = <fun>
val mapfilter : ('a -> 'b) -> 'a list -> 'b list = <fun>
val find : ('a -> bool) -> 'a list -> 'a = <fun>
val tryfind : ('a -> 'b) -> 'a list -> 'b = <fun>
val flat : 'a list list -> 'a list = <fun>
val remove : ('a -> bool) -> 'a list -> 'a * 'a list = <fun>
val chop_list : int -> 'a list -> 'a list * 'a list = <fun>
val index : 'a -> 'a list -> int = <fun>
val mem : 'a -> 'a list -> bool = <fun>
val insert : 'a -> 'a list -> 'a list = <fun>
val union : 'a list -> 'a list -> 'a list = <fun>
val unions : 'a list list -> 'a list = <fun>
val intersect : 'a list -> 'a list -> 'a list = <fun>
val subtract : 'a list -> 'a list -> 'a list = <fun>
val subset : 'a list -> 'a list -> bool = <fun>
val set_eq : 'a list -> 'a list -> bool = <fun>
val assoc : 'a -> ('a * 'b) list -> 'b = <fun>
val rev_assoc : 'a -> ('b * 'a) list -> 'b = <fun>
val zip : 'a list -> 'b list -> ('a * 'b) list = <fun>
val unzip : ('a * 'b) list -> 'a list * 'b list = <fun>
val shareout : 'a list list -> 'b list -> 'b list list = <fun>
val do_list : ('a -> 'b) -> 'a list -> unit = <fun>
val sort : ('a -> 'a -> bool) -> 'a list -> 'a list = <fun>
val uniq : 'a list -> 'a list = <fun>
val setify : 'a list -> 'a list = <fun>
val implode : string list -> string = <fun>
val explode : string -> string list = <fun>
val gcd : int -> int -> int = <fun>
val num_0 : num = 0
val num_1 : num = 1
val num_2 : num = 2
val num_10 : num = 10
val pow2 : int -> num = <fun>
val pow10 : int -> num = <fun>
val numdom : num -> num * num = <fun>
val numerator : num -> num = <fun>
val denominator : num -> num = <fun>
val gcd_num : num -> num -> num = <fun>
val lcm_num : num -> num -> num = <fun>
val allpairs : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list = <fun>
val report : string -> unit = <fun>
val warn : bool -> string -> unit = <fun>
val verbose : bool ref = {contents = true}
val report_timing : bool ref = {contents = true}
val remark : string -> unit = <fun>
val time : ('a -> 'b) -> 'a -> 'b = <fun>
val assocd : 'a -> ('a * 'b) list -> 'b -> 'b = <fun>
val rev_assocd : 'a -> ('b * 'a) list -> 'b -> 'b = <fun>
val qmap : ('a -> 'a) -> 'a list -> 'a list = <fun>
val merge : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list = <fun>
val mergesort : ('a -> 'a -> bool) -> 'a list -> 'a list = <fun>
val increasing : ('a -> 'b) -> 'a -> 'a -> bool = <fun>
val decreasing : ('a -> 'b) -> 'a -> 'a -> bool = <fun>
type ('a, 'b) func =
    Empty
  | Leaf of int * ('a * 'b) list
  | Branch of int * int * ('a, 'b) func * ('a, 'b) func
val undefined : ('a, 'b) func = Empty
val is_undefined : ('a, 'b) func -> bool = <fun>
val mapf : ('a -> 'b) -> ('c, 'a) func -> ('c, 'b) func = <fun>
val foldl : ('a -> 'b -> 'c -> 'a) -> 'a -> ('b, 'c) func -> 'a = <fun>
val foldr : ('a -> 'b -> 'c -> 'c) -> ('a, 'b) func -> 'c -> 'c = <fun>
val graph : ('a, 'b) func -> ('a * 'b) list = <fun>
val dom : ('a, 'b) func -> 'a list = <fun>
val ran : ('a, 'b) func -> 'b list = <fun>
val applyd : ('a, 'b) func -> ('a -> 'b) -> 'a -> 'b = <fun>
val apply : ('a, 'b) func -> 'a -> 'b = <fun>
val tryapplyd : ('a, 'b) func -> 'a -> 'b -> 'b = <fun>
val defined : ('a, 'b) func -> 'a -> bool = <fun>
val undefine : 'a -> ('a, 'b) func -> ('a, 'b) func = <fun>
val ( |-> ) : 'a -> 'b -> ('a, 'b) func -> ('a, 'b) func = <fun>
val combine :
  ('a -> 'a -> 'a) ->
  ('a -> bool) -> ('b, 'a) func -> ('b, 'a) func -> ('b, 'a) func = <fun>
val ( |=> ) : 'a -> 'b -> ('a, 'b) func = <fun>
val choose : ('a, 'b) func -> 'a * 'b = <fun>
val print_fpf : ('a, 'b) func -> unit = <fun>
val mem' : ('a -> 'b -> bool) -> 'a -> 'b list -> bool = <fun>
val insert' : ('a -> 'a -> bool) -> 'a -> 'a list -> 'a list = <fun>
val union' : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list = <fun>
val unions' : ('a -> 'a -> bool) -> 'a list list -> 'a list = <fun>
val subtract' : ('a -> 'b -> bool) -> 'a list -> 'b list -> 'a list = <fun>
val num_of_string : string -> num = <fun>
val strings_of_file : string -> string list = <fun>
val string_of_file : string -> string = <fun>
val file_of_string : string -> string -> unit = <fun>
- : unit = ()
File "lib.ml" already loaded
- : unit = ()
module type Hol_kernel =
  sig
    type hol_type = private Tyvar of string | Tyapp of string * hol_type list
    type term = private
        Var of string * hol_type
      | Const of string * hol_type
      | Comb of term * term
      | Abs of term * term
    type thm
    val types : unit -> (string * int) list
    val get_type_arity : string -> int
    val new_type : string * int -> unit
    val mk_type : string * hol_type list -> hol_type
    val mk_vartype : string -> hol_type
    val dest_type : hol_type -> string * hol_type list
    val dest_vartype : hol_type -> string
    val is_type : hol_type -> bool
    val is_vartype : hol_type -> bool
    val tyvars : hol_type -> hol_type list
    val type_subst : (hol_type * hol_type) list -> hol_type -> hol_type
    val bool_ty : hol_type
    val aty : hol_type
    val constants : unit -> (string * hol_type) list
    val get_const_type : string -> hol_type
    val new_constant : string * hol_type -> unit
    val type_of : term -> hol_type
    val alphaorder : term -> term -> int
    val is_var : term -> bool
    val is_const : term -> bool
    val is_abs : term -> bool
    val is_comb : term -> bool
    val mk_var : string * hol_type -> term
    val mk_const : string * (hol_type * hol_type) list -> term
    val mk_abs : term * term -> term
    val mk_comb : term * term -> term
    val dest_var : term -> string * hol_type
    val dest_const : term -> string * hol_type
    val dest_comb : term -> term * term
    val dest_abs : term -> term * term
    val frees : term -> term list
    val freesl : term list -> term list
    val freesin : term list -> term -> bool
    val vfree_in : term -> term -> bool
    val type_vars_in_term : term -> hol_type list
    val variant : term list -> term -> term
    val vsubst : (term * term) list -> term -> term
    val inst : (hol_type * hol_type) list -> term -> term
    val rand : term -> term
    val rator : term -> term
    val dest_eq : term -> term * term
    val dest_thm : thm -> term list * term
    val hyp : thm -> term list
    val concl : thm -> term
    val REFL : term -> thm
    val TRANS : thm -> thm -> thm
    val MK_COMB : thm * thm -> thm
    val ABS : term -> thm -> thm
    val BETA : term -> thm
    val ASSUME : term -> thm
    val EQ_MP : thm -> thm -> thm
    val DEDUCT_ANTISYM_RULE : thm -> thm -> thm
    val INST_TYPE : (hol_type * hol_type) list -> thm -> thm
    val INST : (term * term) list -> thm -> thm
    val axioms : unit -> thm list
    val new_axiom : term -> thm
    val definitions : unit -> thm list
    val new_basic_definition : term -> thm
    val new_basic_type_definition :
      string -> string * string -> thm -> thm * thm
  end
module Hol : Hol_kernel
type hol_type =
  Hol.hol_type = private
    Tyvar of string
  | Tyapp of string * hol_type list
type term =
  Hol.term = private
    Var of string * hol_type
  | Const of string * hol_type
  | Comb of term * term
  | Abs of term * term
type thm = Hol.thm
val types : unit -> (string * int) list = <fun>
val get_type_arity : string -> int = <fun>
val new_type : string * int -> unit = <fun>
val mk_type : string * hol_type list -> hol_type = <fun>
val mk_vartype : string -> hol_type = <fun>
val dest_type : hol_type -> string * hol_type list = <fun>
val dest_vartype : hol_type -> string = <fun>
val is_type : hol_type -> bool = <fun>
val is_vartype : hol_type -> bool = <fun>
val tyvars : hol_type -> hol_type list = <fun>
val type_subst : (hol_type * hol_type) list -> hol_type -> hol_type = <fun>
val bool_ty : hol_type = Tyapp ("bool", [])
val aty : hol_type = Tyvar "A"
val constants : unit -> (string * hol_type) list = <fun>
val get_const_type : string -> hol_type = <fun>
val new_constant : string * hol_type -> unit = <fun>
val type_of : term -> hol_type = <fun>
val alphaorder : term -> term -> int = <fun>
val is_var : term -> bool = <fun>
val is_const : term -> bool = <fun>
val is_abs : term -> bool = <fun>
val is_comb : term -> bool = <fun>
val mk_var : string * hol_type -> term = <fun>
val mk_const : string * (hol_type * hol_type) list -> term = <fun>
val mk_abs : term * term -> term = <fun>
val mk_comb : term * term -> term = <fun>
val dest_var : term -> string * hol_type = <fun>
val dest_const : term -> string * hol_type = <fun>
val dest_comb : term -> term * term = <fun>
val dest_abs : term -> term * term = <fun>
val frees : term -> term list = <fun>
val freesl : term list -> term list = <fun>
val freesin : term list -> term -> bool = <fun>
val vfree_in : term -> term -> bool = <fun>
val type_vars_in_term : term -> hol_type list = <fun>
val variant : term list -> term -> term = <fun>
val vsubst : (term * term) list -> term -> term = <fun>
val inst : (hol_type * hol_type) list -> term -> term = <fun>
val rand : term -> term = <fun>
val rator : term -> term = <fun>
val dest_eq : term -> term * term = <fun>
val dest_thm : thm -> term list * term = <fun>
val hyp : thm -> term list = <fun>
val concl : thm -> term = <fun>
val REFL : term -> thm = <fun>
val TRANS : thm -> thm -> thm = <fun>
val MK_COMB : thm * thm -> thm = <fun>
val ABS : term -> thm -> thm = <fun>
val BETA : term -> thm = <fun>
val ASSUME : term -> thm = <fun>
val EQ_MP : thm -> thm -> thm = <fun>
val DEDUCT_ANTISYM_RULE : thm -> thm -> thm = <fun>
val INST_TYPE : (hol_type * hol_type) list -> thm -> thm = <fun>
val INST : (term * term) list -> thm -> thm = <fun>
val axioms : unit -> thm list = <fun>
val new_axiom : term -> thm = <fun>
val definitions : unit -> thm list = <fun>
val new_basic_definition : term -> thm = <fun>
val new_basic_type_definition : string -> string * string -> thm -> thm * thm =
  <fun>
val mk_fun_ty : hol_type -> hol_type -> hol_type = <fun>
val bty : hol_type = Tyvar "B"
val is_eq : term -> bool = <fun>
val mk_eq : term * term -> term = <fun>
val aconv : term -> term -> bool = <fun>
val equals_thm : thm -> thm -> bool = <fun>
- : unit = ()
File "fusion.ml" already loaded
- : unit = ()
val genvar : hol_type -> term = <fun>
val dest_fun_ty : hol_type -> hol_type * hol_type = <fun>
val occurs_in : hol_type -> hol_type -> bool = <fun>
val tysubst : (hol_type * hol_type) list -> hol_type -> hol_type = <fun>
val bndvar : term -> term = <fun>
val body : term -> term = <fun>
val list_mk_comb : term * term list -> term = <fun>
val list_mk_abs : term list * term -> term = <fun>
val strip_comb : term -> term * term list = <fun>
val strip_abs : term -> term list * term = <fun>
val is_binary : string -> term -> bool = <fun>
val dest_binary : string -> term -> term * term = <fun>
val mk_binary : string -> term * term -> term = <fun>
val variants : term list -> term list -> term list = <fun>
val variables : term -> term list = <fun>
val subst : (term * term) list -> term -> term = <fun>
val alpha : term -> term -> term = <fun>
val type_match :
  hol_type ->
  hol_type -> (hol_type * hol_type) list -> (hol_type * hol_type) list =
  <fun>
val mk_mconst : string * hol_type -> term = <fun>
val mk_icomb : term * term -> term = <fun>
val list_mk_icomb : string -> term list -> term = <fun>
val thm_frees : thm -> term list = <fun>
val free_in : term -> term -> bool = <fun>
val find_term : (term -> bool) -> term -> term = <fun>
val find_terms : (term -> bool) -> term -> term list = <fun>
val is_binder : string -> term -> bool = <fun>
val dest_binder : string -> term -> term * term = <fun>
val mk_binder : string -> term * term -> term = <fun>
val is_binop : term -> term -> bool = <fun>
val dest_binop : term -> term -> term * term = <fun>
val mk_binop : term -> term -> term -> term = <fun>
val list_mk_binop : term -> term list -> term = <fun>
val binops : term -> term -> term list = <fun>
val is_conj : term -> bool = <fun>
val dest_conj : term -> term * term = <fun>
val conjuncts : term -> term list = <fun>
val is_imp : term -> bool = <fun>
val dest_imp : term -> term * term = <fun>
val is_forall : term -> bool = <fun>
val dest_forall : term -> term * term = <fun>
val strip_forall : term -> term list * term = <fun>
val is_exists : term -> bool = <fun>
val dest_exists : term -> term * term = <fun>
val strip_exists : term -> term list * term = <fun>
val is_disj : term -> bool = <fun>
val dest_disj : term -> term * term = <fun>
val disjuncts : term -> term list = <fun>
val is_neg : term -> bool = <fun>
val dest_neg : term -> term = <fun>
val is_uexists : term -> bool = <fun>
val dest_uexists : term -> term * term = <fun>
val dest_cons : term -> term * term = <fun>
val is_cons : term -> bool = <fun>
val dest_list : term -> term list = <fun>
val is_list : term -> bool = <fun>
val dest_numeral : term -> num = <fun>
val dest_gabs : term -> term * term = <fun>
val is_gabs : term -> bool = <fun>
val mk_gabs : term * term -> term = <fun>
val list_mk_gabs : term list * term -> term = <fun>
val strip_gabs : term -> term list * term = <fun>
val dest_let : term -> (term * term) list * term = <fun>
val is_let : term -> bool = <fun>
val mk_let : (term * term) list * term -> term = <fun>
val make_args : string -> term list -> hol_type list -> term list = <fun>
val find_path : (term -> bool) -> term -> string = <fun>
val follow_path : string -> term -> term = <fun>
- : unit = ()
File "basics.ml" already loaded
- : unit = ()
type term_label =
    Vnet
  | Lcnet of (string * int)
  | Cnet of (string * int)
  | Lnet of int
type 'a net = Netnode of (term_label * 'a net) list * 'a list
val empty_net : 'a net = Netnode ([], [])
val enter : term list -> term * 'a -> 'a net -> 'a net = <fun>
val lookup : term -> 'a net -> 'a list = <fun>
val merge_nets : 'a net * 'a net -> 'a net = <fun>
- : unit = ()
File "nets.ml" already loaded
- : unit = ()
val isspace : string -> bool = <fun>
val issep : string -> bool = <fun>
val isbra : string -> bool = <fun>
val issymb : string -> bool = <fun>
val isalpha : string -> bool = <fun>
val isnum : string -> bool = <fun>
val isalnum : string -> bool = <fun>
val reserve_words : string list -> unit = <fun>
val unreserve_words : string list -> unit = <fun>
val is_reserved_word : string -> bool = <fun>
val reserved_words : unit -> string list = <fun>
val unparse_as_binder : string -> unit = <fun>
val parse_as_binder : string -> unit = <fun>
val parses_as_binder : string -> bool = <fun>
val binders : unit -> string list = <fun>
val unparse_as_prefix : string -> unit = <fun>
val parse_as_prefix : string -> unit = <fun>
val is_prefix : string -> bool = <fun>
val prefixes : unit -> string list = <fun>
val unparse_as_infix : string -> unit = <fun>
val parse_as_infix : string * (int * string) -> unit = <fun>
val get_infix_status : string -> int * string = <fun>
val infixes : unit -> (string * (int * string)) list = <fun>
val the_interface : (string * (string * hol_type)) list ref = {contents = []}
val the_overload_skeletons : (string * hol_type) list ref = {contents = []}
val open_box : int -> unit = <fun>
val close_box : unit -> unit = <fun>
val print_string : string -> unit = <fun>
val print_as : int -> string -> unit = <fun>
val print_int : int -> unit = <fun>
val print_float : float -> unit = <fun>
val print_char : char -> unit = <fun>
val print_bool : bool -> unit = <fun>
val print_space : unit -> unit = <fun>
val print_cut : unit -> unit = <fun>
val print_break : int -> int -> unit = <fun>
val print_flush : unit -> unit = <fun>
val print_newline : unit -> unit = <fun>
val force_newline : unit -> unit = <fun>
val print_if_newline : unit -> unit = <fun>
val set_margin : int -> unit = <fun>
val get_margin : unit -> int = <fun>
val set_max_indent : int -> unit = <fun>
val get_max_indent : unit -> int = <fun>
val set_max_boxes : int -> unit = <fun>
val get_max_boxes : unit -> int = <fun>
val over_max_boxes : unit -> bool = <fun>
val open_hbox : unit -> unit = <fun>
val open_vbox : int -> unit = <fun>
val open_hvbox : int -> unit = <fun>
val open_hovbox : int -> unit = <fun>
val open_tbox : unit -> unit = <fun>
val close_tbox : unit -> unit = <fun>
val print_tbreak : int -> int -> unit = <fun>
val set_tab : unit -> unit = <fun>
val print_tab : unit -> unit = <fun>
val set_ellipsis_text : string -> unit = <fun>
val get_ellipsis_text : unit -> string = <fun>
type tag = string
val open_tag : tag -> unit = <fun>
val close_tag : unit -> unit = <fun>
val set_tags : bool -> unit = <fun>
val set_print_tags : bool -> unit = <fun>
val set_mark_tags : bool -> unit = <fun>
val get_print_tags : unit -> bool = <fun>
val get_mark_tags : unit -> bool = <fun>
val set_formatter_out_channel : out_channel -> unit = <fun>
val set_formatter_output_functions :
  (string -> int -> int -> unit) -> (unit -> unit) -> unit = <fun>
val get_formatter_output_functions :
  unit -> (string -> int -> int -> unit) * (unit -> unit) = <fun>
val set_all_formatter_output_functions :
  out:(string -> int -> int -> unit) ->
  flush:(unit -> unit) ->
  newline:(unit -> unit) -> spaces:(int -> unit) -> unit = <fun>
val get_all_formatter_output_functions :
  unit ->
  (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *
  (int -> unit) = <fun>
type formatter_tag_functions =
  Format.formatter_tag_functions = {
  mark_open_tag : tag -> string;
  mark_close_tag : tag -> string;
  print_open_tag : tag -> unit;
  print_close_tag : tag -> unit;
}
val set_formatter_tag_functions : formatter_tag_functions -> unit = <fun>
val get_formatter_tag_functions : unit -> formatter_tag_functions = <fun>
type formatter = Format.formatter
val formatter_of_out_channel : out_channel -> formatter = <fun>
val std_formatter : formatter = <abstr>
val err_formatter : formatter = <abstr>
val formatter_of_buffer : Buffer.t -> formatter = <fun>
val stdbuf : Buffer.t = <abstr>
val str_formatter : formatter = <abstr>
val flush_str_formatter : unit -> string = <fun>
val make_formatter :
  (string -> int -> int -> unit) -> (unit -> unit) -> formatter = <fun>
val pp_open_hbox : formatter -> unit -> unit = <fun>
val pp_open_vbox : formatter -> int -> unit = <fun>
val pp_open_hvbox : formatter -> int -> unit = <fun>
val pp_open_hovbox : formatter -> int -> unit = <fun>
val pp_open_box : formatter -> int -> unit = <fun>
val pp_close_box : formatter -> unit -> unit = <fun>
val pp_open_tag : formatter -> string -> unit = <fun>
val pp_close_tag : formatter -> unit -> unit = <fun>
val pp_print_string : formatter -> string -> unit = <fun>
val pp_print_as : formatter -> int -> string -> unit = <fun>
val pp_print_int : formatter -> int -> unit = <fun>
val pp_print_float : formatter -> float -> unit = <fun>
val pp_print_char : formatter -> char -> unit = <fun>
val pp_print_bool : formatter -> bool -> unit = <fun>
val pp_print_break : formatter -> int -> int -> unit = <fun>
val pp_print_cut : formatter -> unit -> unit = <fun>
val pp_print_space : formatter -> unit -> unit = <fun>
val pp_force_newline : formatter -> unit -> unit = <fun>
val pp_print_flush : formatter -> unit -> unit = <fun>
val pp_print_newline : formatter -> unit -> unit = <fun>
val pp_print_if_newline : formatter -> unit -> unit = <fun>
val pp_open_tbox : formatter -> unit -> unit = <fun>
val pp_close_tbox : formatter -> unit -> unit = <fun>
val pp_print_tbreak : formatter -> int -> int -> unit = <fun>
val pp_set_tab : formatter -> unit -> unit = <fun>
val pp_print_tab : formatter -> unit -> unit = <fun>
val pp_set_tags : formatter -> bool -> unit = <fun>
val pp_set_print_tags : formatter -> bool -> unit = <fun>
val pp_set_mark_tags : formatter -> bool -> unit = <fun>
val pp_get_print_tags : formatter -> unit -> bool = <fun>
val pp_get_mark_tags : formatter -> unit -> bool = <fun>
val pp_set_margin : formatter -> int -> unit = <fun>
val pp_get_margin : formatter -> unit -> int = <fun>
val pp_set_max_indent : formatter -> int -> unit = <fun>
val pp_get_max_indent : formatter -> unit -> int = <fun>
val pp_set_max_boxes : formatter -> int -> unit = <fun>
val pp_get_max_boxes : formatter -> unit -> int = <fun>
val pp_over_max_boxes : formatter -> unit -> bool = <fun>
val pp_set_ellipsis_text : formatter -> string -> unit = <fun>
val pp_get_ellipsis_text : formatter -> unit -> string = <fun>
val pp_set_formatter_out_channel : formatter -> out_channel -> unit = <fun>
val pp_set_formatter_output_functions :
  formatter -> (string -> int -> int -> unit) -> (unit -> unit) -> unit =
  <fun>
val pp_get_formatter_output_functions :
  formatter -> unit -> (string -> int -> int -> unit) * (unit -> unit) =
  <fun>
val pp_set_all_formatter_output_functions :
  formatter ->
  out:(string -> int -> int -> unit) ->
  flush:(unit -> unit) ->
  newline:(unit -> unit) -> spaces:(int -> unit) -> unit = <fun>
val pp_get_all_formatter_output_functions :
  formatter ->
  unit ->
  (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *
  (int -> unit) = <fun>
val pp_set_formatter_tag_functions :
  formatter -> formatter_tag_functions -> unit = <fun>
val pp_get_formatter_tag_functions :
  formatter -> unit -> formatter_tag_functions = <fun>
val fprintf : formatter -> ('a, formatter, unit) format -> 'a = <fun>
val printf : ('a, formatter, unit) format -> 'a = <fun>
val eprintf : ('a, formatter, unit) format -> 'a = <fun>
val sprintf : ('a, unit, string) format -> 'a = <fun>
val ifprintf : formatter -> ('a, formatter, unit) format -> 'a = <fun>
val kfprintf :
  (formatter -> 'a) -> formatter -> ('b, formatter, unit, 'a) format4 -> 'b =
  <fun>
val ikfprintf :
  (formatter -> 'a) -> formatter -> ('b, formatter, unit, 'a) format4 -> 'b =
  <fun>
val ksprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b = <fun>
val bprintf : Buffer.t -> ('a, formatter, unit) format -> 'a = <fun>
val kprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b = <fun>
- : unit = ()
val reverse_interface_mapping : bool ref = {contents = true}
val unspaced_binops : string list ref = {contents = [","; ".."; "$"]}
val prebroken_binops : string list ref = {contents = ["==>"]}
val print_unambiguous_comprehensions : bool ref = {contents = false}
val typify_universal_set : bool ref = {contents = true}
val print_all_thm : bool ref = {contents = true}
val name_of : term -> string = <fun>
val pp_print_type : formatter -> hol_type -> unit = <fun>
val pp_print_qtype : formatter -> hol_type -> unit = <fun>
val install_user_printer : string * (formatter -> term -> unit) -> unit =
  <fun>
val delete_user_printer : string -> unit = <fun>
val try_user_printer : formatter -> term -> unit = <fun>
val pp_print_term : formatter -> term -> unit = <fun>
val pp_print_qterm : formatter -> term -> unit = <fun>
val pp_print_thm : formatter -> thm -> unit = <fun>
val print_type : hol_type -> unit = <fun>
val print_qtype : hol_type -> unit = <fun>
val print_term : term -> unit = <fun>
val print_qterm : term -> unit = <fun>
val print_thm : thm -> unit = <fun>
val print_to_string : (formatter -> 'a -> unit) -> 'a -> string = <fun>
val string_of_type : hol_type -> string = <fun>
val string_of_term : term -> string = <fun>
val string_of_thm : thm -> string = <fun>
- : unit = ()
File "printer.ml" already loaded
- : unit = ()
val ignore_constant_varstruct : bool ref = {contents = true}
val type_invention_warning : bool ref = {contents = true}
val type_invention_error : bool ref = {contents = false}
val the_implicit_types : (string * hol_type) list ref = {contents = []}
val make_overloadable : string -> hol_type -> unit = <fun>
val remove_interface : string -> unit = <fun>
val reduce_interface : string * term -> unit = <fun>
val override_interface : string * term -> unit = <fun>
val overload_interface : string * term -> unit = <fun>
val prioritize_overload : hol_type -> unit = <fun>
val new_type_abbrev : string * hol_type -> unit = <fun>
val remove_type_abbrev : string -> unit = <fun>
val type_abbrevs : unit -> (string * hol_type) list = <fun>
val hide_constant : string -> unit = <fun>
val unhide_constant : string -> unit = <fun>
val is_hidden : string -> bool = <fun>
type pretype = Utv of string | Ptycon of string * pretype list | Stv of int
val dpty : pretype = Ptycon ("", [])
val pretype_of_type : hol_type -> pretype = <fun>
type preterm =
    Varp of string * pretype
  | Constp of string * pretype
  | Combp of preterm * preterm
  | Absp of preterm * preterm
  | Typing of preterm * pretype
val preterm_of_term : term -> preterm = <fun>
val type_of_pretype : pretype -> hol_type = <fun>
val term_of_preterm : preterm -> term = <fun>
val retypecheck : (string * pretype) list -> preterm -> preterm = <fun>
- : unit = ()
File "preterm.ml" already loaded
- : unit = ()
- : unit = ()
exception Noparse
val ( || ) : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b = <fun>
val ( ++ ) : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e =
  <fun>
val many : ('a -> 'b * 'a) -> 'a -> 'b list * 'a = <fun>
val ( >> ) : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c = <fun>
val fix : string -> ('a -> 'b) -> 'a -> 'b = <fun>
val listof :
  ('a -> 'b * 'c) -> ('c -> 'd * 'a) -> string -> 'a -> 'b list * 'c = <fun>
val nothing : 'a -> 'b list * 'a = <fun>
val elistof :
  ('a -> 'b * 'a) -> ('a -> 'c * 'a) -> string -> 'a -> 'b list * 'a = <fun>
val leftbin :
  ('a -> 'b * 'c) ->
  ('c -> 'd * 'a) -> ('d -> 'b -> 'b -> 'b) -> string -> 'a -> 'b * 'c =
  <fun>
val rightbin :
  ('a -> 'b * 'c) ->
  ('c -> 'd * 'a) -> ('d -> 'b -> 'b -> 'b) -> string -> 'a -> 'b * 'c =
  <fun>
val possibly : ('a -> 'b * 'a) -> 'a -> 'b list * 'a = <fun>
val some : ('a -> bool) -> 'a list -> 'a * 'a list = <fun>
val a : 'a -> 'a list -> 'a * 'a list = <fun>
val atleast : int -> ('a -> 'b * 'a) -> 'a -> 'b list * 'a = <fun>
val finished : 'a list -> int * 'a list = <fun>
type lexcode = Ident of string | Resword of string
- : unit = ()
val comment_token : lexcode ref = {contents = Resword "//"}
val lex : string list -> lexcode list = <fun>
val parse_pretype : lexcode list -> pretype * lexcode list = <fun>
val install_parser :
  string * (lexcode list -> preterm * lexcode list) -> unit = <fun>
val delete_parser : string -> unit = <fun>
val installed_parsers :
  unit -> (string * (lexcode list -> preterm * lexcode list)) list = <fun>
val try_user_parser : lexcode list -> preterm * lexcode list = <fun>
val parse_preterm : lexcode list -> preterm * lexcode list = <fun>
val parse_type : string -> hol_type = <fun>
val parse_term : string -> term = <fun>
- : unit = ()
File "printer.ml" already loaded
- : unit = ()
type conv = term -> thm
val lhand : term -> term = <fun>
val lhs : term -> term = <fun>
val rhs : term -> term = <fun>
val mk_primed_var : term list -> term -> term = <fun>
val BETA_CONV : term -> thm = <fun>
val AP_TERM : term -> thm -> thm = <fun>
val AP_THM : thm -> term -> thm = <fun>
val SYM : thm -> thm = <fun>
val ALPHA : term -> term -> thm = <fun>
val ALPHA_CONV : term -> term -> thm = <fun>
val GEN_ALPHA_CONV : term -> term -> thm = <fun>
val MK_BINOP : term -> thm * thm -> thm = <fun>
val NO_CONV : conv = <fun>
val ALL_CONV : conv = <fun>
val thenc_ : conv -> conv -> conv = <fun>
val orelsec_ : conv -> conv -> conv = <fun>
val FIRST_CONV : conv list -> conv = <fun>
val EVERY_CONV : conv list -> conv = <fun>
val REPEATC : conv -> conv = <fun>
val CHANGED_CONV : conv -> conv = <fun>
val TRY_CONV : conv -> conv = <fun>
val RATOR_CONV : conv -> conv = <fun>
val RAND_CONV : conv -> conv = <fun>
val LAND_CONV : conv -> conv = <fun>
val COMB2_CONV : conv -> conv -> conv = <fun>
val COMB_CONV : conv -> conv = <fun>
val ABS_CONV : conv -> conv = <fun>
val BINDER_CONV : conv -> term -> thm = <fun>
val SUB_CONV : conv -> term -> thm = <fun>
val BINOP_CONV : (term -> thm) -> term -> thm = <fun>
val ONCE_DEPTH_CONV : conv -> conv = <fun>
val DEPTH_CONV : conv -> conv = <fun>
val REDEPTH_CONV : conv -> conv = <fun>
val TOP_DEPTH_CONV : conv -> conv = <fun>
val TOP_SWEEP_CONV : conv -> conv = <fun>
val DEPTH_BINOP_CONV : term -> (term -> thm) -> term -> thm = <fun>
val PATH_CONV : string -> conv -> conv = <fun>
val PAT_CONV : term -> conv -> conv = <fun>
val SYM_CONV : term -> thm = <fun>
val CONV_RULE : conv -> thm -> thm = <fun>
val SUBS_CONV : thm list -> term -> thm = <fun>
val BETA_RULE : thm -> thm = <fun>
val GSYM : thm -> thm = <fun>
val SUBS : thm list -> thm -> thm = <fun>
val CACHE_CONV : (term -> thm) -> term -> thm = <fun>
- : unit = ()
File "equal.ml" already loaded
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val is_iff : term -> bool = <fun>
val dest_iff : term -> term * term = <fun>
val mk_iff : term * term -> term = <fun>
val PINST : (hol_type * hol_type) list -> (term * term) list -> thm -> thm =
  <fun>
val PROVE_HYP : thm -> thm -> thm = <fun>
val T_DEF : thm = |- T <=> (\p. p) = (\p. p)
val TRUTH : thm = |- T
val EQT_ELIM : thm -> thm = <fun>
val EQT_INTRO : thm -> thm = <fun>
val AND_DEF : thm = |- (/\) = (\p q. (\f. f p q) = (\f. f T T))
val mk_conj : term * term -> term = <fun>
val list_mk_conj : term list -> term = <fun>
val CONJ : thm -> thm -> thm = <fun>
val CONJUNCT1 : thm -> thm = <fun>
val CONJUNCT2 : thm -> thm = <fun>
val CONJ_PAIR : thm -> thm * thm = <fun>
val CONJUNCTS : thm -> thm list = <fun>
val IMP_DEF : thm = |- (==>) = (\p q. p /\ q <=> p)
val mk_imp : term * term -> term = <fun>
val MP : thm -> thm -> thm = <fun>
val DISCH : term -> thm -> thm = <fun>
val DISCH_ALL : thm -> thm = <fun>
val UNDISCH : thm -> thm = <fun>
val UNDISCH_ALL : thm -> thm = <fun>
val IMP_ANTISYM_RULE : thm -> thm -> thm = <fun>
val ADD_ASSUM : term -> thm -> thm = <fun>
val EQ_IMP_RULE : thm -> thm * thm = <fun>
val IMP_TRANS : thm -> thm -> thm = <fun>
val FORALL_DEF : thm = |- (!) = (\P. P = (\x. T))
val mk_forall : term * term -> term = <fun>
val list_mk_forall : term list * term -> term = <fun>
val SPEC : term -> thm -> thm = <fun>
val SPECL : term list -> thm -> thm = <fun>
val SPEC_VAR : thm -> term * thm = <fun>
val SPEC_ALL : thm -> thm = <fun>
val ISPEC : term -> thm -> thm = <fun>
val ISPECL : term list -> thm -> thm = <fun>
val GEN : term -> thm -> thm = <fun>
val GENL : term list -> thm -> thm = <fun>
val GEN_ALL : thm -> thm = <fun>
val EXISTS_DEF : thm = |- (?) = (\P. !q. (!x. P x ==> q) ==> q)
val mk_exists : term * term -> term = <fun>
val list_mk_exists : term list * term -> term = <fun>
val EXISTS : term * term -> thm -> thm = <fun>
val SIMPLE_EXISTS : term -> thm -> thm = <fun>
val CHOOSE : term * thm -> thm -> thm = <fun>
val SIMPLE_CHOOSE : term -> thm -> thm = <fun>
val OR_DEF : thm = |- (\/) = (\p q. !r. (p ==> r) ==> (q ==> r) ==> r)
val mk_disj : term * term -> term = <fun>
val list_mk_disj : term list -> term = <fun>
val DISJ1 : thm -> term -> thm = <fun>
val DISJ2 : term -> thm -> thm = <fun>
val DISJ_CASES : thm -> thm -> thm -> thm = <fun>
val SIMPLE_DISJ_CASES : thm -> thm -> thm = <fun>
val F_DEF : thm = |- F <=> (!p. p)
val NOT_DEF : thm = |- (~) = (\p. p ==> F)
val mk_neg : term -> term = <fun>
val NOT_ELIM : thm -> thm = <fun>
val NOT_INTRO : thm -> thm = <fun>
val EQF_INTRO : thm -> thm = <fun>
val EQF_ELIM : thm -> thm = <fun>
val CONTR : term -> thm -> thm = <fun>
val EXISTS_UNIQUE_DEF : thm =
  |- (?!) = (\P. (?) P /\ (!x y. P x /\ P y ==> x = y))
val mk_uexists : term * term -> term = <fun>
val EXISTENCE : thm -> thm = <fun>
- : unit = ()
File "bool.ml" already loaded
- : unit = ()
type instantiation =
    (int * term) list * (term * term) list * (hol_type * hol_type) list
val mk_thm : term list * term -> thm = <fun>
val MK_CONJ : thm -> thm -> thm = <fun>
val MK_DISJ : thm -> thm -> thm = <fun>
val MK_FORALL : term -> thm -> thm = <fun>
val MK_EXISTS : term -> thm -> thm = <fun>
val MP_CONV : conv -> thm -> thm = <fun>
val BETAS_CONV : conv = <fun>
val instantiate : instantiation -> term -> term = <fun>
val INSTANTIATE : instantiation -> thm -> thm = <fun>
val INSTANTIATE_ALL : instantiation -> thm -> thm = <fun>
val term_match : term list -> term -> term -> instantiation = <fun>
val term_unify : term list -> term -> term -> instantiation = <fun>
val deep_alpha : (string * string) list -> term -> term = <fun>
val PART_MATCH : (term -> term) -> thm -> term -> thm = <fun>
val GEN_PART_MATCH : (term -> term) -> thm -> term -> thm = <fun>
val MATCH_MP : thm -> thm -> thm = <fun>
val HIGHER_REWRITE_CONV : thm list -> bool -> term -> thm = <fun>
val new_definition : term -> thm = <fun>
- : unit = ()
File "drule.ml" already loaded
- : unit = ()
val null_inst : instantiation = ([], [], [])
val null_meta : term list * instantiation = ([], ([], [], []))
type goal = (string * thm) list * term
val equals_goal : goal -> goal -> bool = <fun>
type justification = instantiation -> thm list -> thm
type goalstate = (term list * instantiation) * goal list * justification
type goalstack = goalstate list
type refinement = goalstate -> goalstate
type tactic = goal -> goalstate
type thm_tactic = thm -> tactic
type thm_tactical = thm_tactic -> thm_tactic
val inst_goal : instantiation -> goal -> goal = <fun>
val compose_insts : instantiation -> instantiation -> instantiation = <fun>
val _FALSITY_ : thm = |- _FALSITY_ <=> F
val mk_fthm : term list * term -> thm = <fun>
val VALID : tactic -> tactic = <fun>
val then_ : tactic -> tactic -> tactic = <fun>
val thenl_ : tactic -> tactic list -> tactic = <fun>
val orelse_ : tactic -> tactic -> tactic = <fun>
val FAIL_TAC : string -> tactic = <fun>
val NO_TAC : tactic = <fun>
val ALL_TAC : tactic = <fun>
val TRY : tactic -> tactic = <fun>
val REPEAT : tactic -> tactic = <fun>
val EVERY : tactic list -> tactic = <fun>
val FIRST : tactic list -> tactic = <fun>
val MAP_EVERY : ('a -> tactic) -> 'a list -> tactic = <fun>
val MAP_FIRST : ('a -> tactic) -> 'a list -> tactic = <fun>
val CHANGED_TAC : tactic -> tactic = <fun>
val REPLICATE_TAC : int -> tactic -> tactic = <fun>
val then_tcl_ : thm_tactical -> thm_tactical -> thm_tactical = <fun>
val orelse_tcl_ : thm_tactical -> thm_tactical -> thm_tactical = <fun>
val REPEAT_TCL : thm_tactical -> thm_tactical = <fun>
val REPEAT_GTCL : thm_tactical -> thm_tactical = <fun>
val ALL_THEN : thm_tactical = <fun>
val NO_THEN : thm_tactical = <fun>
val EVERY_TCL : thm_tactical list -> thm_tactical = <fun>
val FIRST_TCL : thm_tactical list -> thm_tactical = <fun>
val LABEL_TAC : string -> thm_tactic = <fun>
val ASSUME_TAC : thm_tactic = <fun>
val FIND_ASSUM : thm_tactic -> term -> tactic = <fun>
val POP_ASSUM : thm_tactic -> tactic = <fun>
val ASSUM_LIST : (thm list -> tactic) -> tactic = <fun>
val POP_ASSUM_LIST : (thm list -> tactic) -> tactic = <fun>
val EVERY_ASSUM : thm_tactic -> tactic = <fun>
val FIRST_ASSUM : thm_tactic -> tactic = <fun>
val RULE_ASSUM_TAC : (thm -> thm) -> tactic = <fun>
val USE_THEN : string -> thm_tactic -> tactic = <fun>
val REMOVE_THEN : string -> thm_tactic -> tactic = <fun>
val ASM : (thm list -> tactic) -> thm list -> tactic = <fun>
val HYP : (thm list -> tactic) -> string -> thm list -> tactic = <fun>
val ACCEPT_TAC : thm_tactic = <fun>
val CONV_TAC : conv -> tactic = <fun>
val REFL_TAC : tactic = <fun>
val ABS_TAC : tactic = <fun>
val MK_COMB_TAC : tactic = <fun>
val AP_TERM_TAC : tactic = <fun>
val AP_THM_TAC : tactic = <fun>
val BINOP_TAC : tactic = <fun>
val SUBST1_TAC : thm_tactic = <fun>
val SUBST_ALL_TAC : thm -> tactic = <fun>
val BETA_TAC : tactic = <fun>
val SUBST_VAR_TAC : thm -> tactic = <fun>
val DISCH_TAC : tactic = <fun>
val MP_TAC : thm_tactic = <fun>
val EQ_TAC : tactic = <fun>
val UNDISCH_TAC : term -> tactic = <fun>
val SPEC_TAC : term * term -> tactic = <fun>
val X_GEN_TAC : term -> tactic = <fun>
val X_CHOOSE_TAC : term -> thm_tactic = <fun>
val EXISTS_TAC : term -> tactic = <fun>
val GEN_TAC : tactic = <fun>
val CHOOSE_TAC : thm_tactic = <fun>
val CONJ_TAC : tactic = <fun>
val DISJ1_TAC : tactic = <fun>
val DISJ2_TAC : tactic = <fun>
val DISJ_CASES_TAC : thm_tactic = <fun>
val CONTR_TAC : thm_tactic = <fun>
val MATCH_ACCEPT_TAC : thm_tactic = <fun>
val MATCH_MP_TAC : thm_tactic = <fun>
val TRANS_TAC : thm -> term -> tactic = <fun>
val CONJUNCTS_THEN2 : thm_tactic -> thm_tactic -> thm_tactic = <fun>
val CONJUNCTS_THEN : thm_tactical = <fun>
val DISJ_CASES_THEN2 : thm_tactic -> thm_tactic -> thm_tactic = <fun>
val DISJ_CASES_THEN : thm_tactical = <fun>
val DISCH_THEN : thm_tactic -> tactic = <fun>
val X_CHOOSE_THEN : term -> thm_tactical = <fun>
val CHOOSE_THEN : thm_tactical = <fun>
val STRIP_THM_THEN : thm_tactical = <fun>
val ANTE_RES_THEN : thm_tactical = <fun>
val IMP_RES_THEN : thm_tactical = <fun>
val STRIP_ASSUME_TAC : thm_tactic = <fun>
val STRUCT_CASES_THEN : thm_tactic -> thm_tactic = <fun>
val STRUCT_CASES_TAC : thm_tactic = <fun>
val STRIP_GOAL_THEN : thm_tactic -> tactic = <fun>
val STRIP_TAC : tactic = <fun>
val UNDISCH_THEN : term -> thm_tactic -> tactic = <fun>
val FIRST_X_ASSUM : thm_tactic -> tactic = <fun>
val SUBGOAL_THEN : term -> thm_tactic -> tactic = <fun>
val SUBGOAL_TAC : string -> term -> tactic list -> tactic = <fun>
val FREEZE_THEN : thm_tactical = <fun>
val X_META_EXISTS_TAC : term -> tactic = <fun>
val META_EXISTS_TAC : (string * thm) list * term -> goalstate = <fun>
val META_SPEC_TAC : term -> thm -> tactic = <fun>
val CHEAT_TAC : tactic = <fun>
val RECALL_ACCEPT_TAC : ('a -> thm) -> 'a -> goal -> goalstate = <fun>
val ANTS_TAC : tactic = <fun>
val print_goal : goal -> unit = <fun>
val print_goalstack : goalstack -> unit = <fun>
val by : tactic -> refinement = <fun>
val rotate : int -> refinement = <fun>
val mk_goalstate : goal -> goalstate = <fun>
val TAC_PROOF : goal * tactic -> thm = <fun>
val prove : term * tactic -> thm = <fun>
val current_goalstack : goalstack ref = {contents = []}
val refine : refinement -> goalstack = <fun>
val flush_goalstack : unit -> unit = <fun>
val e : tactic -> goalstack = <fun>
val r : int -> goalstack = <fun>
val set_goal : term list * term -> goalstack = <fun>
val g : term -> goalstack = <fun>
val b : unit -> goalstack = <fun>
val p : unit -> goalstack = <fun>
val top_realgoal : unit -> (string * thm) list * term = <fun>
val top_goal : unit -> term list * term = <fun>
val top_thm : unit -> thm = <fun>
- : unit = ()
File "tactics.ml" already loaded
- : unit = ()
val UNIFY_ACCEPT_TAC :
  term list ->
  thm ->
  'a * term ->
  ('b list * instantiation) * 'c list * (instantiation -> 'd list -> thm) =
  <fun>
val ITAUT_TAC : tactic = <fun>
val ITAUT : term -> thm = <fun>
- : unit = ()
File "itab.ml" already loaded
- : unit = ()
type gconv = int * conv
val REWR_CONV : thm -> term -> thm = <fun>
val IMP_REWR_CONV : thm -> term -> thm = <fun>
val ORDERED_REWR_CONV : (term -> term -> bool) -> thm -> term -> thm = <fun>
val ORDERED_IMP_REWR_CONV : (term -> term -> bool) -> thm -> term -> thm =
  <fun>
val term_order : term -> term -> bool = <fun>
val net_of_thm :
  bool -> thm -> (int * (term -> thm)) net -> (int * (term -> thm)) net =
  <fun>
val net_of_conv : term -> 'a -> (int * 'a) net -> (int * 'a) net = <fun>
val net_of_cong :
  thm -> (int * (term -> thm)) net -> (int * (term -> thm)) net = <fun>
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Warning: inventing type variables
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val mk_rewrites : bool -> thm -> thm list -> thm list = <fun>
val REWRITES_CONV : ('a * (term -> 'b)) net -> term -> 'b = <fun>
type prover = Prover of conv * (thm list -> prover)
val mk_prover : ('a -> conv) -> ('a -> thm list -> 'a) -> 'a -> prover =
  <fun>
val augment : prover -> thm list -> prover = <fun>
val apply_prover : prover -> term -> thm = <fun>
type simpset =
    Simpset of gconv net * (strategy -> strategy) * prover list *
      (thm -> thm list -> thm list)
and strategy = simpset -> int -> term -> thm
val basic_prover :
  (simpset -> 'a -> term -> thm) -> simpset -> 'a -> term -> thm = <fun>
val ss_of_thms : thm list -> simpset -> simpset = <fun>
val ss_of_conv : term -> conv -> simpset -> simpset = <fun>
val ss_of_congs : thm list -> simpset -> simpset = <fun>
val ss_of_prover : (strategy -> strategy) -> simpset -> simpset = <fun>
val ss_of_provers : prover list -> simpset -> simpset = <fun>
val ss_of_maker : (thm -> thm list -> thm list) -> simpset -> simpset = <fun>
val AUGMENT_SIMPSET : thm -> simpset -> simpset = <fun>
val ONCE_DEPTH_SQCONV : strategy = <fun>
val DEPTH_SQCONV : strategy = <fun>
val REDEPTH_SQCONV : strategy = <fun>
val TOP_DEPTH_SQCONV : strategy = <fun>
val TOP_SWEEP_SQCONV : strategy = <fun>
val set_basic_rewrites : thm list -> unit = <fun>
val extend_basic_rewrites : thm list -> unit = <fun>
val basic_rewrites : unit -> thm list = <fun>
val set_basic_convs : (string * (term * conv)) list -> unit = <fun>
val extend_basic_convs : string * (term * conv) -> unit = <fun>
val basic_convs : unit -> (string * (term * conv)) list = <fun>
val basic_net : unit -> gconv net = <fun>
val set_basic_congs : thm list -> unit = <fun>
val extend_basic_congs : thm list -> unit = <fun>
val basic_congs : unit -> thm list = <fun>
val GENERAL_REWRITE_CONV :
  bool -> (conv -> conv) -> gconv net -> thm list -> conv = <fun>
val GEN_REWRITE_CONV : (conv -> conv) -> thm list -> conv = <fun>
val PURE_REWRITE_CONV : thm list -> conv = <fun>
val REWRITE_CONV : thm list -> conv = <fun>
val PURE_ONCE_REWRITE_CONV : thm list -> conv = <fun>
val ONCE_REWRITE_CONV : thm list -> conv = <fun>
val GEN_REWRITE_RULE : (conv -> conv) -> thm list -> thm -> thm = <fun>
val PURE_REWRITE_RULE : thm list -> thm -> thm = <fun>
val REWRITE_RULE : thm list -> thm -> thm = <fun>
val PURE_ONCE_REWRITE_RULE : thm list -> thm -> thm = <fun>
val ONCE_REWRITE_RULE : thm list -> thm -> thm = <fun>
val PURE_ASM_REWRITE_RULE : thm list -> thm -> thm = <fun>
val ASM_REWRITE_RULE : thm list -> thm -> thm = <fun>
val PURE_ONCE_ASM_REWRITE_RULE : thm list -> thm -> thm = <fun>
val ONCE_ASM_REWRITE_RULE : thm list -> thm -> thm = <fun>
val GEN_REWRITE_TAC : (conv -> conv) -> thm list -> tactic = <fun>
val PURE_REWRITE_TAC : thm list -> tactic = <fun>
val REWRITE_TAC : thm list -> tactic = <fun>
val PURE_ONCE_REWRITE_TAC : thm list -> tactic = <fun>
val ONCE_REWRITE_TAC : thm list -> tactic = <fun>
val PURE_ASM_REWRITE_TAC : thm list -> tactic = <fun>
val ASM_REWRITE_TAC : thm list -> tactic = <fun>
val PURE_ONCE_ASM_REWRITE_TAC : thm list -> tactic = <fun>
val ONCE_ASM_REWRITE_TAC : thm list -> tactic = <fun>
val GEN_SIMPLIFY_CONV : strategy -> simpset -> int -> thm list -> conv =
  <fun>
val ONCE_SIMPLIFY_CONV : simpset -> thm list -> conv = <fun>
val SIMPLIFY_CONV : simpset -> thm list -> conv = <fun>
val empty_ss : simpset = Simpset (Netnode ([], []), <fun>, [], <fun>)
val basic_ss : thm list -> simpset = <fun>
val SIMP_CONV : thm list -> conv = <fun>
val PURE_SIMP_CONV : thm list -> conv = <fun>
val ONCE_SIMP_CONV : thm list -> conv = <fun>
val SIMP_RULE : thm list -> thm -> thm = <fun>
val PURE_SIMP_RULE : thm list -> thm -> thm = <fun>
val ONCE_SIMP_RULE : thm list -> thm -> thm = <fun>
val SIMP_TAC : thm list -> tactic = <fun>
val PURE_SIMP_TAC : thm list -> tactic = <fun>
val ONCE_SIMP_TAC : thm list -> tactic = <fun>
val ASM_SIMP_TAC : thm list -> tactic = <fun>
val PURE_ASM_SIMP_TAC : thm list -> tactic = <fun>
val ONCE_ASM_SIMP_TAC : thm list -> tactic = <fun>
val ABBREV_TAC : term -> (string * thm) list * term -> goalstate = <fun>
val EXPAND_TAC : string -> tactic = <fun>
- : unit = ()
File "simp.ml" already loaded
- : unit = ()
val EQ_REFL : thm = |- !x. x = x
val REFL_CLAUSE : thm = |- !x. x = x <=> T
val EQ_SYM : thm = |- !x y. x = y ==> y = x
val EQ_SYM_EQ : thm = |- !x y. x = y <=> y = x
val EQ_TRANS : thm = |- !x y z. x = y /\ y = z ==> x = z
val AC : thm -> term -> thm = <fun>
val BETA_THM : thm = |- !f y. (\x. f x) y = f y
val ABS_SIMP : thm = |- !t1 t2. (\x. t1) t2 = t1
Searching with limit 0
Searching with limit 1
val CONJ_ASSOC : thm = |- !t1 t2 t3. t1 /\ t2 /\ t3 <=> (t1 /\ t2) /\ t3
Searching with limit 0
Searching with limit 1
val CONJ_SYM : thm = |- !t1 t2. t1 /\ t2 <=> t2 /\ t1
Searching with limit 0
Searching with limit 1
val CONJ_ACI : thm =
  |- (p /\ q <=> q /\ p) /\
     ((p /\ q) /\ r <=> p /\ q /\ r) /\
     (p /\ q /\ r <=> q /\ p /\ r) /\
     (p /\ p <=> p) /\
     (p /\ p /\ q <=> p /\ q)
Searching with limit 0
Searching with limit 1
val DISJ_ASSOC : thm = |- !t1 t2 t3. t1 \/ t2 \/ t3 <=> (t1 \/ t2) \/ t3
Searching with limit 0
Searching with limit 1
val DISJ_SYM : thm = |- !t1 t2. t1 \/ t2 <=> t2 \/ t1
Searching with limit 0
Searching with limit 1
val DISJ_ACI : thm =
  |- (p \/ q <=> q \/ p) /\
     ((p \/ q) \/ r <=> p \/ q \/ r) /\
     (p \/ q \/ r <=> q \/ p \/ r) /\
     (p \/ p <=> p) /\
     (p \/ p \/ q <=> p \/ q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val IMP_CONJ : thm = |- p /\ q ==> r <=> p ==> q ==> r
val IMP_IMP : thm = |- p ==> q ==> r <=> p /\ q ==> r
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val IMP_CONJ_ALT : thm = |- p /\ q ==> r <=> q ==> p ==> r
Searching with limit 0
Searching with limit 1
val LEFT_OR_DISTRIB : thm = |- !p q r. p /\ (q \/ r) <=> p /\ q \/ p /\ r
Searching with limit 0
Searching with limit 1
val RIGHT_OR_DISTRIB : thm = |- !p q r. (p \/ q) /\ r <=> p /\ r \/ q /\ r
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val FORALL_SIMP : thm = |- !t. (!x. t) <=> t
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val EXISTS_SIMP : thm = |- !t. (?x. t) <=> t
Searching with limit 0
Searching with limit 1
Searching with limit 2
val EQ_IMP : thm = |- (a <=> b) ==> a ==> b
Searching with limit 0
Searching with limit 1
Searching with limit 2
val EQ_CLAUSES : thm =
  |- !t. ((T <=> t) <=> t) /\
         ((t <=> T) <=> t) /\
         ((F <=> t) <=> ~t) /\
         ((t <=> F) <=> ~t)
Searching with limit 0
Searching with limit 1
Searching with limit 2
val NOT_CLAUSES_WEAK : thm = |- (~T <=> F) /\ (~F <=> T)
Searching with limit 0
Searching with limit 1
val AND_CLAUSES : thm =
  |- !t. (T /\ t <=> t) /\
         (t /\ T <=> t) /\
         (F /\ t <=> F) /\
         (t /\ F <=> F) /\
         (t /\ t <=> t)
Searching with limit 0
Searching with limit 1
val OR_CLAUSES : thm =
  |- !t. (T \/ t <=> T) /\
         (t \/ T <=> T) /\
         (F \/ t <=> t) /\
         (t \/ F <=> t) /\
         (t \/ t <=> t)
Searching with limit 0
Searching with limit 1
Searching with limit 2
val IMP_CLAUSES : thm =
  |- !t. (T ==> t <=> t) /\
         (t ==> T <=> T) /\
         (F ==> t <=> T) /\
         (t ==> t <=> T) /\
         (t ==> F <=> ~t)
Warning: inventing type variables
- : unit = ()
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
- : unit = ()
val EXISTS_UNIQUE_THM : thm =
  |- !P. (?!x. P x) <=> (?x. P x) /\ (!x x'. P x /\ P x' ==> x = x')
val EXISTS_REFL : thm = |- !a. ?x. x = a
val EXISTS_UNIQUE_REFL : thm = |- !a. ?!x. x = a
val UNWIND_THM1 : thm = |- !P a. (?x. a = x /\ P x) <=> P a
val UNWIND_THM2 : thm = |- !P a. (?x. x = a /\ P x) <=> P a
val FORALL_UNWIND_THM2 : thm = |- !P a. (!x. x = a ==> P x) <=> P a
Warning: inventing type variables
val FORALL_UNWIND_THM1 : thm = |- !P a. (!x. a = x ==> P x) <=> P a
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
Searching with limit 5
val SWAP_FORALL_THM : thm = |- !P. (!x y. P x y) <=> (!y x. P x y)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
Searching with limit 5
val SWAP_EXISTS_THM : thm = |- !P. (?x y. P x y) <=> (?y x. P x y)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val FORALL_AND_THM : thm =
  |- !P Q. (!x. P x /\ Q x) <=> (!x. P x) /\ (!x. Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val AND_FORALL_THM : thm =
  |- !P Q. (!x. P x) /\ (!x. Q x) <=> (!x. P x /\ Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val LEFT_AND_FORALL_THM : thm = |- !P Q. (!x. P x) /\ Q <=> (!x. P x /\ Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val RIGHT_AND_FORALL_THM : thm = |- !P Q. P /\ (!x. Q x) <=> (!x. P /\ Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val EXISTS_OR_THM : thm =
  |- !P Q. (?x. P x \/ Q x) <=> (?x. P x) \/ (?x. Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val OR_EXISTS_THM : thm =
  |- !P Q. (?x. P x) \/ (?x. Q x) <=> (?x. P x \/ Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val LEFT_OR_EXISTS_THM : thm = |- !P Q. (?x. P x) \/ Q <=> (?x. P x \/ Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val RIGHT_OR_EXISTS_THM : thm = |- !P Q. P \/ (?x. Q x) <=> (?x. P \/ Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val LEFT_EXISTS_AND_THM : thm = |- !P Q. (?x. P x /\ Q) <=> (?x. P x) /\ Q
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val RIGHT_EXISTS_AND_THM : thm = |- !P Q. (?x. P /\ Q x) <=> P /\ (?x. Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val TRIV_EXISTS_AND_THM : thm = |- !P Q. (?x. P /\ Q) <=> (?x. P) /\ (?x. Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val LEFT_AND_EXISTS_THM : thm = |- !P Q. (?x. P x) /\ Q <=> (?x. P x /\ Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val RIGHT_AND_EXISTS_THM : thm = |- !P Q. P /\ (?x. Q x) <=> (?x. P /\ Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val TRIV_AND_EXISTS_THM : thm = |- !P Q. (?x. P) /\ (?x. Q) <=> (?x. P /\ Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val TRIV_FORALL_OR_THM : thm = |- !P Q. (!x. P \/ Q) <=> (!x. P) \/ (!x. Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val TRIV_OR_FORALL_THM : thm = |- !P Q. (!x. P) \/ (!x. Q) <=> (!x. P \/ Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val RIGHT_IMP_FORALL_THM : thm = |- !P Q. P ==> (!x. Q x) <=> (!x. P ==> Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val RIGHT_FORALL_IMP_THM : thm = |- !P Q. (!x. P ==> Q x) <=> P ==> (!x. Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val LEFT_IMP_EXISTS_THM : thm = |- !P Q. (?x. P x) ==> Q <=> (!x. P x ==> Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val LEFT_FORALL_IMP_THM : thm = |- !P Q. (!x. P x ==> Q) <=> (?x. P x) ==> Q
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val TRIV_FORALL_IMP_THM : thm =
  |- !P Q. (!x. P ==> Q) <=> (?x. P) ==> (!x. Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val TRIV_EXISTS_IMP_THM : thm =
  |- !P Q. (?x. P ==> Q) <=> (!x. P) ==> (?x. Q)
val EXISTS_UNIQUE_ALT : thm = |- !P. (?!x. P x) <=> (?x. !y. P y <=> x = y)
Searching with limit 0
Searching with limit 1
Searching with limit 2
val EXISTS_UNIQUE : thm =
  |- !P. (?!x. P x) <=> (?x. P x /\ (!y. P y ==> y = x))
val DESTRUCT_TAC : string -> thm_tactic = <fun>
val FIX_TAC : string -> tactic = <fun>
val INTRO_TAC : string -> tactic = <fun>
- : unit = ()
File "theorems.ml" already loaded
- : unit = ()
val strip_ncomb : int -> term -> term * term list = <fun>
val RIGHT_BETAS : term list -> thm -> thm = <fun>
val EXISTS_EQUATION : term -> thm -> thm = <fun>
val derive_nonschematic_inductive_relations : term -> thm = <fun>
Searching with limit 0
Searching with limit 1
Searching with limit 2
val MONO_AND : thm = |- (A ==> B) /\ (C ==> D) ==> A /\ C ==> B /\ D
Searching with limit 0
Searching with limit 1
Searching with limit 2
val MONO_OR : thm = |- (A ==> B) /\ (C ==> D) ==> A \/ C ==> B \/ D
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val MONO_IMP : thm = |- (B ==> A) /\ (C ==> D) ==> (A ==> C) ==> B ==> D
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val MONO_NOT : thm = |- (B ==> A) ==> ~A ==> ~B
val MONO_FORALL : thm = |- (!x. P x ==> Q x) ==> (!x. P x) ==> (!x. Q x)
val MONO_EXISTS : thm = |- (!x. P x ==> Q x) ==> (?x. P x) ==> (?x. Q x)
val monotonicity_theorems : thm list ref =
  {contents =
    [|- (A ==> B) /\ (C ==> D) ==> A /\ C ==> B /\ D;
     |- (A ==> B) /\ (C ==> D) ==> A \/ C ==> B \/ D;
     |- (B ==> A) /\ (C ==> D) ==> (A ==> C) ==> B ==> D;
     |- (B ==> A) ==> ~A ==> ~B;
     |- (!x. P x ==> Q x) ==> (?x. P x) ==> (?x. Q x);
     |- (!x. P x ==> Q x) ==> (!x. P x) ==> (!x. Q x)]}
Searching with limit 0
Searching with limit 1
val MONO_TAC : goal -> goalstate = <fun>
val prove_monotonicity_hyps : thm -> thm = <fun>
val the_inductive_definitions : '_a list ref = {contents = []}
val prove_inductive_relations_exist : term -> thm = <fun>
val new_inductive_definition : term -> thm * thm * thm = <fun>
val derive_strong_induction : thm * thm -> thm = <fun>
- : unit = ()
File "ind_defs.ml" already loaded
- : unit = ()
val ETA_AX : thm = |- !t. (\x. t x) = t
val ETA_CONV : term -> thm = <fun>
val EQ_EXT : thm = |- !f g. (!x. f x = g x) ==> f = g
val FUN_EQ_THM : thm = |- !f g. f = g <=> (!x. f x = g x)
- : unit = ()
- : unit = ()
val is_select : term -> bool = <fun>
val dest_select : term -> term * term = <fun>
val mk_select : term * term -> term = <fun>
val SELECT_AX : thm = |- !P x. P x ==> P ((@) P)
val EXISTS_THM : thm = |- (?) = (\P. P ((@) P))
val SELECT_RULE : thm -> thm = <fun>
val SELECT_CONV : term -> thm = <fun>
val SELECT_REFL : thm = |- !x. (@y. y = x) = x
val SELECT_UNIQUE : thm = |- !P x. (!y. P y <=> y = x) ==> (@) P = x
- : unit = ()
val the_type_definitions :
  ((string * string * string) * (thm * thm)) list ref = {contents = []}
val new_type_definition : string -> string * string -> thm -> thm = <fun>
Searching with limit 0
Searching with limit 1
Searching with limit 0
Searching with limit 1
Searching with limit 2
val EXCLUDED_MIDDLE : thm = |- !t. t \/ ~t
val BOOL_CASES_AX : thm = |- !t. (t <=> T) \/ (t <=> F)
val BOOL_CASES_TAC : term -> tactic = <fun>
val ASM_CASES_TAC : term -> tactic = <fun>
val TAUT : term -> thm = <fun>
val DE_MORGAN_THM : thm =
  |- !t1 t2. (~(t1 /\ t2) <=> ~t1 \/ ~t2) /\ (~(t1 \/ t2) <=> ~t1 /\ ~t2)
val NOT_CLAUSES : thm = |- (!t. ~ ~t <=> t) /\ (~T <=> F) /\ (~F <=> T)
val NOT_IMP : thm = |- !t1 t2. ~(t1 ==> t2) <=> t1 /\ ~t2
val CONTRAPOS_THM : thm = |- !t1 t2. ~t1 ==> ~t2 <=> t2 ==> t1
- : unit = ()
val CCONTR : term -> thm -> thm = <fun>
val CONTRAPOS_CONV : term -> thm = <fun>
val REFUTE_THEN : thm_tactic -> (string * thm) list * term -> goalstate =
  <fun>
val NOT_EXISTS_THM : thm = |- !P. ~(?x. P x) <=> (!x. ~P x)
val EXISTS_NOT_THM : thm = |- !P. (?x. ~P x) <=> ~(!x. P x)
val NOT_FORALL_THM : thm = |- !P. ~(!x. P x) <=> (?x. ~P x)
val FORALL_NOT_THM : thm = |- !P. (!x. ~P x) <=> ~(?x. P x)
val FORALL_BOOL_THM : thm = |- (!b. P b) <=> P T /\ P F
val EXISTS_BOOL_THM : thm = |- (?b. P b) <=> P T \/ P F
val LEFT_FORALL_OR_THM : thm = |- !P Q. (!x. P x \/ Q) <=> (!x. P x) \/ Q
val RIGHT_FORALL_OR_THM : thm = |- !P Q. (!x. P \/ Q x) <=> P \/ (!x. Q x)
val LEFT_OR_FORALL_THM : thm = |- !P Q. (!x. P x) \/ Q <=> (!x. P x \/ Q)
val RIGHT_OR_FORALL_THM : thm = |- !P Q. P \/ (!x. Q x) <=> (!x. P \/ Q x)
val LEFT_IMP_FORALL_THM : thm = |- !P Q. (!x. P x) ==> Q <=> (?x. P x ==> Q)
val LEFT_EXISTS_IMP_THM : thm = |- !P Q. (?x. P x ==> Q) <=> (!x. P x) ==> Q
val RIGHT_IMP_EXISTS_THM : thm = |- !P Q. P ==> (?x. Q x) <=> (?x. P ==> Q x)
val RIGHT_EXISTS_IMP_THM : thm = |- !P Q. (?x. P ==> Q x) <=> P ==> (?x. Q x)
val COND_DEF : thm =
  |- COND = (\t t1 t2. @x. ((t <=> T) ==> x = t1) /\ ((t <=> F) ==> x = t2))
val COND_CLAUSES : thm =
  |- !t1 t2. (if T then t1 else t2) = t1 /\ (if F then t1 else t2) = t2
val is_cond : term -> bool = <fun>
val mk_cond : term * term * term -> term = <fun>
val dest_cond : term -> term * (term * term) = <fun>
- : unit = ()
val COND_EXPAND : thm =
  |- !b t1 t2. (if b then t1 else t2) <=> (~b \/ t1) /\ (b \/ t2)
val COND_ID : thm = |- !b t. (if b then t else t) = t
val COND_RAND : thm =
  |- !b f x y. f (if b then x else y) = (if b then f x else f y)
val COND_RATOR : thm =
  |- !b f g x. (if b then f else g) x = (if b then f x else g x)
val COND_ABS : thm =
  |- !b f g. (\x. if b then f x else g x) = (if b then f else g)
val TAUT : term -> thm = <fun>
val MONO_COND : thm =
  |- (A ==> B) /\ (C ==> D) ==> (if b then A else C) ==> (if b then B else D)
- : unit = ()
val COND_ELIM_THM : thm =
  |- P (if c then x else y) <=> (c ==> P x) /\ (~c ==> P y)
val COND_ELIM_CONV : term -> thm = <fun>
val COND_CASES_TAC : tactic = <fun>
val SKOLEM_THM : thm = |- !P. (!x. ?y. P x y) <=> (?y. !x. P x (y x))
Warning: inventing type variables
val SKOLEM_THM_GEN : thm =
  |- !P s. (!x. P x ==> (?y. R x y)) <=> (?f. !x. P x ==> R x (f x))
val UNIQUE_SKOLEM_ALT : thm =
  |- !P. (!x. ?!y. P x y) <=> (?f. !x y. P x y <=> f x = y)
val UNIQUE_SKOLEM_THM : thm =
  |- !P. (!x. ?!y. P x y) <=> (?!f. !x. P x (f x))
Warning: inventing type variables
- : unit = ()
Warning: inventing type variables
- : unit = ()
val bool_INDUCT : thm = |- !P. P F /\ P T ==> (!x. P x)
val bool_RECURSION : thm = |- !a b. ?f. f F = a /\ f T = b
val inductive_type_store : (string * (int * thm * thm)) list ref =
  {contents =
    [("bool",
      (2, |- !P. P F /\ P T ==> (!x. P x), |- !a b. ?f. f F = a /\ f T = b))]}
- : unit = ()
File "class.ml" already loaded
- : unit = ()
- : unit = ()
val o_DEF : thm = |- !f g. f o g = (\x. f (g x))
val I_DEF : thm = |- I = (\x. x)
val o_THM : thm = |- !f g x. (f o g) x = f (g x)
val o_ASSOC : thm = |- !f g h. f o g o h = (f o g) o h
val I_THM : thm = |- !x. I x = x
val I_O_ID : thm = |- !f. I o f = f /\ f o I = f
val EXISTS_ONE_REP : thm = |- ?b. b
val one_tydef : thm =
  |- (!a. one_ABS (one_REP a) = a) /\ (!r. r <=> one_REP (one_ABS r) <=> r)
val one_DEF : thm = |- one = (@x. T)
val one : thm = |- !v. v = one
val one_axiom : thm = |- !f g. f = g
val one_INDUCT : thm = |- !P. P one ==> (!x. P x)
val one_RECURSION : thm = |- !e. ?fn. fn one = e
val one_Axiom : thm = |- !e. ?!fn. fn one = e
- : unit = ()
- : unit = ()
File "trivia.ml" already loaded
- : unit = ()
val PRESIMP_CONV : conv = <fun>
val CONJ_ACI_RULE : term -> thm = <fun>
val DISJ_ACI_RULE : term -> thm = <fun>
val CONJ_CANON_CONV : term -> thm = <fun>
val DISJ_CANON_CONV : term -> thm = <fun>
val GEN_NNF_CONV : bool -> conv * (term -> thm * thm) -> conv = <fun>
val NNF_CONV : conv = <fun>
val NNFC_CONV : conv = <fun>
val SKOLEM_CONV : conv = <fun>
val PRENEX_CONV : conv = <fun>
val WEAK_DNF_CONV : conv = <fun>
val DNF_CONV : conv = <fun>
val WEAK_CNF_CONV : conv = <fun>
val CNF_CONV : conv = <fun>
val ASSOC_CONV : thm -> term -> thm = <fun>
val SELECT_ELIM_TAC : tactic = <fun>
Warning: inventing type variables
Warning: inventing type variables
val LAMBDA_ELIM_CONV : conv = <fun>
val CONDS_ELIM_CONV : conv = <fun>
val CONDS_CELIM_CONV : conv = <fun>
val ASM_FOL_TAC : (string * thm) list * term -> goalstate = <fun>
val PROP_ATOM_CONV : conv -> conv = <fun>
- : unit = ()
File "canon.ml" already loaded
- : unit = ()
val meson_depth : bool ref = {contents = false}
val meson_prefine : bool ref = {contents = true}
val meson_dcutin : int ref = {contents = 1}
val meson_skew : int ref = {contents = 3}
val meson_brand : bool ref = {contents = false}
val meson_split_limit : int ref = {contents = 8}
val meson_chatty : bool ref = {contents = false}
exception Cut
type fol_term = Fvar of int | Fnapp of int * fol_term list
type fol_atom = int * fol_term list
type fol_form =
    Atom of fol_atom
  | Conj of fol_form * fol_form
  | Disj of fol_form * fol_form
  | Forallq of int * fol_form
type fol_goal =
    Subgoal of fol_atom * fol_goal list * (int * thm) * int *
      (fol_term * int) list
val GEN_MESON_TAC : int -> int -> int -> thm list -> tactic = <fun>
val ASM_MESON_TAC : thm list -> tactic = <fun>
val MESON_TAC : thm list -> tactic = <fun>
val MESON : thm list -> term -> thm = <fun>
- : unit = ()
File "meson.ml" already loaded
- : unit = ()
val define_quotient_type : string -> string * string -> term -> thm * thm =
  <fun>
val lift_function : thm -> thm * thm -> string -> thm -> thm * thm = <fun>
0..0..1..3..7..15..26..54..86..136..solved at 208
0..0..1..solved at 4
0..0..solved at 2
0..0..1..4..solved at 10
0..0..1..4..9..solved at 21
0..0..solved at 2
0..0..1..solved at 4
0..0..1..2..6..11..22..38..70..solved at 116
0..0..solved at 2
0..0..solved at 2
0..0..1..2..6..11..22..41..76..solved at 108
0..0..1..solved at 4
0..0..solved at 2
val lift_theorem : thm * thm -> thm * thm * thm -> thm list -> thm -> thm =
  <fun>
- : unit = ()
val IMP_REWRITE_TAC : thm list -> tactic = <fun>
val TARGET_REWRITE_TAC : thm list -> thm -> tactic = <fun>
val HINT_EXISTS_TAC : tactic = <fun>
val SEQ_IMP_REWRITE_TAC : thm list -> tactic = <fun>
val CASE_REWRITE_TAC : thm -> tactic = <fun>
- : unit = ()
File "quot.ml" already loaded
- : unit = ()
val LET_DEF : thm = |- !f x. LET f x = f x
val LET_END_DEF : thm = |- !t. LET_END t = t
val GABS_DEF : thm = |- !P. GABS P = (@) P
val GEQ_DEF : thm = |- !a b. GEQ a b <=> a = b
Warning: inventing type variables
val _SEQPATTERN : thm =
  |- _SEQPATTERN = (\r s x. if ?y. r x y then r x else s x)
val _UNGUARDED_PATTERN : thm = |- _UNGUARDED_PATTERN = (\p r. p /\ r)
val _GUARDED_PATTERN : thm = |- _GUARDED_PATTERN = (\p g r. p /\ g /\ r)
Warning: inventing type variables
val _MATCH : thm =
  |- _MATCH = (\e r. if (?!) (r e) then (@) (r e) else @z. F)
Warning: inventing type variables
val _FUNCTION : thm =
  |- _FUNCTION = (\r x. if (?!) (r x) then (@) (r x) else @z. F)
val mk_pair_def : thm = |- !x y. mk_pair x y = (\a b. a = x /\ b = y)
0..0..solved at 2
val PAIR_EXISTS_THM : thm = |- ?x a b. x = mk_pair a b
val prod_tybij : thm =
  |- (!a. ABS_prod (REP_prod a) = a) /\
     (!r. (?a b. r = mk_pair a b) <=> REP_prod (ABS_prod r) = r)
0..0..1..solved at 4
val REP_ABS_PAIR : thm =
  |- !x y. REP_prod (ABS_prod (mk_pair x y)) = mk_pair x y
- : unit = ()
val COMMA_DEF : thm = |- !x y. x,y = ABS_prod (mk_pair x y)
val FST_DEF : thm = |- !p. FST p = (@x. ?y. p = x,y)
val SND_DEF : thm = |- !p. SND p = (@y. ?x. p = x,y)
0..0..1..2..solved at 6
0..0..1..2..solved at 6
0..0..solved at 2
val PAIR_EQ : thm = |- !x y a b. x,y = a,b <=> x = a /\ y = b
val PAIR_SURJECTIVE : thm = |- !p. ?x y. p = x,y
val FST : thm = |- !x y. FST (x,y) = x
val SND : thm = |- !x y. SND (x,y) = y
val PAIR : thm = |- !x. FST x,SND x = x
Warning: inventing type variables
val pair_INDUCT : thm = |- !P. (!x y. P (x,y)) ==> (!p. P p)
val pair_RECURSION : thm = |- !PAIR'. ?fn. !a0 a1. fn (a0,a1) = PAIR' a0 a1
val is_pair : term -> bool = <fun>
val dest_pair : term -> term * term = <fun>
val mk_pair : term * term -> term = <fun>
- : unit = ()
val the_definitions : thm list ref =
  {contents =
    [|- !p. SND p = (@y. ?x. p = x,y); |- !p. FST p = (@x. ?y. p = x,y);
     |- !x y. x,y = ABS_prod (mk_pair x y);
     |- !x y. mk_pair x y = (\a b. a = x /\ b = y);
     |- !a b. GEQ a b <=> a = b; |- !P. GABS P = (@) P; |- !t. LET_END t = t;
     |- !f x. LET f x = f x; |- one = (@x. T); |- I = (\x. x);
     |- !f g. f o g = (\x. f (g x));
     |- COND =
        (\t t1 t2. @x. ((t <=> T) ==> x = t1) /\ ((t <=> F) ==> x = t2));
     |- _FALSITY_ <=> F;
     |- (?!) = (\P. (?) P /\ (!x y. P x /\ P y ==> x = y));
     |- (~) = (\p. p ==> F); |- F <=> (!p. p);
     |- (\/) = (\p q. !r. (p ==> r) ==> (q ==> r) ==> r);
     |- (?) = (\P. !q. (!x. P x ==> q) ==> q); |- (!) = (\P. P = (\x. T));
     |- (==>) = (\p q. p /\ q <=> p);
     |- (/\) = (\p q. (\f. f p q) = (\f. f T T)); |- T <=> (\p. p) = (\p. p)]}
val new_definition : term -> thm = <fun>
val CURRY_DEF : thm = |- !f x y. CURRY f x y = f (x,y)
val UNCURRY_DEF : thm = |- !f x y. UNCURRY f (x,y) = f x y
val PASSOC_DEF : thm = |- !f x y z. PASSOC f (x,y,z) = f ((x,y),z)
val GABS_CONV : conv -> term -> thm = <fun>
Warning: inventing type variables
val GEN_BETA_CONV : term -> thm = <fun>
Warning: inventing type variables
- : unit = ()
- : unit = ()
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..solved at 6
val FORALL_PAIR_THM : thm = |- !P. (!p. P p) <=> (!p1 p2. P (p1,p2))
Warning: inventing type variables
0..0..1..2..6..11..solved at 22
0..0..solved at 2
val EXISTS_PAIR_THM : thm = |- !P. (?p. P p) <=> (?p1 p2. P (p1,p2))
Warning: inventing type variables
val LAMBDA_PAIR_THM : thm = |- !t. (\p. t p) = (\(x,y). t (x,y))
Warning: inventing type variables
val PAIRED_ETA_THM : thm =
  |- (!f. (\(x,y). f (x,y)) = f) /\
     (!f. (\(x,y,z). f (x,y,z)) = f) /\
     (!f. (\(w,x,y,z). f (w,x,y,z)) = f)
val FORALL_UNCURRY : thm = |- !P. (!f. P f) <=> (!f. P (\a b. f (a,b)))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
val EXISTS_UNCURRY : thm = |- !P. (?f. P f) <=> (?f. P (\a b. f (a,b)))
Warning: inventing type variables
val EXISTS_CURRY : thm = |- !P. (?f. P f) <=> (?f. P (\(a,b). f a b))
Warning: inventing type variables
val FORALL_CURRY : thm = |- !P. (!f. P f) <=> (!f. P (\(a,b). f a b))
Warning: inventing type variables
val FORALL_UNPAIR_THM : thm =
  |- !P. (!x y. P x y) <=> (!z. P (FST z) (SND z))
Warning: inventing type variables
val EXISTS_UNPAIR_THM : thm =
  |- !P. (?x y. P x y) <=> (?z. P (FST z) (SND z))
Warning: inventing type variables
val FORALL_PAIRED_THM : thm = |- !P. (!(x,y). P x y) <=> (!x y. P x y)
Warning: inventing type variables
val EXISTS_PAIRED_THM : thm = |- !P. (?(x,y). P x y) <=> (?x y. P x y)
Warning: inventing type variables
val FORALL_TRIPLED_THM : thm =
  |- !P. (!(x,y,z). P x y z) <=> (!x y z. P x y z)
Warning: inventing type variables
val EXISTS_TRIPLED_THM : thm =
  |- !P. (?(x,y,z). P x y z) <=> (?x y z. P x y z)
val let_CONV : term -> thm = <fun>
Warning: inventing type variables
0..0..1..5..13..solved at 26
0..0..1..5..13..solved at 26
0..0..solved at 2
Warning: inventing type variables
val LET_TAC : tactic = <fun>
- : unit = ()
File "pair.ml" already loaded
- : unit = ()
- : unit = ()
val ONE_ONE : thm = |- !f. ONE_ONE f <=> (!x1 x2. f x1 = f x2 ==> x1 = x2)
val ONTO : thm = |- !f. ONTO f <=> (!y. ?x. y = f x)
val INFINITY_AX : thm = |- ?f. ONE_ONE f /\ ~ONTO f
0..0..2..solved at 5
0..0..solved at 2
0..0..1..3..solved at 9
val IND_SUC_0_EXISTS : thm =
  |- ?f z. (!x1 x2. f x1 = f x2 <=> x1 = x2) /\ (!x. ~(f x = z))
val IND_SUC_SPEC : thm =
  |- (!x1 x2. IND_SUC x1 = IND_SUC x2 <=> x1 = x2) /\
     (!x. ~(IND_SUC x = IND_0))
val IND_SUC_INJ : thm = |- !x1 x2. IND_SUC x1 = IND_SUC x2 <=> x1 = x2
val IND_SUC_0 : thm = |- !x. ~(IND_SUC x = IND_0)
val NUM_REP_RULES : thm =
  |- NUM_REP IND_0 /\ (!i. NUM_REP i ==> NUM_REP (IND_SUC i))
val NUM_REP_INDUCT : thm =
  |- !NUM_REP'. NUM_REP' IND_0 /\ (!i. NUM_REP' i ==> NUM_REP' (IND_SUC i))
                ==> (!a. NUM_REP a ==> NUM_REP' a)
val NUM_REP_CASES : thm =
  |- !a. NUM_REP a <=> a = IND_0 \/ (?i. a = IND_SUC i /\ NUM_REP i)
val num_tydef : thm * thm =
  (|- mk_num (dest_num a) = a, |- NUM_REP r <=> dest_num (mk_num r) = r)
val ZERO_DEF : thm = |- _0 = mk_num IND_0
val SUC_DEF : thm = |- !n. SUC n = mk_num (IND_SUC (dest_num n))
0..0..1..2..5..9..15..29..44..68..142..260..solved at 420
val NOT_SUC : thm = |- !n. ~(SUC n = _0)
val SUC_INJ : thm = |- !m n. SUC m = SUC n <=> m = n
val num_INDUCTION : thm =
  |- !P. P _0 /\ (!n. P n ==> P (SUC n)) ==> (!n. P n)
val num_Axiom : thm =
  |- !e f. ?!fn. fn _0 = e /\ (!n. fn (SUC n) = f (fn n) n)
val NUMERAL : thm = |- !n. NUMERAL n = n
val NOT_SUC : thm = |- !n. ~(SUC n = 0)
val num_INDUCTION : thm = |- !P. P 0 /\ (!n. P n ==> P (SUC n)) ==> (!n. P n)
val num_Axiom : thm =
  |- !e f. ?!fn. fn 0 = e /\ (!n. fn (SUC n) = f (fn n) n)
val INDUCT_TAC : tactic = <fun>
val num_RECURSION : thm =
  |- !e f. ?fn. fn 0 = e /\ (!n. fn (SUC n) = f (fn n) n)
0..0..solved at 3
0..0..solved at 2
val num_CASES : thm = |- !m. m = 0 \/ (?n. m = SUC n)
val num_RECURSION_STD : thm =
  |- !e f. ?fn. fn 0 = e /\ (!n. fn (SUC n) = f n (fn n))
- : unit = ()
val BIT0_DEF : thm = |- BIT0 0 = 0 /\ (!n. BIT0 (SUC n) = SUC (SUC (BIT0 n)))
val BIT1_DEF : thm = |- !n. BIT1 n = SUC (BIT0 n)
val mk_numeral : num -> term = <fun>
val mk_small_numeral : int -> term = <fun>
val dest_small_numeral : term -> int = <fun>
val is_numeral : term -> bool = <fun>
val the_specifications : '_a list ref = {contents = []}
val new_specification : string list -> thm -> thm = <fun>
- : unit = ()
File "nums.ml" already loaded
- : unit = ()
val prove_recursive_functions_exist : thm -> term -> thm = <fun>
val new_recursive_definition : thm -> term -> thm = <fun>
- : unit = ()
File "recursion.ml" already loaded
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val PRE : thm = |- PRE 0 = 0 /\ (!n. PRE (SUC n) = n)
val ADD : thm = |- (!n. 0 + n = n) /\ (!m n. SUC m + n = SUC (m + n))
val ADD_0 : thm = |- !m. m + 0 = m
val ADD_SUC : thm = |- !m n. m + SUC n = SUC (m + n)
val ADD_CLAUSES : thm =
  |- (!n. 0 + n = n) /\
     (!m. m + 0 = m) /\
     (!m n. SUC m + n = SUC (m + n)) /\
     (!m n. m + SUC n = SUC (m + n))
val ADD_SYM : thm = |- !m n. m + n = n + m
val ADD_ASSOC : thm = |- !m n p. m + n + p = (m + n) + p
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..2..7..14..35..62..solved at 73
val ADD_AC : thm =
  |- m + n = n + m /\ (m + n) + p = m + n + p /\ m + n + p = n + m + p
val ADD_EQ_0 : thm = |- !m n. m + n = 0 <=> m = 0 /\ n = 0
val EQ_ADD_LCANCEL : thm = |- !m n p. m + n = m + p <=> n = p
val EQ_ADD_RCANCEL : thm = |- !m n p. m + p = n + p <=> m = n
val EQ_ADD_LCANCEL_0 : thm = |- !m n. m + n = m <=> n = 0
val EQ_ADD_RCANCEL_0 : thm = |- !m n. m + n = n <=> m = 0
val BIT0 : thm = |- !n. BIT0 n = n + n
val BIT1 : thm = |- !n. BIT1 n = SUC (n + n)
val BIT0_THM : thm = |- !n. NUMERAL (BIT0 n) = NUMERAL n + NUMERAL n
val BIT1_THM : thm = |- !n. NUMERAL (BIT1 n) = SUC (NUMERAL n + NUMERAL n)
val ONE : thm = |- 1 = SUC 0
val TWO : thm = |- 2 = SUC 1
val ADD1 : thm = |- !m. SUC m = m + 1
val MULT : thm = |- (!n. 0 * n = 0) /\ (!m n. SUC m * n = m * n + n)
val MULT_0 : thm = |- !m. m * 0 = 0
val MULT_SUC : thm = |- !m n. m * SUC n = m + m * n
val MULT_CLAUSES : thm =
  |- (!n. 0 * n = 0) /\
     (!m. m * 0 = 0) /\
     (!n. 1 * n = n) /\
     (!m. m * 1 = m) /\
     (!m n. SUC m * n = m * n + n) /\
     (!m n. m * SUC n = m + m * n)
val MULT_SYM : thm = |- !m n. m * n = n * m
val LEFT_ADD_DISTRIB : thm = |- !m n p. m * (n + p) = m * n + m * p
val RIGHT_ADD_DISTRIB : thm = |- !m n p. (m + n) * p = m * p + n * p
val MULT_ASSOC : thm = |- !m n p. m * n * p = (m * n) * p
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..2..7..14..35..62..solved at 73
val MULT_AC : thm =
  |- m * n = n * m /\ (m * n) * p = m * n * p /\ m * n * p = n * m * p
val MULT_EQ_0 : thm = |- !m n. m * n = 0 <=> m = 0 \/ n = 0
val EQ_MULT_LCANCEL : thm = |- !m n p. m * n = m * p <=> m = 0 \/ n = p
val EQ_MULT_RCANCEL : thm = |- !m n p. m * p = n * p <=> m = n \/ p = 0
val MULT_2 : thm = |- !n. 2 * n = n + n
val MULT_EQ_1 : thm = |- !m n. m * n = 1 <=> m = 1 /\ n = 1
val EXP : thm = |- (!m. m EXP 0 = 1) /\ (!m n. m EXP SUC n = m * m EXP n)
val EXP_EQ_0 : thm = |- !m n. m EXP n = 0 <=> m = 0 /\ ~(n = 0)
val EXP_EQ_1 : thm = |- !x n. x EXP n = 1 <=> x = 1 \/ n = 0
val EXP_ZERO : thm = |- !n. 0 EXP n = (if n = 0 then 1 else 0)
val EXP_ADD : thm = |- !m n p. m EXP (n + p) = m EXP n * m EXP p
val EXP_ONE : thm = |- !n. 1 EXP n = 1
val EXP_1 : thm = |- !n. n EXP 1 = n
val EXP_2 : thm = |- !n. n EXP 2 = n * n
val MULT_EXP : thm = |- !p m n. (m * n) EXP p = m EXP p * n EXP p
val EXP_MULT : thm = |- !m n p. m EXP (n * p) = m EXP n EXP p
val LE : thm =
  |- (!m. m <= 0 <=> m = 0) /\ (!m n. m <= SUC n <=> m = SUC n \/ m <= n)
val LT : thm = |- (!m. m < 0 <=> F) /\ (!m n. m < SUC n <=> m = n \/ m < n)
val GE : thm = |- !n m. m >= n <=> n <= m
val GT : thm = |- !n m. m > n <=> n < m
val MAX : thm = |- !m n. MAX m n = (if m <= n then n else m)
val MIN : thm = |- !m n. MIN m n = (if m <= n then m else n)
val LE_SUC_LT : thm = |- !m n. SUC m <= n <=> m < n
val LT_SUC_LE : thm = |- !m n. m < SUC n <=> m <= n
val LE_SUC : thm = |- !m n. SUC m <= SUC n <=> m <= n
val LT_SUC : thm = |- !m n. SUC m < SUC n <=> m < n
val LE_0 : thm = |- !n. 0 <= n
val LT_0 : thm = |- !n. 0 < SUC n
val LE_REFL : thm = |- !n. n <= n
val LT_REFL : thm = |- !n. ~(n < n)
val LE_ANTISYM : thm = |- !m n. m <= n /\ n <= m <=> m = n
val LT_ANTISYM : thm = |- !m n. ~(m < n /\ n < m)
val LET_ANTISYM : thm = |- !m n. ~(m <= n /\ n < m)
val LTE_ANTISYM : thm = |- !m n. ~(m < n /\ n <= m)
val LE_TRANS : thm = |- !m n p. m <= n /\ n <= p ==> m <= p
val LT_TRANS : thm = |- !m n p. m < n /\ n < p ==> m < p
val LET_TRANS : thm = |- !m n p. m <= n /\ n < p ==> m < p
val LTE_TRANS : thm = |- !m n p. m < n /\ n <= p ==> m < p
val LE_CASES : thm = |- !m n. m <= n \/ n <= m
val LT_CASES : thm = |- !m n. m < n \/ n < m \/ m = n
val LET_CASES : thm = |- !m n. m <= n \/ n < m
val LTE_CASES : thm = |- !m n. m < n \/ n <= m
val LE_LT : thm = |- !m n. m <= n <=> m < n \/ m = n
val LT_LE : thm = |- !m n. m < n <=> m <= n /\ ~(m = n)
val NOT_LE : thm = |- !m n. ~(m <= n) <=> n < m
val NOT_LT : thm = |- !m n. ~(m < n) <=> n <= m
val LT_IMP_LE : thm = |- !m n. m < n ==> m <= n
val EQ_IMP_LE : thm = |- !m n. m = n ==> m <= n
val LT_NZ : thm = |- !n. 0 < n <=> ~(n = 0)
val LE_1 : thm =
  |- (!n. ~(n = 0) ==> 0 < n) /\
     (!n. ~(n = 0) ==> 1 <= n) /\
     (!n. 0 < n ==> ~(n = 0)) /\
     (!n. 0 < n ==> 1 <= n) /\
     (!n. 1 <= n ==> 0 < n) /\
     (!n. 1 <= n ==> ~(n = 0))
val LE_EXISTS : thm = |- !m n. m <= n <=> (?d. n = m + d)
val LT_EXISTS : thm = |- !m n. m < n <=> (?d. n = m + SUC d)
val LE_ADD : thm = |- !m n. m <= m + n
val LE_ADDR : thm = |- !m n. n <= m + n
val LT_ADD : thm = |- !m n. m < m + n <=> 0 < n
val LT_ADDR : thm = |- !m n. n < m + n <=> 0 < m
val LE_ADD_LCANCEL : thm = |- !m n p. m + n <= m + p <=> n <= p
val LE_ADD_RCANCEL : thm = |- !m n p. m + p <= n + p <=> m <= n
val LT_ADD_LCANCEL : thm = |- !m n p. m + n < m + p <=> n < p
val LT_ADD_RCANCEL : thm = |- !m n p. m + p < n + p <=> m < n
val LE_ADD2 : thm = |- !m n p q. m <= p /\ n <= q ==> m + n <= p + q
val LET_ADD2 : thm = |- !m n p q. m <= p /\ n < q ==> m + n < p + q
val LTE_ADD2 : thm = |- !m n p q. m < p /\ n <= q ==> m + n < p + q
val LT_ADD2 : thm = |- !m n p q. m < p /\ n < q ==> m + n < p + q
val LT_MULT : thm = |- !m n. 0 < m * n <=> 0 < m /\ 0 < n
val LE_MULT2 : thm = |- !m n p q. m <= n /\ p <= q ==> m * p <= n * q
val LT_LMULT : thm = |- !m n p. ~(m = 0) /\ n < p ==> m * n < m * p
val LE_MULT_LCANCEL : thm = |- !m n p. m * n <= m * p <=> m = 0 \/ n <= p
val LE_MULT_RCANCEL : thm = |- !m n p. m * p <= n * p <=> m <= n \/ p = 0
val LT_MULT_LCANCEL : thm = |- !m n p. m * n < m * p <=> ~(m = 0) /\ n < p
val LT_MULT_RCANCEL : thm = |- !m n p. m * p < n * p <=> m < n /\ ~(p = 0)
val LT_MULT2 : thm = |- !m n p q. m < n /\ p < q ==> m * p < n * q
val LE_SQUARE_REFL : thm = |- !n. n <= n * n
0..0..2..12..solved at 18
val LT_POW2_REFL : thm = |- !n. n < 2 EXP n
0..0..1..5..13..27..solved at 33
val WLOG_LE : thm =
  |- (!m n. P m n <=> P n m) /\ (!m n. m <= n ==> P m n) ==> (!m n. P m n)
0..0..1..5..11..22..49..95..171..305..solved at 319
val WLOG_LT : thm =
  |- (!m. P m m) /\ (!m n. P m n <=> P n m) /\ (!m n. m < n ==> P m n)
     ==> (!m y. P m y)
0..0..3..13..37..solved at 48
0..0..3..solved at 8
0..0..2..8..solved at 23
val num_WF : thm = |- !P. (!n. (!m. m < n ==> P m) ==> P n) ==> (!n. P n)
0..0..solved at 2
0..0..0..1..3..5..solved at 10
val num_WOP : thm = |- !P. (?n. P n) <=> (?n. P n /\ (!m. m < n ==> ~P m))
val num_MAX : thm =
  |- !P. (?x. P x) /\ (?M. !x. P x ==> x <= M) <=>
         (?m. P m /\ (!x. P x ==> x <= m))
val EVEN : thm = |- (EVEN 0 <=> T) /\ (!n. EVEN (SUC n) <=> ~EVEN n)
val ODD : thm = |- (ODD 0 <=> F) /\ (!n. ODD (SUC n) <=> ~ODD n)
val NOT_EVEN : thm = |- !n. ~EVEN n <=> ODD n
val NOT_ODD : thm = |- !n. ~ODD n <=> EVEN n
val EVEN_OR_ODD : thm = |- !n. EVEN n \/ ODD n
Searching with limit 0
Searching with limit 1
Searching with limit 2
val EVEN_AND_ODD : thm = |- !n. ~(EVEN n /\ ODD n)
val EVEN_ADD : thm = |- !m n. EVEN (m + n) <=> EVEN m <=> EVEN n
val EVEN_MULT : thm = |- !m n. EVEN (m * n) <=> EVEN m \/ EVEN n
Searching with limit 0
Searching with limit 1
val EVEN_EXP : thm = |- !m n. EVEN (m EXP n) <=> EVEN m /\ ~(n = 0)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val ODD_ADD : thm = |- !m n. ODD (m + n) <=> ~(ODD m <=> ODD n)
Searching with limit 0
Searching with limit 1
Searching with limit 2
val ODD_MULT : thm = |- !m n. ODD (m * n) <=> ODD m /\ ODD n
Searching with limit 0
Searching with limit 1
val ODD_EXP : thm = |- !m n. ODD (m EXP n) <=> ODD m \/ n = 0
val EVEN_DOUBLE : thm = |- !n. EVEN (2 * n)
val ODD_DOUBLE : thm = |- !n. ODD (SUC (2 * n))
val EVEN_EXISTS_LEMMA : thm =
  |- !n. (EVEN n ==> (?m. n = 2 * m)) /\ (~EVEN n ==> (?m. n = SUC (2 * m)))
val EVEN_EXISTS : thm = |- !n. EVEN n <=> (?m. n = 2 * m)
val ODD_EXISTS : thm = |- !n. ODD n <=> (?m. n = SUC (2 * m))
0..0..1..4..solved at 10
0..0..2..8..31..79..254..629..1685..solved at 3183
0..0..solved at 2
val EVEN_ODD_DECOMPOSITION : thm =
  |- !n. (?k m. ODD m /\ n = 2 EXP k * m) <=> ~(n = 0)
val SUB : thm = |- (!m. m - 0 = m) /\ (!m n. m - SUC n = PRE (m - n))
val SUB_0 : thm = |- !m. 0 - m = 0 /\ m - 0 = m
val SUB_PRESUC : thm = |- !m n. PRE (SUC m - n) = m - n
val SUB_SUC : thm = |- !m n. SUC m - SUC n = m - n
val SUB_REFL : thm = |- !n. n - n = 0
val ADD_SUB : thm = |- !m n. (m + n) - n = m
val ADD_SUB2 : thm = |- !m n. (m + n) - m = n
val SUB_EQ_0 : thm = |- !m n. m - n = 0 <=> m <= n
val ADD_SUBR2 : thm = |- !m n. m - (m + n) = 0
val ADD_SUBR : thm = |- !m n. n - (m + n) = 0
val SUB_ADD : thm = |- !m n. n <= m ==> m - n + n = m
val SUB_ADD_LCANCEL : thm = |- !m n p. (m + n) - (m + p) = n - p
val SUB_ADD_RCANCEL : thm = |- !m n p. (m + p) - (n + p) = m - n
val LEFT_SUB_DISTRIB : thm = |- !m n p. m * (n - p) = m * n - m * p
val RIGHT_SUB_DISTRIB : thm = |- !m n p. (m - n) * p = m * p - n * p
val SUC_SUB1 : thm = |- !n. SUC n - 1 = n
0..0..solved at 3
0..0..solved at 3
0..0..1..4..13..29..74..solved at 99
0..0..1..4..19..49..130..solved at 165
0..0..3..10..29..63..170..solved at 283
0..0..solved at 2
0..0..solved at 5
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 7
0..0..2..4..solved at 10
0..0..solved at 2
0..0..solved at 2
0..0..4..8..solved at 17
0..0..2..4..solved at 11
0..0..solved at 2
0..0..solved at 3
0..0..6..12..solved at 24
val EVEN_SUB : thm = |- !m n. EVEN (m - n) <=> m <= n \/ (EVEN m <=> EVEN n)
val ODD_SUB : thm = |- !m n. ODD (m - n) <=> n < m /\ ~(ODD m <=> ODD n)
val FACT : thm = |- FACT 0 = 1 /\ (!n. FACT (SUC n) = SUC n * FACT n)
val FACT_LT : thm = |- !n. 0 < FACT n
val FACT_LE : thm = |- !n. 1 <= FACT n
val FACT_NZ : thm = |- !n. ~(FACT n = 0)
val FACT_MONO : thm = |- !m n. m <= n ==> FACT m <= FACT n
val EXP_LT_0 : thm = |- !n x. 0 < x EXP n <=> ~(x = 0) \/ n = 0
val LT_EXP : thm =
  |- !x m n.
         x EXP m < x EXP n <=> 2 <= x /\ m < n \/ x = 0 /\ ~(m = 0) /\ n = 0
val LE_EXP : thm =
  |- !x m n.
         x EXP m <= x EXP n <=>
         (if x = 0 then m = 0 ==> n = 0 else x = 1 \/ m <= n)
val EQ_EXP : thm =
  |- !x m n.
         x EXP m = x EXP n <=>
         (if x = 0 then m = 0 <=> n = 0 else x = 1 \/ m = n)
val EXP_MONO_LE_IMP : thm = |- !x y n. x <= y ==> x EXP n <= y EXP n
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
val EXP_MONO_LT_IMP : thm =
  |- !x y n. x < y /\ ~(n = 0) ==> x EXP n < y EXP n
0..0..2..7..16..32..solved at 45
val EXP_MONO_LE : thm = |- !x y n. x EXP n <= y EXP n <=> x <= y \/ n = 0
val EXP_MONO_LT : thm = |- !x y n. x EXP n < y EXP n <=> x < y /\ ~(n = 0)
val EXP_MONO_EQ : thm = |- !x y n. x EXP n = y EXP n <=> x = y \/ n = 0
val DIVMOD_EXIST : thm = |- !m n. ~(n = 0) ==> (?q r. m = q * n + r /\ r < n)
val DIVMOD_EXIST_0 : thm =
  |- !m n. ?q r. if n = 0 then q = 0 /\ r = m else m = q * n + r /\ r < n
val DIVISION_0 : thm =
  |- !m n.
         if n = 0
         then m DIV n = 0 /\ m MOD n = m
         else m = m DIV n * n + m MOD n /\ m MOD n < n
0..0..2..solved at 5
0..0..2..solved at 5
val DIVISION : thm =
  |- !m n. ~(n = 0) ==> m = m DIV n * n + m MOD n /\ m MOD n < n
0..0..2..6..15..solved at 21
0..0..2..6..15..57..160..883..4135..solved at 8792
val DIVISION_SIMP : thm =
  |- (!m n. ~(n = 0) ==> m DIV n * n + m MOD n = m) /\
     (!m n. ~(n = 0) ==> n * m DIV n + m MOD n = m)
val DIVMOD_UNIQ_LEMMA : thm =
  |- !m n q1 r1 q2 r2.
         (m = q1 * n + r1 /\ r1 < n) /\ m = q2 * n + r2 /\ r2 < n
         ==> q1 = q2 /\ r1 = r2
val DIVMOD_UNIQ : thm =
  |- !m n q r. m = q * n + r /\ r < n ==> m DIV n = q /\ m MOD n = r
val MOD_UNIQ : thm = |- !m n q r. m = q * n + r /\ r < n ==> m MOD n = r
val DIV_UNIQ : thm = |- !m n q r. m = q * n + r /\ r < n ==> m DIV n = q
val DIV_MULT : thm = |- !m n. ~(m = 0) ==> (m * n) DIV m = n
val MOD_MULT : thm = |- !m n. ~(m = 0) ==> (m * n) MOD m = 0
val MOD_LT : thm = |- !m n. m < n ==> m MOD n = m
val MOD_EQ : thm = |- !m n p q. m = n + q * p ==> m MOD p = n MOD p
val DIV_LE : thm = |- !m n. ~(n = 0) ==> m DIV n <= m
val DIV_MUL_LE : thm = |- !m n. n * m DIV n <= m
val DIV_0 : thm = |- !n. ~(n = 0) ==> 0 DIV n = 0
val MOD_0 : thm = |- !n. ~(n = 0) ==> 0 MOD n = 0
val DIV_1 : thm = |- !n. n DIV 1 = n
val MOD_1 : thm = |- !n. n MOD 1 = 0
val DIV_LT : thm = |- !m n. m < n ==> m DIV n = 0
val MOD_MOD : thm = |- !m n p. ~(n * p = 0) ==> m MOD (n * p) MOD n = m MOD n
val MOD_MOD_REFL : thm = |- !m n. ~(n = 0) ==> m MOD n MOD n = m MOD n
val DIV_MULT2 : thm =
  |- !m n p. ~(m * p = 0) ==> (m * n) DIV (m * p) = n DIV p
val MOD_MULT2 : thm =
  |- !m n p. ~(m * p = 0) ==> (m * n) MOD (m * p) = m * n MOD p
0..0..2..solved at 5
val MOD_EXISTS : thm =
  |- !m n. (?q. m = n * q) <=> (if n = 0 then m = 0 else m MOD n = 0)
0..0..2..6..13..45..solved at 52
0..0..2..solved at 5
val LE_RDIV_EQ : thm = |- !a b n. ~(a = 0) ==> (n <= b DIV a <=> a * n <= b)
val LE_LDIV_EQ : thm =
  |- !a b n. ~(a = 0) ==> (b DIV a <= n <=> b < a * (n + 1))
0..0..2..6..18..42..solved at 52
val LE_LDIV : thm = |- !a b n. ~(a = 0) /\ b <= a * n ==> b DIV a <= n
0..0..1..solved at 4
0..0..2..4..solved at 8
val DIV_MONO : thm = |- !m n p. ~(p = 0) /\ m <= n ==> m DIV p <= n DIV p
0..0..1..3..5..10..19..31..52..solved at 74
0..0..2..4..10..24..solved at 34
val DIV_MONO_LT : thm =
  |- !m n p. ~(p = 0) /\ m + p <= n ==> m DIV p < n DIV p
val DIV_EQ_0 : thm = |- !m n. ~(n = 0) ==> (m DIV n = 0 <=> m < n)
0..0..solved at 2
0..0..solved at 2
0..0..2..7..solved at 11
val MOD_EQ_0 : thm = |- !m n. ~(n = 0) ==> (m MOD n = 0 <=> (?q. m = q * n))
0..0..2..4..solved at 9
val MOD_REFL : thm = |- !n. ~(n = 0) ==> n MOD n = 0
val EVEN_MOD : thm = |- !n. EVEN n <=> n MOD 2 = 0
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..1..2..solved at 6
val ODD_MOD : thm = |- !n. ODD n <=> n MOD 2 = 1
val MOD_MULT_RMOD : thm =
  |- !m n p. ~(n = 0) ==> (m * p MOD n) MOD n = (m * p) MOD n
val MOD_MULT_LMOD : thm =
  |- !m n p. ~(n = 0) ==> (m MOD n * p) MOD n = (m * p) MOD n
val MOD_MULT_MOD2 : thm =
  |- !m n p. ~(n = 0) ==> (m MOD n * p MOD n) MOD n = (m * p) MOD n
val MOD_EXP_MOD : thm =
  |- !m n p. ~(n = 0) ==> (m MOD n) EXP p MOD n = m EXP p MOD n
val MOD_MULT_ADD : thm = |- !m n p. (m * n + p) MOD n = p MOD n
0..0..2..6..17..solved at 25
0..0..2..solved at 5
val DIV_MULT_ADD : thm =
  |- !a b n. ~(n = 0) ==> (a * n + b) DIV n = a + b DIV n
val MOD_ADD_MOD : thm =
  |- !a b n. ~(n = 0) ==> (a MOD n + b MOD n) MOD n = (a + b) MOD n
val DIV_ADD_MOD : thm =
  |- !a b n.
         ~(n = 0)
         ==> ((a + b) MOD n = a MOD n + b MOD n <=>
              (a + b) DIV n = a DIV n + b DIV n)
val DIV_REFL : thm = |- !n. ~(n = 0) ==> n DIV n = 1
val MOD_LE : thm = |- !m n. ~(n = 0) ==> m MOD n <= m
0..0..2..solved at 6
0..0..2..5..11..22..40..solved at 53
val DIV_MONO2 : thm = |- !m n p. ~(p = 0) /\ p <= m ==> n DIV m <= n DIV p
0..0..1..solved at 4
0..0..3..6..14..32..57..102..188..solved at 204
val DIV_LE_EXCLUSION : thm =
  |- !a b c d. ~(b = 0) /\ b * c < (a + 1) * d ==> c DIV d <= a DIV b
0..0..3..6..22..41..72..122..175..248..386..solved at 407
val DIV_EQ_EXCLUSION : thm =
  |- b * c < (a + 1) * d /\ a * d < (c + 1) * b ==> a DIV b = c DIV d
val MULT_DIV_LE : thm = |- !m n p. ~(p = 0) ==> m * n DIV p <= (m * n) DIV p
0..0..1..2..6..11..19..32..45..60..solved at 73
val DIV_DIV : thm = |- !m n p. ~(n * p = 0) ==> m DIV n DIV p = m DIV (n * p)
0..0..1..2..6..11..19..32..45..60..solved at 73
0..0..1..3..6..15..34..67..132..266..solved at 510
0..0..1..3..6..13..29..59..110..solved at 162
0..0..1..3..6..15..34..68..130..solved at 182
0..0..1..3..6..15..34..67..132..266..solved at 510
val DIV_MOD : thm =
  |- !m n p. ~(n * p = 0) ==> (m DIV n) MOD p = (m MOD (n * p)) DIV n
0..0..3..10..solved at 15
val MOD_MOD_EXP_MIN : thm =
  |- !x p m n. ~(p = 0) ==> x MOD p EXP m MOD p EXP n = x MOD p EXP MIN m n
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
val PRE_ELIM_THM : thm =
  |- P (PRE n) <=> (!m. n = SUC m \/ m = 0 /\ n = 0 ==> P m)
0..0..solved at 2
0..0..2..solved at 7
0..0..2..5..solved at 17
0..0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..0..1..solved at 9
0..0..solved at 2
0..0..solved at 2
val PRE_ELIM_THM' : thm =
  |- P (PRE n) <=> (?m. (n = SUC m \/ m = 0 /\ n = 0) /\ P m)
0..0..1..solved at 5
0..0..1..5..16..32..solved at 40
0..0..1..5..18..37..solved at 48
0..0..solved at 2
0..0..1..solved at 4
val SUB_ELIM_THM : thm =
  |- P (a - b) <=> (!d. a = b + d \/ a < b /\ d = 0 ==> P d)
0..0..solved at 2
0..0..2..solved at 7
0..0..2..5..solved at 17
0..0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..0..1..solved at 9
0..0..solved at 2
0..0..solved at 2
val SUB_ELIM_THM' : thm =
  |- P (a - b) <=> (?d. (a = b + d \/ a < b /\ d = 0) /\ P d)
0..0..2..5..14..66..287..1310..solved at 1325
0..0..solved at 3
0..0..2..5..16..72..302..solved at 311
0..0..1..2..3..7..12..17..23..29..35..solved at 84
0..0..1..2..solved at 6
val DIVMOD_ELIM_THM : thm =
  |- P (m DIV n) (m MOD n) <=>
     (!q r. n = 0 /\ q = 0 /\ r = m \/ m = q * n + r /\ r < n ==> P q r)
0..0..solved at 2
0..0..2..4..7..solved at 21
0..0..2..4..solved at 10
0..0..0..0..1..solved at 7
0..0..solved at 2
0..0..solved at 2
0..0..0..0..solved at 4
0..0..solved at 2
0..0..solved at 2
val DIVMOD_ELIM_THM' : thm =
  |- P (m DIV n) (m MOD n) <=>
     (?q r. (n = 0 /\ q = 0 /\ r = m \/ m = q * n + r /\ r < n) /\ P q r)
val NUM_CANCEL_CONV : term -> thm = <fun>
val LE_IMP : thm -> thm = <fun>
- : unit = ()
val minimal : thm = |- !P. (minimal) P = (@n. P n /\ (!m. m < n ==> ~P m))
val MINIMAL : thm =
  |- !P. (?n. P n) <=> P ((minimal) P) /\ (!m. m < (minimal) P ==> ~P m)
0..0..solved at 2
0..0..1..2..solved at 6
val TRANSITIVE_STEPWISE_LT_EQ : thm =
  |- !R. (!x y z. R x y /\ R y z ==> R x z)
         ==> ((!m n. m < n ==> R m n) <=> (!n. R n (SUC n)))
val TRANSITIVE_STEPWISE_LT : thm =
  |- !R. (!x y z. R x y /\ R y z ==> R x z) /\ (!n. R n (SUC n))
         ==> (!m n. m < n ==> R m n)
0..0..solved at 2
0..0..1..2..solved at 6
val TRANSITIVE_STEPWISE_LE_EQ : thm =
  |- !R. (!x. R x x) /\ (!x y z. R x y /\ R y z ==> R x z)
         ==> ((!m n. m <= n ==> R m n) <=> (!n. R n (SUC n)))
val TRANSITIVE_STEPWISE_LE : thm =
  |- !R. (!x. R x x) /\
         (!x y z. R x y /\ R y z ==> R x z) /\
         (!n. R n (SUC n))
         ==> (!m n. m <= n ==> R m n)
0..0..solved at 2
0..0..solved at 2
0..0..1..2..5..10..19..32..55..112..263..solved at 489
0..0..0..1..2..3..solved at 8
0..0..0..1..2..3..7..14..22..33..57..84..141..221..305..441..638..849..solved at 1042
val DEPENDENT_CHOICE_FIXED : thm =
  |- !P R a.
         P 0 a /\ (!n x. P n x ==> (?y. P (SUC n) y /\ R n x y))
         ==> (?f. f 0 = a /\ (!n. P n (f n)) /\ (!n. R n (f n) (f (SUC n))))
0..0..0..1..2..3..4..5..6..11..16..21..40..59..78..103..128..153..192..231..270..358..446..534..650..766..882..1036..1190..1344..solved at 3172
val DEPENDENT_CHOICE : thm =
  |- !P R.
         (?a. P 0 a) /\ (!n x. P n x ==> (?y. P (SUC n) y /\ R n x y))
         ==> (?f. (!n. P n (f n)) /\ (!n. R n (f n) (f (SUC n))))
- : unit = ()
File "arith.ml" already loaded
- : unit = ()
- : unit = ()
val WF : thm =
  |- !(<<). WF (<<) <=>
            (!P. (?x. P x) ==> (?x. P x /\ (!y. y << x ==> ~P y)))
0..0..solved at 2
0..0..solved at 2
0..0..0..0..2..5..8..25..57..89..solved at 97
0..0..0..1..5..10..solved at 15
0..0..0..0..2..5..8..25..57..89..solved at 97
val WF_EQ : thm =
  |- WF (<<) <=> (!P. (?x. P x) <=> (?x. P x /\ (!y. y << x ==> ~P y)))
0..0..solved at 2
0..0..2..10..25..solved at 35
0..0..0..1..4..7..solved at 12
0..0..solved at 2
val WF_IND : thm =
  |- WF (<<) <=> (!P. (!x. (!y. y << x ==> P y) ==> P x) ==> (!x. P x))
0..0..0..3..6..9..solved at 16
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..3..solved at 7
0..0..solved at 2
0..0..0..solved at 3
val WF_DCHAIN : thm = |- WF (<<) <=> ~(?s. !n. s (SUC n) << s n)
val WF_UREC : thm =
  |- WF (<<)
     ==> (!H. (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x)
              ==> (!f g. (!x. f x = H f x) /\ (!x. g x = H g x) ==> f = g))
0..0..solved at 3
0..0..2..4..8..solved at 13
0..0..solved at 3
0..0..2..4..8..solved at 13
0..0..solved at 3
0..0..solved at 2
0..0..2..10..25..solved at 35
0..0..solved at 2
val WF_UREC_WF : thm =
  |- (!H. (!f g x. (!z. z << x ==> (f z <=> g z)) ==> (H f x <=> H g x))
          ==> (!f g. (!x. f x <=> H f x) /\ (!x. g x <=> H g x) ==> f = g))
     ==> WF (<<)
0..0..1..3..11..solved at 20
0..0..1..2..4..12..24..45..78..125..solved at 140
0..0..0..2..7..solved at 12
0..0..1..3..13..29..63..128..226..388..642..977..1459..2097..3319..solved at 3649
val WF_REC_INVARIANT : thm =
  |- WF (<<)
     ==> (!H S.
              (!f g x.
                   (!z. z << x ==> f z = g z /\ S z (f z))
                   ==> H f x = H g x /\ S x (H f x))
              ==> (?f. !x. f x = H f x))
val WF_REC : thm =
  |- WF (<<)
     ==> (!H. (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x)
              ==> (?f. !x. f x = H f x))
0..0..solved at 2
0..0..solved at 2
0..0..0..solved at 3
0..0..solved at 2
val WF_REC_WF : thm =
  |- (!H. (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x)
          ==> (?f. !x. f x = H f x))
     ==> WF (<<)
0..0..1..4..15..41..98..211..420..solved at 656
0..0..1..2..5..9..17..33..55..97..162..262..411..solved at 543
val WF_EREC : thm =
  |- WF (<<)
     ==> (!H. (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x)
              ==> (?!f. !x. f x = H f x))
- : unit = ()
0..0..0..1..4..7..solved at 16
val WF_SUBSET : thm = |- (!x y. x << y ==> x <<< y) /\ WF (<<<) ==> WF (<<)
0..0..2..8..24..54..solved at 69
0..0..1..solved at 6
val WF_MEASURE_GEN : thm = |- !m. WF (<<) ==> WF (\x x'. m x << m x')
0..0..0..solved at 4
0..0..0..solved at 3
val WF_LEX_DEPENDENT : thm =
  |- !R S.
         WF R /\ (!a. WF (S a))
         ==> WF (\(r1,s1) (r2,s2). R r1 r2 \/ r1 = r2 /\ S r1 s1 s2)
val WF_LEX : thm =
  |- !R S.
         WF R /\ WF S
         ==> WF (\(r1,s1) (r2,s2). R r1 r2 \/ r1 = r2 /\ S s1 s2)
val WF_POINTWISE : thm =
  |- WF (<<) /\ WF (<<<) ==> WF (\(x1,y1) (x2,y2). x1 << x2 /\ y1 <<< y2)
val WF_num : thm = |- WF (<)
val WF_REC_num : thm =
  |- !H. (!f g n. (!m. m < n ==> f m = g m) ==> H f n = H g n)
         ==> (?f. !n. f n = H f n)
Warning: inventing type variables
val MEASURE : thm = |- !m. MEASURE m = (\x y. m x < m y)
val WF_MEASURE : thm = |- !m. WF (MEASURE m)
Warning: inventing type variables
0..0..2..8..solved at 12
0..0..2..8..solved at 13
val MEASURE_LE : thm =
  |- (!y. MEASURE m y a ==> MEASURE m y b) <=> m a <= m b
0..0..solved at 2
0..0..0..solved at 3
val WF_REFL : thm = |- !x. WF (<<) ==> ~(x << x)
val WF_FALSE : thm = |- WF (\x y. F)
0..0..solved at 2
0..0..3..7..20..54..150..solved at 180
0..0..solved at 2
0..0..2..6..solved at 13
0..0..1..3..solved at 7
0..0..1..3..solved at 8
0..0..2..6..solved at 14
0..0..1..3..solved at 8
0..0..2..4..solved at 11
0..0..5..12..39..solved at 71
0..0..4..10..30..solved at 55
0..0..5..13..38..solved at 66
0..0..4..10..31..solved at 57
0..0..3..6..19..35..60..118..solved at 270
val WF_REC_TAIL : thm =
  |- !P g h. ?f. !x. f x = (if P x then f (g x) else h x)
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..5..15..51..120..259..solved at 434
0..0..1..5..15..51..120..259..solved at 394
0..0..1..4..13..31..solved at 37
0..0..1..2..solved at 6
0..0..1..5..15..51..120..259..solved at 394
0..0..1..5..15..51..120..259..solved at 434
0..0..1..4..12..28..58..118..solved at 128
0..0..2..9..28..85..206..492..solved at 618
0..0..2..9..28..94..222..491..1165..solved at 1499
0..0..2..9..28..94..223..491..1149..solved at 1472
0..0..2..10..28..82..204..solved at 236
0..0..1..4..11..43..116..246..648..1354..solved at 1611
0..0..solved at 2
0..0..1..5..15..51..120..259..solved at 434
0..0..1..5..15..51..120..259..solved at 394
0..0..1..4..13..31..solved at 37
0..0..2..7..24..55..104..223..440..827..1504..solved at 1616
0..0..2..7..24..65..133..290..574..solved at 904
0..0..2..7..24..65..134..294..583..solved at 913
0..0..2..8..25..52..110..solved at 145
0..0..1..2..7..13..26..50..83..132..216..308..447..705..1020..1530..2268..3184..4455..6310..solved at 8365
0..0..1..3..9..17..43..86..154..300..472..714..1138..1664..2466..4129..6181..solved at 6305
0..0..2..7..20..49..89..185..solved at 215
0..0..1..2..7..17..34..70..132..223..396..solved at 427
0..0..1..2..6..12..23..46..74..119..197..285..418..630..886..solved at 1210
0..0..2..8..24..solved at 32
0..0..2..7..24..61..134..280..548..1144..solved at 1169
0..0..3..solved at 7
val WF_REC_TAIL_GENERAL : thm =
  |- !P G H.
         WF (<<) /\
         (!f g x.
              (!z. z << x ==> f z = g z)
              ==> (P f x <=> P g x) /\ G f x = G g x /\ H f x = H g x) /\
         (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x) /\
         (!f x y. P f x /\ y << G f x ==> y << x)
         ==> (?f. !x. f x = (if P f x then f (G f x) else H f x))
Warning: inventing type variables
0..0..1..solved at 4
0..0..1..solved at 4
Warning: inventing type variables
0..0..0..solved at 3
0..0..solved at 2
val WF_INDUCT_TAC : term -> (string * thm) list * term -> goalstate = <fun>
- : unit = ()
File "wf.ml" already loaded
- : unit = ()
val DENUMERAL : thm -> thm = <fun>
val ARITH_ZERO : thm = |- NUMERAL 0 = 0 /\ BIT0 _0 = _0
val ARITH_SUC : thm =
  |- (!n. SUC (NUMERAL n) = NUMERAL (SUC n)) /\
     SUC _0 = BIT1 _0 /\
     (!n. SUC (BIT0 n) = BIT1 n) /\
     (!n. SUC (BIT1 n) = BIT0 (SUC n))
val ARITH_PRE : thm =
  |- (!n. PRE (NUMERAL n) = NUMERAL (PRE n)) /\
     PRE _0 = _0 /\
     (!n. PRE (BIT0 n) = (if n = _0 then _0 else BIT1 (PRE n))) /\
     (!n. PRE (BIT1 n) = BIT0 n)
val ARITH_ADD : thm =
  |- (!m n. NUMERAL m + NUMERAL n = NUMERAL (m + n)) /\
     _0 + _0 = _0 /\
     (!n. _0 + BIT0 n = BIT0 n) /\
     (!n. _0 + BIT1 n = BIT1 n) /\
     (!n. BIT0 n + _0 = BIT0 n) /\
     (!n. BIT1 n + _0 = BIT1 n) /\
     (!m n. BIT0 m + BIT0 n = BIT0 (m + n)) /\
     (!m n. BIT0 m + BIT1 n = BIT1 (m + n)) /\
     (!m n. BIT1 m + BIT0 n = BIT1 (m + n)) /\
     (!m n. BIT1 m + BIT1 n = BIT0 (SUC (m + n)))
val ARITH_MULT : thm =
  |- (!m n. NUMERAL m * NUMERAL n = NUMERAL (m * n)) /\
     _0 * _0 = _0 /\
     (!n. _0 * BIT0 n = _0) /\
     (!n. _0 * BIT1 n = _0) /\
     (!n. BIT0 n * _0 = _0) /\
     (!n. BIT1 n * _0 = _0) /\
     (!m n. BIT0 m * BIT0 n = BIT0 (BIT0 (m * n))) /\
     (!m n. BIT0 m * BIT1 n = BIT0 m + BIT0 (BIT0 (m * n))) /\
     (!m n. BIT1 m * BIT0 n = BIT0 n + BIT0 (BIT0 (m * n))) /\
     (!m n. BIT1 m * BIT1 n = BIT1 m + BIT0 n + BIT0 (BIT0 (m * n)))
val ARITH_EXP : thm =
  |- (!m n. NUMERAL m EXP NUMERAL n = NUMERAL (m EXP n)) /\
     _0 EXP _0 = BIT1 _0 /\
     (!m. BIT0 m EXP _0 = BIT1 _0) /\
     (!m. BIT1 m EXP _0 = BIT1 _0) /\
     (!n. _0 EXP BIT0 n = _0 EXP n * _0 EXP n) /\
     (!m n. BIT0 m EXP BIT0 n = BIT0 m EXP n * BIT0 m EXP n) /\
     (!m n. BIT1 m EXP BIT0 n = BIT1 m EXP n * BIT1 m EXP n) /\
     (!n. _0 EXP BIT1 n = _0) /\
     (!m n. BIT0 m EXP BIT1 n = BIT0 m * BIT0 m EXP n * BIT0 m EXP n) /\
     (!m n. BIT1 m EXP BIT1 n = BIT1 m * BIT1 m EXP n * BIT1 m EXP n)
val ARITH_EVEN : thm =
  |- (!n. EVEN (NUMERAL n) <=> EVEN n) /\
     (EVEN _0 <=> T) /\
     (!n. EVEN (BIT0 n) <=> T) /\
     (!n. EVEN (BIT1 n) <=> F)
val ARITH_ODD : thm =
  |- (!n. ODD (NUMERAL n) <=> ODD n) /\
     (ODD _0 <=> F) /\
     (!n. ODD (BIT0 n) <=> F) /\
     (!n. ODD (BIT1 n) <=> T)
val ARITH_LE : thm =
  |- (!m n. NUMERAL m <= NUMERAL n <=> m <= n) /\
     (_0 <= _0 <=> T) /\
     (!n. BIT0 n <= _0 <=> n <= _0) /\
     (!n. BIT1 n <= _0 <=> F) /\
     (!n. _0 <= BIT0 n <=> T) /\
     (!n. _0 <= BIT1 n <=> T) /\
     (!m n. BIT0 m <= BIT0 n <=> m <= n) /\
     (!m n. BIT0 m <= BIT1 n <=> m <= n) /\
     (!m n. BIT1 m <= BIT0 n <=> m < n) /\
     (!m n. BIT1 m <= BIT1 n <=> m <= n)
val ARITH_LT : thm =
  |- (!m n. NUMERAL m < NUMERAL n <=> m < n) /\
     (_0 < _0 <=> F) /\
     (!n. BIT0 n < _0 <=> F) /\
     (!n. BIT1 n < _0 <=> F) /\
     (!n. _0 < BIT0 n <=> _0 < n) /\
     (!n. _0 < BIT1 n <=> T) /\
     (!m n. BIT0 m < BIT0 n <=> m < n) /\
     (!m n. BIT0 m < BIT1 n <=> m <= n) /\
     (!m n. BIT1 m < BIT0 n <=> m < n) /\
     (!m n. BIT1 m < BIT1 n <=> m < n)
val ARITH_GE : thm =
  |- (!m n. NUMERAL n >= NUMERAL m <=> n >= m) /\
     _0 >= _0 /\
     (!n. _0 >= BIT0 n <=> _0 >= n) /\
     (!n. ~(_0 >= BIT1 n)) /\
     (!n. BIT0 n >= _0) /\
     (!n. BIT1 n >= _0) /\
     (!m n. BIT0 n >= BIT0 m <=> n >= m) /\
     (!m n. BIT1 n >= BIT0 m <=> n >= m) /\
     (!m n. BIT0 n >= BIT1 m <=> n > m) /\
     (!m n. BIT1 n >= BIT1 m <=> n >= m)
val ARITH_GT : thm =
  |- (!m n. NUMERAL n > NUMERAL m <=> n > m) /\
     ~(_0 > _0) /\
     (!n. ~(_0 > BIT0 n)) /\
     (!n. ~(_0 > BIT1 n)) /\
     (!n. BIT0 n > _0 <=> n > _0) /\
     (!n. BIT1 n > _0) /\
     (!m n. BIT0 n > BIT0 m <=> n > m) /\
     (!m n. BIT1 n > BIT0 m <=> n >= m) /\
     (!m n. BIT0 n > BIT1 m <=> n > m) /\
     (!m n. BIT1 n > BIT1 m <=> n > m)
val ARITH_EQ : thm =
  |- (!m n. NUMERAL m = NUMERAL n <=> m = n) /\
     (_0 = _0 <=> T) /\
     (!n. BIT0 n = _0 <=> n = _0) /\
     (!n. BIT1 n = _0 <=> F) /\
     (!n. _0 = BIT0 n <=> _0 = n) /\
     (!n. _0 = BIT1 n <=> F) /\
     (!m n. BIT0 m = BIT0 n <=> m = n) /\
     (!m n. BIT0 m = BIT1 n <=> F) /\
     (!m n. BIT1 m = BIT0 n <=> F) /\
     (!m n. BIT1 m = BIT1 n <=> m = n)
val ARITH_SUB : thm =
  |- (!m n. NUMERAL m - NUMERAL n = NUMERAL (m - n)) /\
     _0 - _0 = _0 /\
     (!n. _0 - BIT0 n = _0) /\
     (!n. _0 - BIT1 n = _0) /\
     (!n. BIT0 n - _0 = BIT0 n) /\
     (!n. BIT1 n - _0 = BIT1 n) /\
     (!m n. BIT0 m - BIT0 n = BIT0 (m - n)) /\
     (!m n. BIT0 m - BIT1 n = PRE (BIT0 (m - n))) /\
     (!m n. BIT1 m - BIT0 n = (if n <= m then BIT1 (m - n) else _0)) /\
     (!m n. BIT1 m - BIT1 n = BIT0 (m - n))
val ARITH : thm =
  |- (NUMERAL 0 = 0 /\ BIT0 _0 = _0) /\
     ((!n. SUC (NUMERAL n) = NUMERAL (SUC n)) /\
      SUC _0 = BIT1 _0 /\
      (!n. SUC (BIT0 n) = BIT1 n) /\
      (!n. SUC (BIT1 n) = BIT0 (SUC n))) /\
     ((!n. PRE (NUMERAL n) = NUMERAL (PRE n)) /\
      PRE _0 = _0 /\
      (!n. PRE (BIT0 n) = (if n = _0 then _0 else BIT1 (PRE n))) /\
      (!n. PRE (BIT1 n) = BIT0 n)) /\
     ((!m n. NUMERAL m + NUMERAL n = NUMERAL (m + n)) /\
      _0 + _0 = _0 /\
      (!n. _0 + BIT0 n = BIT0 n) /\
      (!n. _0 + BIT1 n = BIT1 n) /\
      (!n. BIT0 n + _0 = BIT0 n) /\
      (!n. BIT1 n + _0 = BIT1 n) /\
      (!m n. BIT0 m + BIT0 n = BIT0 (m + n)) /\
      (!m n. BIT0 m + BIT1 n = BIT1 (m + n)) /\
      (!m n. BIT1 m + BIT0 n = BIT1 (m + n)) /\
      (!m n. BIT1 m + BIT1 n = BIT0 (SUC (m + n)))) /\
     ((!m n. NUMERAL m * NUMERAL n = NUMERAL (m * n)) /\
      _0 * _0 = _0 /\
      (!n. _0 * BIT0 n = _0) /\
      (!n. _0 * BIT1 n = _0) /\
      (!n. BIT0 n * _0 = _0) /\
      (!n. BIT1 n * _0 = _0) /\
      (!m n. BIT0 m * BIT0 n = BIT0 (BIT0 (m * n))) /\
      (!m n. BIT0 m * BIT1 n = BIT0 m + BIT0 (BIT0 (m * n))) /\
      (!m n. BIT1 m * BIT0 n = BIT0 n + BIT0 (BIT0 (m * n))) /\
      (!m n. BIT1 m * BIT1 n = BIT1 m + BIT0 n + BIT0 (BIT0 (m * n)))) /\
     ((!m n. NUMERAL m EXP NUMERAL n = NUMERAL (m EXP n)) /\
      _0 EXP _0 = BIT1 _0 /\
      (!m. BIT0 m EXP _0 = BIT1 _0) /\
      (!m. BIT1 m EXP _0 = BIT1 _0) /\
      (!n. _0 EXP BIT0 n = _0 EXP n * _0 EXP n) /\
      (!m n. BIT0 m EXP BIT0 n = BIT0 m EXP n * BIT0 m EXP n) /\
      (!m n. BIT1 m EXP BIT0 n = BIT1 m EXP n * BIT1 m EXP n) /\
      (!n. _0 EXP BIT1 n = _0) /\
      (!m n. BIT0 m EXP BIT1 n = BIT0 m * BIT0 m EXP n * BIT0 m EXP n) /\
      (!m n. BIT1 m EXP BIT1 n = BIT1 m * BIT1 m EXP n * BIT1 m EXP n)) /\
     ((!n. EVEN (NUMERAL n) <=> EVEN n) /\
      (EVEN _0 <=> T) /\
      (!n. EVEN (BIT0 n) <=> T) /\
      (!n. EVEN (BIT1 n) <=> F)) /\
     ((!n. ODD (NUMERAL n) <=> ODD n) /\
      (ODD _0 <=> F) /\
      (!n. ODD (BIT0 n) <=> F) /\
      (!n. ODD (BIT1 n) <=> T)) /\
     ((!m n. NUMERAL m = NUMERAL n <=> m = n) /\
      (_0 = _0 <=> T) /\
      (!n. BIT0 n = _0 <=> n = _0) /\
      (!n. BIT1 n = _0 <=> F) /\
      (!n. _0 = BIT0 n <=> _0 = n) /\
      (!n. _0 = BIT1 n <=> F) /\
      (!m n. BIT0 m = BIT0 n <=> m = n) /\
      (!m n. BIT0 m = BIT1 n <=> F) /\
      (!m n. BIT1 m = BIT0 n <=> F) /\
      (!m n. BIT1 m = BIT1 n <=> m = n)) /\
     ((!m n. NUMERAL m <= NUMERAL n <=> m <= n) /\
      (_0 <= _0 <=> T) /\
      (!n. BIT0 n <= _0 <=> n <= _0) /\
      (!n. BIT1 n <= _0 <=> F) /\
      (!n. _0 <= BIT0 n <=> T) /\
      (!n. _0 <= BIT1 n <=> T) /\
      (!m n. BIT0 m <= BIT0 n <=> m <= n) /\
      (!m n. BIT0 m <= BIT1 n <=> m <= n) /\
      (!m n. BIT1 m <= BIT0 n <=> m < n) /\
      (!m n. BIT1 m <= BIT1 n <=> m <= n)) /\
     ((!m n. NUMERAL m < NUMERAL n <=> m < n) /\
      (_0 < _0 <=> F) /\
      (!n. BIT0 n < _0 <=> F) /\
      (!n. BIT1 n < _0 <=> F) /\
      (!n. _0 < BIT0 n <=> _0 < n) /\
      (!n. _0 < BIT1 n <=> T) /\
      (!m n. BIT0 m < BIT0 n <=> m < n) /\
      (!m n. BIT0 m < BIT1 n <=> m <= n) /\
      (!m n. BIT1 m < BIT0 n <=> m < n) /\
      (!m n. BIT1 m < BIT1 n <=> m < n)) /\
     ((!m n. NUMERAL n >= NUMERAL m <=> n >= m) /\
      _0 >= _0 /\
      (!n. _0 >= BIT0 n <=> _0 >= n) /\
      (!n. ~(_0 >= BIT1 n)) /\
      (!n. BIT0 n >= _0) /\
      (!n. BIT1 n >= _0) /\
      (!m n. BIT0 n >= BIT0 m <=> n >= m) /\
      (!m n. BIT1 n >= BIT0 m <=> n >= m) /\
      (!m n. BIT0 n >= BIT1 m <=> n > m) /\
      (!m n. BIT1 n >= BIT1 m <=> n >= m)) /\
     ((!m n. NUMERAL n > NUMERAL m <=> n > m) /\
      ~(_0 > _0) /\
      (!n. ~(_0 > BIT0 n)) /\
      (!n. ~(_0 > BIT1 n)) /\
      (!n. BIT0 n > _0 <=> n > _0) /\
      (!n. BIT1 n > _0) /\
      (!m n. BIT0 n > BIT0 m <=> n > m) /\
      (!m n. BIT1 n > BIT0 m <=> n >= m) /\
      (!m n. BIT0 n > BIT1 m <=> n > m) /\
      (!m n. BIT1 n > BIT1 m <=> n > m)) /\
     (!m n. NUMERAL m - NUMERAL n = NUMERAL (m - n)) /\
     _0 - _0 = _0 /\
     (!n. _0 - BIT0 n = _0) /\
     (!n. _0 - BIT1 n = _0) /\
     (!n. BIT0 n - _0 = BIT0 n) /\
     (!n. BIT1 n - _0 = BIT1 n) /\
     (!m n. BIT0 m - BIT0 n = BIT0 (m - n)) /\
     (!m n. BIT0 m - BIT1 n = PRE (BIT0 (m - n))) /\
     (!m n. BIT1 m - BIT0 n = (if n <= m then BIT1 (m - n) else _0)) /\
     (!m n. BIT1 m - BIT1 n = BIT0 (m - n))
val NUM_EVEN_CONV : conv = <fun>
val NUM_ODD_CONV : conv = <fun>
0..0..1..2..8..18..solved at 48
0..0..1..2..8..18..solved at 55
0..0..1..2..10..24..118..279..1321..3190..solved at 4661
0..0..1..2..solved at 6
0..0..1..2..solved at 6
0..0..1..2..6..12..28..51..solved at 84
0..0..1..2..6..12..28..57..solved at 90
0..0..1..solved at 4
0..0..1..2..solved at 6
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..2..8..18..68..147..solved at 443
0..0..1..2..8..18..67..146..solved at 427
0..0..1..2..8..18..solved at 55
0..0..1..2..8..18..solved at 48
0..0..1..2..7..14..solved at 23
0..0..1..2..solved at 6
0..0..1..2..solved at 6
0..0..1..2..solved at 6
0..0..solved at 2
0..0..1..3..12..31..100..solved at 139
0..0..1..2..solved at 8
0..0..1..2..6..13..29..solved at 39
0..0..1..2..6..12..28..51..solved at 80
0..0..1..2..6..13..29..solved at 39
0..0..1..2..6..12..28..51..solved at 80
0..0..1..2..7..15..35..77..161..solved at 177
0..0..1..2..6..12..28..51..104..192..solved at 349
0..0..1..solved at 4
0..0..1..2..3..solved at 8
0..0..solved at 2
0..0..1..2..3..solved at 8
0..0..1..solved at 4
0..0..2..solved at 5
0..0..2..solved at 6
val NUM_SUC_CONV : term -> thm = <fun>
val NUM_ADD_CONV : term -> thm = <fun>
val NUM_MULT_CONV : term -> thm = <fun>
val NUM_EXP_CONV : term -> thm = <fun>
val NUM_LT_CONV : term -> thm = <fun>
val NUM_LE_CONV : term -> thm = <fun>
val NUM_EQ_CONV : term -> thm = <fun>
val NUM_GT_CONV : conv = <fun>
val NUM_GE_CONV : conv = <fun>
val NUM_PRE_CONV : term -> thm = <fun>
val NUM_SUB_CONV : term -> thm = <fun>
0..0..1..2..solved at 6
0..0..1..2..solved at 6
val NUM_DIV_CONV : term -> thm = <fun>
val NUM_MOD_CONV : term -> thm = <fun>
val NUM_FACT_CONV : term -> thm = <fun>
val NUM_MAX_CONV : conv = <fun>
val NUM_MIN_CONV : conv = <fun>
val NUM_REL_CONV : term -> thm = <fun>
val NUM_RED_CONV : term -> thm = <fun>
val NUM_REDUCE_CONV : conv = <fun>
val NUM_REDUCE_TAC : tactic = <fun>
val num_CONV : term -> thm = <fun>
0..0..1..solved at 4
0..0..1..solved at 5
0..0..solved at 2
0..0..1..solved at 4
val EXPAND_CASES_CONV : conv = <fun>
- : unit = ()
File "calc_num.ml" already loaded
- : unit = ()
0..0..solved at 2
0..0..1..2..solved at 9
0..0..1..2..9..20..73..154..solved at 284
0..0..1..2..solved at 8
0..0..solved at 2
0..0..1..2..solved at 8
0..0..1..2..9..20..73..154..solved at 229
0..0..1..2..8..18..65..140..472..992..solved at 2047
0..0..0..1..2..3..4..5..6..solved at 20
0..0..1..2..solved at 6
0..0..solved at 2
0..0..solved at 2
val SEMIRING_NORMALIZERS_CONV :
  thm ->
  thm ->
  (term -> bool) * (term -> thm) * (term -> thm) * (term -> thm) ->
  (term -> term -> bool) ->
  (term -> thm) * (term -> thm) * (term -> thm) * (term -> thm) *
  (term -> thm) * (term -> thm) = <fun>
val NUM_NORMALIZE_CONV : term -> thm = <fun>
- : unit = ()
File "normalizer.ml" already loaded
- : unit = ()
type history =
    Start of int
  | Mmul of (num * int list) * history
  | Add of history * history
val RING_AND_IDEAL_CONV :
  (term -> num) * (num -> term) * conv * term * term * term * term * 
  term * term * term * thm * thm * (term -> thm) ->
  (term -> thm) * (term list -> term -> term list) = <fun>
val RING :
  (term -> num) * (num -> term) * conv * term * term * term * term * 
  term * term * term * thm * thm * (term -> thm) -> term -> thm = <fun>
val ideal_cofactors :
  (term -> num) * (num -> term) * conv * term * term * term * term * 
  term * term * term * thm * thm * (term -> thm) ->
  term list -> term -> term list = <fun>
val NUM_SIMPLIFY_CONV : conv = <fun>
0..0..2..4..10..20..52..96..204..356..638..1042..1916..3036..solved at 4498
0..0..1..2..7..16..42..78..161..285..685..solved at 954
0..0..1..2..7..16..42..78..160..281..solved at 672
0..0..2..4..11..21..59..116..239..426..800..1336..solved at 1840
0..0..1..2..7..16..45..86..174..312..724..solved at 772
0..0..1..2..7..16..44..84..168..solved at 185
0..0..2..4..11..21..59..116..239..426..solved at 540
0..0..1..2..7..18..46..solved at 77
0..0..1..2..7..18..47..92..185..solved at 281
0..0..2..4..12..22..solved at 41
0..0..1..2..7..solved at 21
0..0..1..2..7..solved at 18
val NUM_RING : term -> thm = <fun>
- : unit = ()
File "grobner.ml" already loaded
- : unit = ()
val INJ_INVERSE2 : thm =
  |- !P. (!x1 y1 x2 y2. P x1 y1 = P x2 y2 <=> x1 = x2 /\ y1 = y2)
         ==> (?X Y. !x y. X (P x y) = x /\ Y (P x y) = y)
val NUMPAIR : thm = |- !x y. NUMPAIR x y = 2 EXP x * (2 * y + 1)
val NUMPAIR_INJ_LEMMA : thm =
  |- !x1 y1 x2 y2. NUMPAIR x1 y1 = NUMPAIR x2 y2 ==> x1 = x2
val NUMPAIR_INJ : thm =
  |- !x1 y1 x2 y2. NUMPAIR x1 y1 = NUMPAIR x2 y2 <=> x1 = x2 /\ y1 = y2
val NUMPAIR_DEST : thm =
  |- !x y. NUMFST (NUMPAIR x y) = x /\ NUMSND (NUMPAIR x y) = y
val NUMSUM : thm = |- !b x. NUMSUM b x = (if b then SUC (2 * x) else 2 * x)
val NUMSUM_INJ : thm =
  |- !b1 x1 b2 x2. NUMSUM b1 x1 = NUMSUM b2 x2 <=> (b1 <=> b2) /\ x1 = x2
val NUMSUM_DEST : thm =
  |- !x y. (NUMLEFT (NUMSUM x y) <=> x) /\ NUMRIGHT (NUMSUM x y) = y
val INJN : thm = |- !m. INJN m = (\n a. n = m)
val INJN_INJ : thm = |- !n1 n2. INJN n1 = INJN n2 <=> n1 = n2
val INJA : thm = |- !a. INJA a = (\n b. b = a)
val INJA_INJ : thm = |- !a1 a2. INJA a1 = INJA a2 <=> a1 = a2
val INJF : thm = |- !f. INJF f = (\n. f (NUMFST n) (NUMSND n))
val INJF_INJ : thm = |- !f1 f2. INJF f1 = INJF f2 <=> f1 = f2
val INJP : thm =
  |- !f1 f2.
         INJP f1 f2 =
         (\n a. if NUMLEFT n then f1 (NUMRIGHT n) a else f2 (NUMRIGHT n) a)
val INJP_INJ : thm =
  |- !f1 f1' f2 f2'. INJP f1 f2 = INJP f1' f2' <=> f1 = f1' /\ f2 = f2'
val ZCONSTR : thm =
  |- !c i r. ZCONSTR c i r = INJP (INJN (SUC c)) (INJP (INJA i) (INJF r))
val ZBOT : thm = |- ZBOT = INJP (INJN 0) (@z. T)
val ZCONSTR_ZBOT : thm = |- !c i r. ~(ZCONSTR c i r = ZBOT)
val ZRECSPACE_RULES : thm =
  |- ZRECSPACE ZBOT /\
     (!c i r. (!n. ZRECSPACE (r n)) ==> ZRECSPACE (ZCONSTR c i r))
val ZRECSPACE_INDUCT : thm =
  |- !ZRECSPACE'. ZRECSPACE' ZBOT /\
                  (!c i r.
                       (!n. ZRECSPACE' (r n)) ==> ZRECSPACE' (ZCONSTR c i r))
                  ==> (!a. ZRECSPACE a ==> ZRECSPACE' a)
val ZRECSPACE_CASES : thm =
  |- !a. ZRECSPACE a <=>
         a = ZBOT \/ (?c i r. a = ZCONSTR c i r /\ (!n. ZRECSPACE (r n)))
val recspace_tydef : thm * thm =
  (|- _mk_rec (_dest_rec a) = a,
   |- ZRECSPACE r <=> _dest_rec (_mk_rec r) = r)
val BOTTOM : thm = |- BOTTOM = _mk_rec ZBOT
val CONSTR : thm =
  |- !c i r. CONSTR c i r = _mk_rec (ZCONSTR c i (\n. _dest_rec (r n)))
val MK_REC_INJ : thm =
  |- !x y. _mk_rec x = _mk_rec y ==> ZRECSPACE x /\ ZRECSPACE y ==> x = y
val DEST_REC_INJ : thm = |- !x y. _dest_rec x = _dest_rec y <=> x = y
val CONSTR_BOT : thm = |- !c i r. ~(CONSTR c i r = BOTTOM)
val CONSTR_INJ : thm =
  |- !c1 i1 r1 c2 i2 r2.
         CONSTR c1 i1 r1 = CONSTR c2 i2 r2 <=> c1 = c2 /\ i1 = i2 /\ r1 = r2
Searching with limit 0
Searching with limit 1
Searching with limit 2
val CONSTR_IND : thm =
  |- !P. P BOTTOM /\ (!c i r. (!n. P (r n)) ==> P (CONSTR c i r))
         ==> (!x. P x)
val CONSTR_REC : thm =
  |- !Fn. ?f. !c i r. f (CONSTR c i r) = Fn c i r (\n. f (r n))
val FCONS : thm =
  |- (!a f. FCONS a f 0 = a) /\ (!a f n. FCONS a f (SUC n) = f n)
val FCONS_UNDO : thm = |- !f. f = FCONS (f 0) (f o SUC)
val FNIL : thm = |- !n. FNIL n = (@x. T)
val define_type_raw :
  (hol_type * (string * hol_type list) list) list -> thm * thm = <fun>
val parse_inductive_type_specification :
  string -> (hol_type * (string * hol_type list) list) list = <fun>
val sum_INDUCT : thm =
  |- !P. (!a. P (INL a)) /\ (!a. P (INR a)) ==> (!x. P x)
val sum_RECURSION : thm =
  |- !INL' INR'. ?fn. (!a. fn (INL a) = INL' a) /\ (!a. fn (INR a) = INR' a)
val OUTL : thm = |- OUTL (INL x) = x
val OUTR : thm = |- OUTR (INR y) = y
val define_type_raw :
  (hol_type * (string * hol_type list) list) list -> thm * thm = <fun>
val option_INDUCT : thm = |- !P. P NONE /\ (!a. P (SOME a)) ==> (!x. P x)
val option_RECURSION : thm =
  |- !NONE' SOME'. ?fn. fn NONE = NONE' /\ (!a. fn (SOME a) = SOME' a)
val list_INDUCT : thm =
  |- !P. P [] /\ (!a0 a1. P a1 ==> P (CONS a0 a1)) ==> (!x. P x)
val list_RECURSION : thm =
  |- !NIL' CONS'.
         ?fn. fn [] = NIL' /\ (!a0 a1. fn (CONS a0 a1) = CONS' a0 a1 (fn a1))
val prove_constructors_injective : thm -> thm = <fun>
val prove_constructors_distinct : thm -> thm = <fun>
val prove_cases_thm : thm -> thm = <fun>
- : unit = ()
val basic_rectype_net : '_a net ref = {contents = Netnode ([], [])}
val distinctness_store : (string * thm) list ref =
  {contents = [("bool", |- (T <=> F) <=> F)]}
val injectivity_store : '_a list ref = {contents = []}
val extend_rectype_net : string * ('a * 'b * thm) -> unit = <fun>
- : unit = ()
val distinctness : string -> thm = <fun>
val injectivity : string -> thm = <fun>
val cases : string -> thm = <fun>
val ISO : thm = |- !g f. ISO f g <=> (!x. f (g x) = x) /\ (!y. g (f y) = y)
val ISO_REFL : thm = |- ISO (\x. x) (\x. x)
0..0..1..2..6..13..30..solved at 70
0..0..1..2..6..13..30..solved at 70
val ISO_FUN : thm =
  |- ISO f f' /\ ISO g g' ==> ISO (\h a'. g (h (f' a'))) (\h a. g' (h (f a)))
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..2..6..11..solved at 22
0..0..solved at 2
0..0..solved at 2
0..0..1..2..solved at 6
val ISO_USAGE : thm =
  |- ISO f g
     ==> (!P. (!x. P x) <=> (!x. P (g x))) /\
         (!P. (?x. P x) <=> (?x. P (g x))) /\
         (!a b. a = g b <=> f a = b)
Warning: inventing type variables
val define_type_raw :
  (hol_type * (string * hol_type list) list) list -> thm * thm = <fun>
val the_inductive_types : (string * (thm * thm)) list ref =
  {contents =
    [("list = NIL | CONS A list",
      (|- !P. P [] /\ (!a0 a1. P a1 ==> P (CONS a0 a1)) ==> (!x. P x),
       |- !NIL' CONS'.
              ?fn. fn [] = NIL' /\
                   (!a0 a1. fn (CONS a0 a1) = CONS' a0 a1 (fn a1))));
     ("option = NONE | SOME A",
      (|- !P. P NONE /\ (!a. P (SOME a)) ==> (!x. P x),
       |- !NONE' SOME'. ?fn. fn NONE = NONE' /\ (!a. fn (SOME a) = SOME' a)));
     ("sum = INL A | INR B",
      (|- !P. (!a. P (INL a)) /\ (!a. P (INR a)) ==> (!x. P x),
       |- !INL' INR'.
              ?fn. (!a. fn (INL a) = INL' a) /\ (!a. fn (INR a) = INR' a)))]}
val define_type : string -> thm * thm = <fun>
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 3
0..0..solved at 4
0..0..solved at 5
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
Warning: inventing type variables
Warning: inventing type variables
Warning: inventing type variables
val UNWIND_CONV : conv = <fun>
val MATCH_CONV : conv = <fun>
Warning: inventing type variables
0..0..1..solved at 4
0..0..solved at 2
Warning: inventing type variables
0..0..1..solved at 4
0..0..solved at 2
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..solved at 2
0..0..solved at 2
val FORALL_UNWIND_CONV : conv = <fun>
- : unit = ()
File "ind_types.ml" already loaded
- : unit = ()
val LIST_INDUCT_TAC : tactic = <fun>
val HD : thm = |- HD (CONS h t) = h
val TL : thm = |- TL (CONS h t) = t
val APPEND : thm =
  |- (!l. APPEND [] l = l) /\
     (!h t l. APPEND (CONS h t) l = CONS h (APPEND t l))
val REVERSE : thm =
  |- REVERSE [] = [] /\ REVERSE (CONS x l) = APPEND (REVERSE l) [x]
val LENGTH : thm =
  |- LENGTH [] = 0 /\ (!h t. LENGTH (CONS h t) = SUC (LENGTH t))
val MAP : thm =
  |- (!f. MAP f [] = []) /\ (!f h t. MAP f (CONS h t) = CONS (f h) (MAP f t))
val LAST : thm = |- LAST (CONS h t) = (if t = [] then h else LAST t)
Warning: inventing type variables
val BUTLAST : thm =
  |- BUTLAST [] = [] /\
     BUTLAST (CONS h t) = (if t = [] then [] else CONS h (BUTLAST t))
Warning: inventing type variables
val REPLICATE : thm =
  |- REPLICATE 0 x = [] /\ REPLICATE (SUC n) x = CONS x (REPLICATE n x)
Warning: inventing type variables
val NULL : thm = |- (NULL [] <=> T) /\ (NULL (CONS h t) <=> F)
Warning: inventing type variables
val ALL : thm = |- (ALL P [] <=> T) /\ (ALL P (CONS h t) <=> P h /\ ALL P t)
Warning: inventing type variables
val EX : thm = |- (EX P [] <=> F) /\ (EX P (CONS h t) <=> P h \/ EX P t)
Warning: inventing type variables
val ITLIST : thm =
  |- ITLIST f [] b = b /\ ITLIST f (CONS h t) b = f h (ITLIST f t b)
Warning: inventing type variables
val MEM : thm =
  |- (MEM x [] <=> F) /\ (MEM x (CONS h t) <=> x = h \/ MEM x t)
Warning: inventing type variables
val ALL2_DEF : thm =
  |- (ALL2 P [] l2 <=> l2 = []) /\
     (ALL2 P (CONS h1 t1) l2 <=>
      (if l2 = [] then F else P h1 (HD l2) /\ ALL2 P t1 (TL l2)))
Warning: inventing type variables
val ALL2 : thm =
  |- (ALL2 P [] [] <=> T) /\
     (ALL2 P (CONS h1 t1) [] <=> F) /\
     (ALL2 P [] (CONS h2 t2) <=> F) /\
     (ALL2 P (CONS h1 t1) (CONS h2 t2) <=> P h1 h2 /\ ALL2 P t1 t2)
Warning: inventing type variables
val MAP2_DEF : thm =
  |- MAP2 f [] l = [] /\
     MAP2 f (CONS h1 t1) l = CONS (f h1 (HD l)) (MAP2 f t1 (TL l))
Warning: inventing type variables
val MAP2 : thm =
  |- MAP2 f [] [] = [] /\
     MAP2 f (CONS h1 t1) (CONS h2 t2) = CONS (f h1 h2) (MAP2 f t1 t2)
Warning: inventing type variables
val EL : thm = |- EL 0 l = HD l /\ EL (SUC n) l = EL n (TL l)
Warning: inventing type variables
val FILTER : thm =
  |- FILTER P [] = [] /\
     FILTER P (CONS h t) = (if P h then CONS h (FILTER P t) else FILTER P t)
Warning: inventing type variables
val ASSOC : thm =
  |- ASSOC a (CONS h t) = (if FST h = a then SND h else ASSOC a t)
Warning: inventing type variables
val ITLIST2_DEF : thm =
  |- ITLIST2 f [] l2 b = b /\
     ITLIST2 f (CONS h1 t1) l2 b = f h1 (HD l2) (ITLIST2 f t1 (TL l2) b)
Warning: inventing type variables
val ITLIST2 : thm =
  |- ITLIST2 f [] [] b = b /\
     ITLIST2 f (CONS h1 t1) (CONS h2 t2) b = f h1 h2 (ITLIST2 f t1 t2 b)
Warning: inventing type variables
val ZIP_DEF : thm =
  |- ZIP [] l2 = [] /\ ZIP (CONS h1 t1) l2 = CONS (h1,HD l2) (ZIP t1 (TL l2))
Warning: inventing type variables
val ZIP : thm =
  |- ZIP [] [] = [] /\
     ZIP (CONS h1 t1) (CONS h2 t2) = CONS (h1,h2) (ZIP t1 t2)
val NOT_CONS_NIL : thm = |- !h t. ~(CONS h t = [])
val LAST_CLAUSES : thm =
  |- LAST [h] = h /\ LAST (CONS h (CONS k t)) = LAST (CONS k t)
val APPEND_NIL : thm = |- !l. APPEND l [] = l
val APPEND_ASSOC : thm =
  |- !l m n. APPEND l (APPEND m n) = APPEND (APPEND l m) n
val REVERSE_APPEND : thm =
  |- !l m. REVERSE (APPEND l m) = APPEND (REVERSE m) (REVERSE l)
val REVERSE_REVERSE : thm = |- !l. REVERSE (REVERSE l) = l
val CONS_11 : thm =
  |- !h1 h2 t1 t2. CONS h1 t1 = CONS h2 t2 <=> h1 = h2 /\ t1 = t2
0..0..solved at 2
0..0..solved at 2
val list_CASES : thm = |- !l. l = [] \/ (?h t. l = CONS h t)
val LENGTH_APPEND : thm = |- !l m. LENGTH (APPEND l m) = LENGTH l + LENGTH m
val MAP_APPEND : thm =
  |- !f l1 l2. MAP f (APPEND l1 l2) = APPEND (MAP f l1) (MAP f l2)
val LENGTH_MAP : thm = |- !l f. LENGTH (MAP f l) = LENGTH l
val LENGTH_EQ_NIL : thm = |- !l. LENGTH l = 0 <=> l = []
Warning: inventing type variables
0..0..0..0..solved at 4
0..0..solved at 2
val LENGTH_EQ_CONS : thm =
  |- !l n. LENGTH l = SUC n <=> (?h t. l = CONS h t /\ LENGTH t = n)
val MAP_o : thm = |- !f g l. MAP (g o f) l = MAP g (MAP f l)
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..6..12..solved at 26
val MAP_EQ : thm = |- !f g l. ALL (\x. f x = g x) l ==> MAP f l = MAP g l
Warning: inventing type variables
0..0..2..4..solved at 9
0..0..2..4..solved at 9
0..0..solved at 3
0..0..solved at 3
0..0..1..2..solved at 7
0..0..solved at 2
val ALL_IMP : thm =
  |- !P Q l. (!x. MEM x l /\ P x ==> Q x) /\ ALL P l ==> ALL Q l
Warning: inventing type variables
val NOT_EX : thm = |- !P l. ~EX P l <=> ALL (\x. ~P x) l
Warning: inventing type variables
val NOT_ALL : thm = |- !P l. ~ALL P l <=> EX (\x. ~P x) l
Warning: inventing type variables
val ALL_MAP : thm = |- !P f l. ALL P (MAP f l) <=> ALL (P o f) l
Warning: inventing type variables
val ALL_T : thm = |- !l. ALL (\x. T) l
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..2..solved at 6
0..0..1..solved at 4
val MAP_EQ_ALL2 : thm =
  |- !l m. ALL2 (\x y. f x = f y) l m ==> MAP f l = MAP f m
Warning: inventing type variables
val ALL2_MAP : thm = |- !P f l. ALL2 P (MAP f l) l <=> ALL (\a. P (f a) a) l
Warning: inventing type variables
val MAP_EQ_DEGEN : thm = |- !l f. ALL (\x. f x = x) l ==> MAP f l = l
Warning: inventing type variables
val ALL2_AND_RIGHT : thm =
  |- !l m P Q. ALL2 (\x y. P x /\ Q x y) l m <=> ALL P l /\ ALL2 Q l m
Warning: inventing type variables
val ITLIST_APPEND : thm =
  |- !f a l1 l2. ITLIST f (APPEND l1 l2) a = ITLIST f l1 (ITLIST f l2 a)
Warning: inventing type variables
val ITLIST_EXTRA : thm =
  |- !l. ITLIST f (APPEND l [a]) b = ITLIST f l (f a b)
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ALL_MP : thm = |- !P Q l. ALL (\x. P x ==> Q x) l /\ ALL P l ==> ALL Q l
Warning: inventing type variables
val AND_ALL : thm = |- !l. ALL P l /\ ALL Q l <=> ALL (\x. P x /\ Q x) l
Warning: inventing type variables
0..0..3..6..solved at 10
0..0..3..6..solved at 13
0..0..solved at 2
0..0..3..6..solved at 10
0..0..solved at 2
0..0..solved at 2
val EX_IMP : thm =
  |- !P Q l. (!x. MEM x l /\ P x ==> Q x) /\ EX P l ==> EX Q l
Warning: inventing type variables
0..0..1..solved at 5
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..3..solved at 7
0..0..3..solved at 7
0..0..solved at 2
0..0..solved at 4
val ALL_MEM : thm = |- !P l. (!x. MEM x l ==> P x) <=> ALL P l
Warning: inventing type variables
val LENGTH_REPLICATE : thm = |- !n x. LENGTH (REPLICATE n x) = n
Warning: inventing type variables
val EX_MAP : thm = |- !P f l. EX P (MAP f l) <=> EX (P o f) l
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 5
0..0..solved at 3
0..0..solved at 4
val EXISTS_EX : thm = |- !P l. (?x. EX (P x) l) <=> EX (\s. ?x. P x s) l
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 2
0..0..solved at 3
val FORALL_ALL : thm = |- !P l. (!x. ALL (P x) l) <=> ALL (\s. !x. P x s) l
Warning: inventing type variables
val MEM_APPEND : thm =
  |- !x l1 l2. MEM x (APPEND l1 l2) <=> MEM x l1 \/ MEM x l2
Warning: inventing type variables
0..0..0..solved at 4
0..0..0..solved at 3
0..0..solved at 2
0..0..1..solved at 6
val MEM_MAP : thm = |- !f y l. MEM y (MAP f l) <=> (?x. MEM x l /\ y = f x)
Warning: inventing type variables
val FILTER_APPEND : thm =
  |- !P l1 l2. FILTER P (APPEND l1 l2) = APPEND (FILTER P l1) (FILTER P l2)
Warning: inventing type variables
val FILTER_MAP : thm =
  |- !P f l. FILTER P (MAP f l) = MAP f (FILTER (P o f) l)
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val MEM_FILTER : thm = |- !P l x. MEM x (FILTER P l) <=> P x /\ MEM x l
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..0..solved at 4
0..0..0..solved at 3
0..0..solved at 3
0..0..3..solved at 9
0..0..1..solved at 7
0..0..solved at 2
val EX_MEM : thm = |- !P l. (?x. P x /\ MEM x l) <=> EX P l
Warning: inventing type variables
val MAP_FST_ZIP : thm =
  |- !l1 l2. LENGTH l1 = LENGTH l2 ==> MAP FST (ZIP l1 l2) = l1
Warning: inventing type variables
val MAP_SND_ZIP : thm =
  |- !l1 l2. LENGTH l1 = LENGTH l2 ==> MAP SND (ZIP l1 l2) = l2
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val MEM_ASSOC : thm = |- !l x. MEM (x,ASSOC x l) l <=> MEM x (MAP FST l)
Warning: inventing type variables
val ALL_APPEND : thm =
  |- !P l1 l2. ALL P (APPEND l1 l2) <=> ALL P l1 /\ ALL P l2
Warning: inventing type variables
val MEM_EL : thm = |- !l n. n < LENGTH l ==> MEM (EL n l) l
0..0..2..4..10..20..40..solved at 67
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
val MEM_EXISTS_EL : thm =
  |- !l x. MEM x l <=> (?i. i < LENGTH l /\ x = EL i l)
Warning: inventing type variables
0..0..1..solved at 4
0..0..1..2..solved at 6
val ALL_EL : thm = |- !P l. (!i. i < LENGTH l ==> P (EL i l)) <=> ALL P l
Warning: inventing type variables
val ALL2_MAP2 : thm =
  |- !l m. ALL2 P (MAP f l) (MAP g m) <=> ALL2 (\x y. P (f x) (g y)) l m
Warning: inventing type variables
val AND_ALL2 : thm =
  |- !P Q l m. ALL2 P l m /\ ALL2 Q l m <=> ALL2 (\x y. P x y /\ Q x y) l m
Warning: inventing type variables
val ALL2_ALL : thm = |- !P l. ALL2 P l l <=> ALL (\x. P x x) l
Warning: inventing type variables
val APPEND_EQ_NIL : thm = |- !l m. APPEND l m = [] <=> l = [] /\ m = []
Warning: inventing type variables
val LENGTH_MAP2 : thm =
  |- !f l m. LENGTH l = LENGTH m ==> LENGTH (MAP2 f l m) = LENGTH m
Warning: inventing type variables
val MAP_EQ_NIL : thm = |- !f l. MAP f l = [] <=> l = []
0..0..2..solved at 6
0..0..1..solved at 4
0..0..2..solved at 6
0..0..1..solved at 4
val INJECTIVE_MAP : thm =
  |- !f. (!l m. MAP f l = MAP f m ==> l = m) <=> (!x y. f x = f y ==> x = y)
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..1..2..5..9..15..22..29..36..solved at 56
val SURJECTIVE_MAP : thm = |- !f. (!m. ?l. MAP f l = m) <=> (!y. ?x. f x = y)
Warning: inventing type variables
val MAP_ID : thm = |- !l. MAP (\x. x) l = l
Warning: inventing type variables
val MAP_I : thm = |- MAP I = I
Warning: inventing type variables
val APPEND_BUTLAST_LAST : thm =
  |- !l. ~(l = []) ==> APPEND (BUTLAST l) [LAST l] = l
Warning: inventing type variables
0..0..solved at 2
val LAST_APPEND : thm =
  |- !p q. LAST (APPEND p q) = (if q = [] then LAST p else LAST q)
Warning: inventing type variables
val LENGTH_TL : thm = |- !l. ~(l = []) ==> LENGTH (TL l) = LENGTH l - 1
Warning: inventing type variables
val EL_APPEND : thm =
  |- !k l m.
         EL k (APPEND l m) =
         (if k < LENGTH l then EL k l else EL (k - LENGTH l) m)
Warning: inventing type variables
val EL_TL : thm = |- !n. EL n (TL l) = EL (n + 1) l
Warning: inventing type variables
val EL_CONS : thm =
  |- !n h t. EL n (CONS h t) = (if n = 0 then h else EL (n - 1) t)
Warning: inventing type variables
val LAST_EL : thm = |- !l. ~(l = []) ==> LAST l = EL (LENGTH l - 1) l
val HD_APPEND : thm =
  |- !l m. HD (APPEND l m) = (if l = [] then HD m else HD l)
Warning: inventing type variables
val CONS_HD_TL : thm = |- !l. ~(l = []) ==> l = CONS (HD l) (TL l)
Warning: inventing type variables
val EL_MAP : thm = |- !f n l. n < LENGTH l ==> EL n (MAP f l) = f (EL n l)
Warning: inventing type variables
val MAP_REVERSE : thm = |- !f l. REVERSE (MAP f l) = MAP f (REVERSE l)
val ALL_FILTER : thm =
  |- !P Q l. ALL P (FILTER Q l) <=> ALL (\x. Q x ==> P x) l
Warning: inventing type variables
val APPEND_SING : thm = |- !h t. APPEND [h] t = CONS h t
0..0..3..8..16..solved at 33
0..0..3..8..16..solved at 35
0..0..solved at 2
0..0..3..8..16..solved at 35
0..0..solved at 5
0..0..solved at 5
0..0..solved at 2
0..0..4..10..22..75..155..solved at 209
val MEM_APPEND_DECOMPOSE_LEFT : thm =
  |- !x l. MEM x l <=> (?l1 l2. ~MEM x l1 /\ l = APPEND l1 (CONS x l2))
0..0..solved at 3
val MEM_APPEND_DECOMPOSE : thm =
  |- !x l. MEM x l <=> (?l1 l2. l = APPEND l1 (CONS x l2))
val mk_cons : term -> term -> term = <fun>
val mk_list : term list * hol_type -> term = <fun>
val mk_flist : term list -> term = <fun>
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
val MONO_ALL : thm = |- (!x. P x ==> Q x) ==> ALL P l ==> ALL Q l
0..0..2..solved at 5
0..0..2..solved at 5
val MONO_ALL2 : thm =
  |- (!x y. P x y ==> Q x y) ==> ALL2 P l l' ==> ALL2 Q l l'
- : unit = ()
val LIST_CONV : conv -> conv = <fun>
val char_INDUCT : thm =
  |- !P. (!a0 a1 a2 a3 a4 a5 a6 a7. P (ASCII a0 a1 a2 a3 a4 a5 a6 a7))
         ==> (!x. P x)
val char_RECURSION : thm =
  |- !f. ?fn. !a0 a1 a2 a3 a4 a5 a6 a7.
                  fn (ASCII a0 a1 a2 a3 a4 a5 a6 a7) =
                  f a0 a1 a2 a3 a4 a5 a6 a7
- : unit = ()
- : unit = ()
File "lists.ml" already loaded
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val prioritize_num : unit -> unit = <fun>
val dist : thm = |- !n m. dist (m,n) = m - n + n - m
val DIST_REFL : thm = |- !n. dist (n,n) = 0
val DIST_LZERO : thm = |- !n. dist (0,n) = n
val DIST_RZERO : thm = |- !n. dist (n,0) = n
val DIST_SYM : thm = |- !m n. dist (m,n) = dist (n,m)
val DIST_LADD : thm = |- !m p n. dist (m + n,m + p) = dist (n,p)
val DIST_RADD : thm = |- !m p n. dist (m + p,n + p) = dist (m,n)
val DIST_LADD_0 : thm = |- !m n. dist (m + n,m) = n
val DIST_RADD_0 : thm = |- !m n. dist (m,m + n) = n
val DIST_LMUL : thm = |- !m n p. m * dist (n,p) = dist (m * n,m * p)
val DIST_RMUL : thm = |- !m n p. dist (m,n) * p = dist (m * p,n * p)
val DIST_EQ_0 : thm = |- !m n. dist (m,n) = 0 <=> m = n
val DIST_ELIM_THM : thm =
  |- P (dist (x,y)) <=> (!d. (x = y + d ==> P d) /\ (y = x + d ==> P d))
val DIST_LE_CASES : thm =
  |- !m n p. dist (m,n) <= p <=> m <= n + p /\ n <= m + p
val DIST_ADDBOUND : thm = |- !m n. dist (m,n) <= m + n
val DIST_TRIANGLE : thm = |- !m n p. dist (m,p) <= dist (m,n) + dist (n,p)
val DIST_ADD2 : thm =
  |- !m n p q. dist (m + n,p + q) <= dist (m,p) + dist (n,q)
val DIST_ADD2_REV : thm =
  |- !m n p q. dist (m,p) <= dist (m + n,p + q) + dist (n,q)
val DIST_TRIANGLE_LE : thm =
  |- !m n p q. dist (m,n) + dist (n,p) <= q ==> dist (m,p) <= q
val DIST_TRIANGLES_LE : thm =
  |- !m n p q r s.
         dist (m,n) <= r /\ dist (p,q) <= s
         ==> dist (m,p) <= dist (n,q) + r + s
val BOUNDS_LINEAR : thm = |- !A B C. (!n. A * n <= B * n + C) <=> A <= B
val BOUNDS_LINEAR_0 : thm = |- !A B. (!n. A * n <= B) <=> A = 0
val BOUNDS_DIVIDED : thm =
  |- !P. (?B. !n. P n <= B) <=> (?A B. !n. n * P n <= A * n + B)
val BOUNDS_NOTZERO : thm =
  |- !P A B.
         P 0 0 = 0 /\ (!m n. P m n <= A * (m + n) + B)
         ==> (?B. !m n. P m n <= B * (m + n))
val BOUNDS_IGNORE : thm =
  |- !P Q. (?B. !i. P i <= Q i + B) <=> (?B N. !i. N <= i ==> P i <= Q i + B)
val is_nadd : thm =
  |- !x. is_nadd x <=> (?B. !m n. dist (m * x n,n * x m) <= B * (m + n))
val is_nadd_0 : thm = |- is_nadd (\n. 0)
val nadd_abs : thm = |- mk_nadd (dest_nadd a) = a
val nadd_rep : thm = |- is_nadd r <=> dest_nadd (mk_nadd r) = r
- : unit = ()
- : unit = ()
val NADD_CAUCHY : thm =
  |- !x. ?B. !m n. dist (m * fn x n,n * fn x m) <= B * (m + n)
val NADD_BOUND : thm = |- !x. ?A B. !n. fn x n <= A * n + B
val NADD_MULTIPLICATIVE : thm =
  |- !x. ?B. !m n. dist (fn x (m * n),m * fn x n) <= B * m + B
val NADD_ADDITIVE : thm =
  |- !x. ?B. !m n. dist (fn x (m + n),fn x m + fn x n) <= B
val NADD_SUC : thm = |- !x. ?B. !n. dist (fn x (SUC n),fn x n) <= B
val NADD_DIST_LEMMA : thm =
  |- !x. ?B. !m n. dist (fn x (m + n),fn x m) <= B * n
val NADD_DIST : thm = |- !x. ?B. !m n. dist (fn x m,fn x n) <= B * dist (m,n)
val NADD_ALTMUL : thm =
  |- !x y. ?A B. !n. dist (n * fn x (fn y n),fn x n * fn y n) <= A * n + B
- : unit = ()
val nadd_eq : thm = |- !x y. x === y <=> (?B. !n. dist (fn x n,fn y n) <= B)
val NADD_EQ_REFL : thm = |- !x. x === x
val NADD_EQ_SYM : thm = |- !x y. x === y <=> y === x
val NADD_EQ_TRANS : thm = |- !x y z. x === y /\ y === z ==> x === z
- : unit = ()
val nadd_of_num : thm = |- !k. & k = afn (\n. k * n)
val NADD_OF_NUM : thm = |- !k. fn (& k) = (\n. k * n)
val NADD_OF_NUM_WELLDEF : thm = |- !m n. m = n ==> & m === & n
val NADD_OF_NUM_EQ : thm = |- !m n. & m === & n <=> m = n
- : unit = ()
val nadd_le : thm = |- !x y. x <<= y <=> (?B. !n. fn x n <= fn y n + B)
val NADD_LE_WELLDEF_LEMMA : thm =
  |- !x x' y y'. x === x' /\ y === y' /\ x <<= y ==> x' <<= y'
val NADD_LE_WELLDEF : thm =
  |- !x x' y y'. x === x' /\ y === y' ==> (x <<= y <=> x' <<= y')
val NADD_LE_REFL : thm = |- !x. x <<= x
val NADD_LE_TRANS : thm = |- !x y z. x <<= y /\ y <<= z ==> x <<= z
val NADD_LE_ANTISYM : thm = |- !x y. x <<= y /\ y <<= x <=> x === y
val NADD_LE_TOTAL_LEMMA : thm =
  |- !x y. ~(x <<= y) ==> (!B. ?n. ~(n = 0) /\ fn y n + B < fn x n)
Searching with limit 0
Searching with limit 1
Searching with limit 2
val NADD_LE_TOTAL : thm = |- !x y. x <<= y \/ y <<= x
val NADD_ARCH : thm = |- !x. ?n. x <<= & n
val NADD_OF_NUM_LE : thm = |- !m n. & m <<= & n <=> m <= n
- : unit = ()
val nadd_add : thm = |- !x y. x ++ y = afn (\n. fn x n + fn y n)
val NADD_ADD : thm = |- !x y. fn (x ++ y) = (\n. fn x n + fn y n)
val NADD_ADD_WELLDEF : thm =
  |- !x x' y y'. x === x' /\ y === y' ==> x ++ y === x' ++ y'
val NADD_ADD_SYM : thm = |- !x y. x ++ y === y ++ x
val NADD_ADD_ASSOC : thm = |- !x y z. x ++ y ++ z === (x ++ y) ++ z
val NADD_ADD_LID : thm = |- !x. & 0 ++ x === x
val NADD_ADD_LCANCEL : thm = |- !x y z. x ++ y === x ++ z ==> y === z
val NADD_LE_ADD : thm = |- !x y. x <<= x ++ y
val NADD_LE_EXISTS : thm = |- !x y. x <<= y ==> (?d. y === x ++ d)
val NADD_OF_NUM_ADD : thm = |- !m n. & m ++ & n === & (m + n)
- : unit = ()
val nadd_mul : thm = |- !x y. x ** y = afn (\n. fn x (fn y n))
val NADD_MUL : thm = |- !x y. fn (x ** y) = (\n. fn x (fn y n))
val NADD_MUL_SYM : thm = |- !x y. x ** y === y ** x
val NADD_MUL_ASSOC : thm = |- !x y z. x ** y ** z === (x ** y) ** z
val NADD_MUL_LID : thm = |- !x. & 1 ** x === x
val NADD_LDISTRIB : thm = |- !x y z. x ** (y ++ z) === x ** y ++ x ** z
val NADD_MUL_WELLDEF_LEMMA : thm =
  |- !x y y'. y === y' ==> x ** y === x ** y'
val NADD_MUL_WELLDEF : thm =
  |- !x x' y y'. x === x' /\ y === y' ==> x ** y === x' ** y'
val NADD_OF_NUM_MUL : thm = |- !m n. & m ** & n === & (m * n)
val NADD_LE_0 : thm = |- !x. & 0 <<= x
val NADD_EQ_IMP_LE : thm = |- !x y. x === y ==> x <<= y
val NADD_LE_LMUL : thm = |- !x y z. y <<= z ==> x ** y <<= x ** z
0..0..1..2..3..10..solved at 16
val NADD_LE_RMUL : thm = |- !x y z. x <<= y ==> x ** z <<= y ** z
val NADD_LE_RADD : thm = |- !x y z. x ++ z <<= y ++ z <=> x <<= y
0..0..1..3..6..12..solved at 21
0..0..1..3..6..16..solved at 33
val NADD_LE_LADD : thm = |- !x y z. x ++ y <<= x ++ z <=> y <<= z
0..0..1..4..10..23..48..94..solved at 172
val NADD_RDISTRIB : thm = |- !x y z. (x ++ y) ** z === x ** z ++ y ** z
val NADD_ARCH_MULT : thm = |- !x k. ~(x === & 0) ==> (?N. & k <<= & N ** x)
0..0..1..4..8..solved at 13
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..2..3..solved at 8
0..0..1..2..5..19..42..solved at 59
val NADD_ARCH_ZERO : thm = |- !x k. (!n. & n ** x <<= k) ==> x === & 0
0..0..1..3..6..16..37..70..121..205..325..solved at 432
0..0..1..2..solved at 6
val NADD_ARCH_LEMMA : thm =
  |- !x y z. (!n. & n ** x <<= & n ** y ++ z) ==> x <<= y
Searching with limit 0
Searching with limit 1
Searching with limit 2
val NADD_COMPLETE : thm =
  |- !P. (?x. P x) /\ (?M. !x. P x ==> x <<= M)
         ==> (?M. (!x. P x ==> x <<= M) /\
                  (!M'. (!x. P x ==> x <<= M') ==> M <<= M'))
val NADD_UBOUND : thm = |- !x. ?B N. !n. N <= n ==> fn x n <= B * n
val NADD_NONZERO : thm =
  |- !x. ~(x === & 0) ==> (?N. !n. N <= n ==> ~(fn x n = 0))
val NADD_LBOUND : thm =
  |- !x. ~(x === & 0) ==> (?A N. !n. N <= n ==> n <= A * fn x n)
val nadd_rinv : thm = |- !x. nadd_rinv x = (\n. (n * n) DIV fn x n)
val NADD_MUL_LINV_LEMMA0 : thm =
  |- !x. ~(x === & 0) ==> (?A B. !n. nadd_rinv x n <= A * n + B)
val NADD_MUL_LINV_LEMMA1 : thm =
  |- !x n. ~(fn x n = 0) ==> dist (fn x n * nadd_rinv x n,n * n) <= fn x n
val NADD_MUL_LINV_LEMMA2 : thm =
  |- !x. ~(x === & 0)
         ==> (?N. !n. N <= n
                      ==> dist (fn x n * nadd_rinv x n,n * n) <= fn x n)
val NADD_MUL_LINV_LEMMA3 : thm =
  |- !x. ~(x === & 0)
         ==> (?N. !m n.
                      N <= n
                      ==> dist
                          (m * fn x m * fn x n * nadd_rinv x n,
                           m * fn x m * n * n) <=
                          m * fn x m * fn x n)
val NADD_MUL_LINV_LEMMA4 : thm =
  |- !x. ~(x === & 0)
         ==> (?N. !m n.
                      N <= m /\ N <= n
                      ==> (fn x m * fn x n) *
                          dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                          (m * n) * dist (m * fn x n,n * fn x m) +
                          (fn x m * fn x n) * (m + n))
val NADD_MUL_LINV_LEMMA5 : thm =
  |- !x. ~(x === & 0)
         ==> (?B N.
                  !m n.
                      N <= m /\ N <= n
                      ==> (fn x m * fn x n) *
                          dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                          B * (m * n) * (m + n))
val NADD_MUL_LINV_LEMMA6 : thm =
  |- !x. ~(x === & 0)
         ==> (?B N.
                  !m n.
                      N <= m /\ N <= n
                      ==> (m * n) *
                          dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                          B * (m * n) * (m + n))
val NADD_MUL_LINV_LEMMA7 : thm =
  |- !x. ~(x === & 0)
         ==> (?B N.
                  !m n.
                      N <= m /\ N <= n
                      ==> dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                          B * (m + n))
val NADD_MUL_LINV_LEMMA7a : thm =
  |- !x. ~(x === & 0)
         ==> (!N. ?A B.
                      !m n.
                          m <= N
                          ==> dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                              A * n + B)
val NADD_MUL_LINV_LEMMA8 : thm =
  |- !x. ~(x === & 0)
         ==> (?B. !m n.
                      dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                      B * (m + n))
val nadd_inv : thm =
  |- !x. nadd_inv x = (if x === & 0 then & 0 else afn (nadd_rinv x))
- : unit = ()
val NADD_INV : thm =
  |- !x. fn (inv x) = (if x === & 0 then \n. 0 else nadd_rinv x)
val NADD_MUL_LINV : thm = |- !x. ~(x === & 0) ==> inv x ** x === & 1
val NADD_INV_0 : thm = |- inv (& 0) === & 0
0..0..1..4..8..solved at 17
0..0..1..4..solved at 10
0..0..3..6..solved at 10
0..0..3..8..15..solved at 20
0..0..3..12..23..40..63..solved at 72
0..0..3..6..18..34..61..94..145..206..solved at 249
0..0..3..14..36..111..307..901..solved at 935
val NADD_INV_WELLDEF : thm = |- !x y. x === y ==> inv x === inv y
val hreal_tybij : thm * thm =
  (|- mk_hreal (dest_hreal a) = a,
   |- (?x. r = (===) x) <=> dest_hreal (mk_hreal r) = r)
- : unit = ()
- : unit = ()
val hreal_of_num : thm = |- & m = mk_hreal (\u. nadd_of_num m === u)
val hreal_of_num_th : thm = |- mk_hreal ((===) (nadd_of_num m)) = & m
val hreal_add : thm =
  |- x + y =
     mk_hreal (\u. ?x y. x ++ y === u /\ dest_hreal x x /\ dest_hreal y y)
val hreal_add_th : thm =
  |- mk_hreal ((===) (x ++ y)) = mk_hreal ((===) x) + mk_hreal ((===) y)
val hreal_mul : thm =
  |- x * y =
     mk_hreal (\u. ?x y. x ** y === u /\ dest_hreal x x /\ dest_hreal y y)
val hreal_mul_th : thm =
  |- mk_hreal ((===) (x ** y)) = mk_hreal ((===) x) * mk_hreal ((===) y)
val hreal_le : thm =
  |- x <= y <=>
     (@u. ?x y. (x <<= y <=> u) /\ dest_hreal x x /\ dest_hreal y y)
val hreal_le_th : thm =
  |- x <<= y <=> mk_hreal ((===) x) <= mk_hreal ((===) y)
val hreal_inv : thm =
  |- inv x = mk_hreal (\u. ?x. nadd_inv x === u /\ dest_hreal x x)
val hreal_inv_th : thm =
  |- mk_hreal ((===) (nadd_inv x)) = inv (mk_hreal ((===) x))
val HREAL_COMPLETE : thm =
  |- !P. (?x. P x) /\ (?M. !x. P x ==> x <= M)
         ==> (?M. (!x. P x ==> x <= M) /\
                  (!M'. (!x. P x ==> x <= M') ==> M <= M'))
val HREAL_OF_NUM_EQ : thm = |- !m n. & m = & n <=> m = n
val HREAL_OF_NUM_LE : thm = |- !m n. & m <= & n <=> m <= n
val HREAL_OF_NUM_ADD : thm = |- !m n. & m + & n = & (m + n)
val HREAL_OF_NUM_MUL : thm = |- !m n. & m * & n = & (m * n)
val HREAL_LE_REFL : thm = |- !x. x <= x
val HREAL_LE_TRANS : thm = |- !x y z. x <= y /\ y <= z ==> x <= z
val HREAL_LE_ANTISYM : thm = |- !x y. x <= y /\ y <= x <=> x = y
val HREAL_LE_TOTAL : thm = |- !x y. x <= y \/ y <= x
val HREAL_LE_ADD : thm = |- !x y. x <= x + y
val HREAL_LE_EXISTS : thm = |- !x y. x <= y ==> (?d. y = x + d)
val HREAL_ARCH : thm = |- !x. ?n. x <= & n
val HREAL_ADD_SYM : thm = |- !x y. x + y = y + x
val HREAL_ADD_ASSOC : thm = |- !x y z. x + y + z = (x + y) + z
val HREAL_ADD_LID : thm = |- !x. & 0 + x = x
val HREAL_ADD_LCANCEL : thm = |- !x y z. x + y = x + z ==> y = z
val HREAL_MUL_SYM : thm = |- !x y. x * y = y * x
val HREAL_MUL_ASSOC : thm = |- !x y z. x * y * z = (x * y) * z
val HREAL_MUL_LID : thm = |- !x. & 1 * x = x
val HREAL_ADD_LDISTRIB : thm = |- !x y z. x * (y + z) = x * y + x * z
val HREAL_MUL_LINV : thm = |- !x. ~(x = & 0) ==> inv x * x = & 1
val HREAL_INV_0 : thm = |- inv (& 0) = & 0
val HREAL_LE_EXISTS_DEF : thm = |- !m n. m <= n <=> (?d. n = m + d)
val HREAL_EQ_ADD_LCANCEL : thm = |- !m n p. m + n = m + p <=> n = p
val HREAL_EQ_ADD_RCANCEL : thm = |- !m n p. m + p = n + p <=> m = n
val HREAL_LE_ADD_LCANCEL : thm = |- !m n p. m + n <= m + p <=> n <= p
val HREAL_LE_ADD_RCANCEL : thm = |- !m n p. m + p <= n + p <=> m <= n
val HREAL_ADD_RID : thm = |- !n. n + & 0 = n
val HREAL_ADD_RDISTRIB : thm = |- !m n p. (m + n) * p = m * p + n * p
val HREAL_MUL_LZERO : thm = |- !m. & 0 * m = & 0
val HREAL_MUL_RZERO : thm = |- !m. m * & 0 = & 0
val HREAL_ADD_AC : thm =
  |- m + n = n + m /\ (m + n) + p = m + n + p /\ m + n + p = n + m + p
val HREAL_LE_ADD2 : thm = |- !a b c d. a <= b /\ c <= d ==> a + c <= b + d
val HREAL_LE_MUL_RCANCEL_IMP : thm = |- !a b c. a <= b ==> a * c <= b * c
val treal_of_num : thm = |- !n. treal_of_num n = & n,& 0
val treal_neg : thm = |- !y x. treal_neg (x,y) = y,x
val treal_add : thm =
  |- !x1 x2 y1 y2. (x1,y1) treal_add (x2,y2) = x1 + x2,y1 + y2
val treal_mul : thm =
  |- !x1 y2 y1 x2.
         (x1,y1) treal_mul (x2,y2) = x1 * x2 + y1 * y2,x1 * y2 + y1 * x2
val treal_le : thm =
  |- !x1 y2 x2 y1. x1,y1 treal_le x2,y2 <=> x1 + y2 <= x2 + y1
val treal_inv : thm =
  |- !y x.
         treal_inv (x,y) =
         (if x = y
          then & 0,& 0
          else if y <= x
               then inv (@d. x = y + d),& 0
               else & 0,inv (@d. y = x + d))
val treal_eq : thm =
  |- !x1 y2 x2 y1. x1,y1 treal_eq x2,y2 <=> x1 + y2 = x2 + y1
val TREAL_EQ_REFL : thm = |- !x. x treal_eq x
val TREAL_EQ_SYM : thm = |- !x y. x treal_eq y <=> y treal_eq x
val TREAL_EQ_TRANS : thm =
  |- !x y z. x treal_eq y /\ y treal_eq z ==> x treal_eq z
val TREAL_EQ_AP : thm = |- !x y. x = y ==> x treal_eq y
val TREAL_OF_NUM_EQ : thm =
  |- !m n. treal_of_num m treal_eq treal_of_num n <=> m = n
val TREAL_OF_NUM_LE : thm =
  |- !m n. treal_of_num m treal_le treal_of_num n <=> m <= n
val TREAL_OF_NUM_ADD : thm =
  |- !m n.
         treal_of_num m treal_add treal_of_num n treal_eq
         treal_of_num (m + n)
val TREAL_OF_NUM_MUL : thm =
  |- !m n.
         treal_of_num m treal_mul treal_of_num n treal_eq
         treal_of_num (m * n)
val TREAL_ADD_SYM_EQ : thm = |- !x y. x treal_add y = y treal_add x
val TREAL_MUL_SYM_EQ : thm = |- !x y. x treal_mul y = y treal_mul x
val TREAL_ADD_SYM : thm = |- !x y. x treal_add y treal_eq y treal_add x
val TREAL_ADD_ASSOC : thm =
  |- !x y z. x treal_add y treal_add z treal_eq (x treal_add y) treal_add z
val TREAL_ADD_LID : thm = |- !x. treal_of_num 0 treal_add x treal_eq x
val TREAL_ADD_LINV : thm =
  |- !x. treal_neg x treal_add x treal_eq treal_of_num 0
val TREAL_MUL_SYM : thm = |- !x y. x treal_mul y treal_eq y treal_mul x
val TREAL_MUL_ASSOC : thm =
  |- !x y z. x treal_mul y treal_mul z treal_eq (x treal_mul y) treal_mul z
val TREAL_MUL_LID : thm = |- !x. treal_of_num 1 treal_mul x treal_eq x
val TREAL_ADD_LDISTRIB : thm =
  |- !x y z.
         x treal_mul (y treal_add z) treal_eq
         x treal_mul y treal_add x treal_mul z
val TREAL_LE_REFL : thm = |- !x. x treal_le x
val TREAL_LE_ANTISYM : thm =
  |- !x y. x treal_le y /\ y treal_le x <=> x treal_eq y
val TREAL_LE_TRANS : thm =
  |- !x y z. x treal_le y /\ y treal_le z ==> x treal_le z
val TREAL_LE_TOTAL : thm = |- !x y. x treal_le y \/ y treal_le x
val TREAL_LE_LADD_IMP : thm =
  |- !x y z. y treal_le z ==> x treal_add y treal_le x treal_add z
val TREAL_LE_MUL : thm =
  |- !x y.
         treal_of_num 0 treal_le x /\ treal_of_num 0 treal_le y
         ==> treal_of_num 0 treal_le x treal_mul y
val TREAL_INV_0 : thm = |- treal_inv (treal_of_num 0) treal_eq treal_of_num 0
val TREAL_MUL_LINV : thm =
  |- !x. ~(x treal_eq treal_of_num 0)
         ==> treal_inv x treal_mul x treal_eq treal_of_num 1
val TREAL_OF_NUM_WELLDEF : thm =
  |- !m n. m = n ==> treal_of_num m treal_eq treal_of_num n
val TREAL_NEG_WELLDEF : thm =
  |- !x1 x2. x1 treal_eq x2 ==> treal_neg x1 treal_eq treal_neg x2
val TREAL_ADD_WELLDEFR : thm =
  |- !x1 x2 y. x1 treal_eq x2 ==> x1 treal_add y treal_eq x2 treal_add y
val TREAL_ADD_WELLDEF : thm =
  |- !x1 x2 y1 y2.
         x1 treal_eq x2 /\ y1 treal_eq y2
         ==> x1 treal_add y1 treal_eq x2 treal_add y2
val TREAL_MUL_WELLDEFR : thm =
  |- !x1 x2 y. x1 treal_eq x2 ==> x1 treal_mul y treal_eq x2 treal_mul y
val TREAL_MUL_WELLDEF : thm =
  |- !x1 x2 y1 y2.
         x1 treal_eq x2 /\ y1 treal_eq y2
         ==> x1 treal_mul y1 treal_eq x2 treal_mul y2
val TREAL_EQ_IMP_LE : thm = |- !x y. x treal_eq y ==> x treal_le y
val TREAL_LE_WELLDEF : thm =
  |- !x1 x2 y1 y2.
         x1 treal_eq x2 /\ y1 treal_eq y2
         ==> (x1 treal_le y1 <=> x2 treal_le y2)
val TREAL_INV_WELLDEF : thm =
  |- !x y. x treal_eq y ==> treal_inv x treal_eq treal_inv y
val real_tybij : thm * thm =
  (|- mk_real (dest_real a) = a,
   |- (?x. r = (treal_eq) x) <=> dest_real (mk_real r) = r)
val real_of_num : thm =
  |- real_of_numm = mk_real (\u. treal_of_num m treal_eq u)
val real_of_num_th : thm =
  |- mk_real ((treal_eq) (treal_of_num m)) = real_of_numm
val real_neg : thm =
  |- real_neg x1 =
     mk_real (\u. ?x1. treal_neg x1 treal_eq u /\ dest_real x1 x1)
val real_neg_th : thm =
  |- mk_real ((treal_eq) (treal_neg x1)) = real_neg (mk_real ((treal_eq) x1))
val real_add : thm =
  |- real_add x1 y1 =
     mk_real
     (\u. ?x1 y1.
              x1 treal_add y1 treal_eq u /\
              dest_real x1 x1 /\
              dest_real y1 y1)
val real_add_th : thm =
  |- mk_real ((treal_eq) (x1 treal_add y1)) =
     real_add (mk_real ((treal_eq) x1)) (mk_real ((treal_eq) y1))
val real_mul : thm =
  |- real_mul x1 y1 =
     mk_real
     (\u. ?x1 y1.
              x1 treal_mul y1 treal_eq u /\
              dest_real x1 x1 /\
              dest_real y1 y1)
val real_mul_th : thm =
  |- mk_real ((treal_eq) (x1 treal_mul y1)) =
     real_mul (mk_real ((treal_eq) x1)) (mk_real ((treal_eq) y1))
val real_le : thm =
  |- real_le x1 y1 <=>
     (@u. ?x1 y1.
              (x1 treal_le y1 <=> u) /\ dest_real x1 x1 /\ dest_real y1 y1)
val real_le_th : thm =
  |- x1 treal_le y1 <=>
     real_le (mk_real ((treal_eq) x1)) (mk_real ((treal_eq) y1))
val real_inv : thm =
  |- real_inv x = mk_real (\u. ?x. treal_inv x treal_eq u /\ dest_real x x)
val real_inv_th : thm =
  |- mk_real ((treal_eq) (treal_inv x)) = real_inv (mk_real ((treal_eq) x))
val REAL_ADD_SYM : thm = |- !x y. real_add x y = real_add y x
val REAL_ADD_ASSOC : thm =
  |- !x y z. real_add x (real_add y z) = real_add (real_add x y) z
val REAL_ADD_LID : thm = |- !x. real_add (real_of_num0) x = x
val REAL_ADD_LINV : thm = |- !x. real_add (real_neg x) x = real_of_num0
val REAL_MUL_SYM : thm = |- !x y. real_mul x y = real_mul y x
val REAL_MUL_ASSOC : thm =
  |- !x y z. real_mul x (real_mul y z) = real_mul (real_mul x y) z
val REAL_MUL_LID : thm = |- !x. real_mul (real_of_num1) x = x
val REAL_ADD_LDISTRIB : thm =
  |- !x y z.
         real_mul x (real_add y z) = real_add (real_mul x y) (real_mul x z)
val REAL_LE_REFL : thm = |- !x. real_le x x
val REAL_LE_ANTISYM : thm = |- !x y. real_le x y /\ real_le y x <=> x = y
val REAL_LE_TRANS : thm =
  |- !x y z. real_le x y /\ real_le y z ==> real_le x z
val REAL_LE_TOTAL : thm = |- !x y. real_le x y \/ real_le y x
val REAL_LE_LADD_IMP : thm =
  |- !x y z. real_le y z ==> real_le (real_add x y) (real_add x z)
val REAL_LE_MUL : thm =
  |- !x y.
         real_le (real_of_num0) x /\ real_le (real_of_num0) y
         ==> real_le (real_of_num0) (real_mul x y)
val REAL_INV_0 : thm = |- real_inv (real_of_num0) = real_of_num0
val REAL_MUL_LINV : thm =
  |- !x. ~(x = real_of_num0) ==> real_mul (real_inv x) x = real_of_num1
val REAL_OF_NUM_EQ : thm = |- !m n. real_of_numm = real_of_numn <=> m = n
val REAL_OF_NUM_LE : thm =
  |- !m n. real_le (real_of_numm) (real_of_numn) <=> m <= n
val REAL_OF_NUM_ADD : thm =
  |- !m n. real_add (real_of_numm) (real_of_numn) = real_of_num(m + n)
val REAL_OF_NUM_MUL : thm =
  |- !m n. real_mul (real_of_numm) (real_of_numn) = real_of_num(m * n)
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val prioritize_real : unit -> unit = <fun>
val real_sub : thm = |- !x y. x - y = x + --y
val real_lt : thm = |- !y x. x < y <=> ~(y <= x)
val real_ge : thm = |- !y x. x >= y <=> y <= x
val real_gt : thm = |- !y x. x > y <=> y < x
val real_abs : thm = |- !x. abs x = (if &0 <= x then x else --x)
val real_pow : thm = |- x pow 0 = &1 /\ (!n. x pow SUC n = x * x pow n)
val real_div : thm = |- !x y. x / y = x * inv y
val real_max : thm = |- !n m. max m n = (if m <= n then n else m)
val real_min : thm = |- !m n. min m n = (if m <= n then m else n)
val REAL_HREAL_LEMMA1 : thm =
  |- ?r. (!x. &0 <= x <=> (?y. x = r y)) /\ (!y z. y <= z <=> r y <= r z)
val REAL_HREAL_LEMMA2 : thm =
  |- ?h r.
         (!x. h (r x) = x) /\
         (!x. &0 <= x ==> r (h x) = x) /\
         (!x. &0 <= r x) /\
         (!x y. x <= y <=> r x <= r y)
val REAL_COMPLETE_SOMEPOS : thm =
  |- !P. (?x. P x /\ &0 <= x) /\ (?M. !x. P x ==> x <= M)
         ==> (?M. (!x. P x ==> x <= M) /\
                  (!M'. (!x. P x ==> x <= M') ==> M <= M'))
val REAL_COMPLETE : thm =
  |- !P. (?x. P x) /\ (?M. !x. P x ==> x <= M)
         ==> (?M. (!x. P x ==> x <= M) /\
                  (!M'. (!x. P x ==> x <= M') ==> M <= M'))
- : unit = ()
- : unit = ()
- : unit = ()
File "realax.ml" already loaded
- : unit = ()
val is_realintconst : term -> bool = <fun>
val dest_realintconst : term -> num = <fun>
val mk_realintconst : num -> term = <fun>
val is_ratconst : term -> bool = <fun>
val rat_of_term : term -> num = <fun>
val term_of_rat : num -> term = <fun>
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..2..7..14..35..62..solved at 73
val REAL_ADD_AC : thm =
  |- m + n = n + m /\ (m + n) + p = m + n + p /\ m + n + p = n + m + p
0..0..1..2..solved at 6
val REAL_ADD_RINV : thm = |- !x. x + --x = &0
val REAL_EQ_ADD_LCANCEL : thm = |- !x y z. x + y = x + z <=> y = z
0..0..1..3..8..19..44..solved at 81
0..0..solved at 2
val REAL_EQ_ADD_RCANCEL : thm = |- !x y z. x + z = y + z <=> x = y
0..0..1..3..9..25..64..166..437..1159..3190..solved at 4411
val REAL_MUL_RZERO : thm = |- !x. x * &0 = &0
0..0..1..2..solved at 6
val REAL_MUL_LZERO : thm = |- !x. &0 * x = &0
0..0..1..3..8..19..44..112..275..694..solved at 932
val REAL_NEG_NEG : thm = |- !x. -- --x = x
0..0..1..3..8..19..40..85..174..348..696..1556..3482..solved at 6840
val REAL_MUL_RNEG : thm = |- !x y. x * --y = --(x * y)
0..0..1..2..6..12..28..solved at 55
val REAL_MUL_LNEG : thm = |- !x y. --x * y = --(x * y)
val REAL_NEG_ADD : thm = |- !x y. --(x + y) = --x + --y
0..0..1..2..solved at 6
val REAL_ADD_RID : thm = |- !x. x + &0 = x
0..0..1..2..solved at 6
val REAL_NEG_0 : thm = |- -- &0 = &0
val REAL_LE_LNEG : thm = |- !x y. --x <= y <=> &0 <= x + y
val REAL_LE_NEG2 : thm = |- !x y. --x <= --y <=> y <= x
val REAL_LE_RNEG : thm = |- !x y. x <= --y <=> x + y <= &0
val REAL_OF_NUM_POW : thm = |- !x n. &x pow n = &(x EXP n)
val REAL_POW_NEG : thm =
  |- !x n. --x pow n = (if EVEN n then x pow n else --(x pow n))
val REAL_ABS_NUM : thm = |- !n. abs (&n) = &n
0..0..1..2..6..11..19..36..53..76..121..solved at 164
0..0..3..solved at 9
val REAL_ABS_NEG : thm = |- !x. abs (--x) = abs x
val REAL_INT_LE_CONV : conv = <fun>
val REAL_INT_LT_CONV : conv = <fun>
val REAL_INT_GE_CONV : conv = <fun>
val REAL_INT_GT_CONV : conv = <fun>
val REAL_INT_EQ_CONV : conv = <fun>
val REAL_INT_NEG_CONV : conv = <fun>
val REAL_INT_MUL_CONV : conv = <fun>
val REAL_INT_ADD_CONV : conv = <fun>
val REAL_INT_SUB_CONV : conv = <fun>
val REAL_INT_POW_CONV : conv = <fun>
val REAL_INT_ABS_CONV : conv = <fun>
val REAL_INT_RED_CONV : term -> thm = <fun>
val REAL_INT_REDUCE_CONV : conv = <fun>
- : unit = ()
File "calc_int.ml" already loaded
- : unit = ()
val REAL_LTE_TOTAL : thm = |- !x y. x < y \/ y <= x
val REAL_LET_TOTAL : thm = |- !x y. x <= y \/ y < x
0..0..1..7..solved at 12
val REAL_LT_IMP_LE : thm = |- !x y. x < y ==> x <= y
0..0..1..5..12..24..solved at 30
val REAL_LTE_TRANS : thm = |- !x y z. x < y /\ y <= z ==> x < z
0..0..1..5..12..23..solved at 30
val REAL_LET_TRANS : thm = |- !x y z. x <= y /\ y < z ==> x < z
0..0..1..2..5..solved at 10
val REAL_LT_TRANS : thm = |- !x y z. x < y /\ y < z ==> x < z
0..0..1..2..6..17..34..81..solved at 102
val REAL_LE_ADD : thm = |- !x y. &0 <= x /\ &0 <= y ==> &0 <= x + y
0..0..0..solved at 3
val REAL_LTE_ANTISYM : thm = |- !x y. ~(x < y /\ y <= x)
val REAL_SUB_LE : thm = |- !x y. &0 <= x - y <=> y <= x
val REAL_NEG_SUB : thm = |- !x y. --(x - y) = y - x
0..0..1..2..solved at 6
0..0..2..solved at 7
0..0..1..solved at 4
val REAL_LE_LT : thm = |- !x y. x <= y <=> x < y \/ x = y
val REAL_SUB_LT : thm = |- !x y. &0 < x - y <=> y < x
val REAL_NOT_LT : thm = |- !x y. ~(x < y) <=> y <= x
val REAL_SUB_0 : thm = |- !x y. x - y = &0 <=> x = y
0..0..1..9..solved at 16
0..0..0..2..solved at 6
0..0..2..6..16..solved at 22
val REAL_LT_LE : thm = |- !x y. x < y <=> x <= y /\ ~(x = y)
val REAL_LT_REFL : thm = |- !x. ~(x < x)
0..0..1..2..5..15..28..59..solved at 68
val REAL_LTE_ADD : thm = |- !x y. &0 < x /\ &0 <= y ==> &0 < x + y
0..0..1..2..4..10..19..solved at 27
val REAL_LET_ADD : thm = |- !x y. &0 <= x /\ &0 < y ==> &0 < x + y
0..0..1..2..5..solved at 10
val REAL_LT_ADD : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x + y
val REAL_ENTIRE : thm = |- !x y. x * y = &0 <=> x = &0 \/ y = &0
val REAL_LE_NEGTOTAL : thm = |- !x. &0 <= x \/ &0 <= --x
val REAL_LE_SQUARE : thm = |- !x. &0 <= x * x
0..0..1..2..solved at 7
val REAL_MUL_RID : thm = |- !x. x * &1 = x
val REAL_POW_2 : thm = |- !x. x pow 2 = x * x
val REAL_POLY_CLAUSES : thm =
  |- (!x y z. x + y + z = (x + y) + z) /\
     (!x y. x + y = y + x) /\
     (!x. &0 + x = x) /\
     (!x y z. x * y * z = (x * y) * z) /\
     (!x y. x * y = y * x) /\
     (!x. &1 * x = x) /\
     (!x. &0 * x = &0) /\
     (!x y z. x * (y + z) = x * y + x * z) /\
     (!x. x pow 0 = &1) /\
     (!x n. x pow SUC n = x * x pow n)
val REAL_POLY_NEG_CLAUSES : thm =
  |- (!x. --x = -- &1 * x) /\ (!x y. x - y = x + -- &1 * y)
val REAL_POS : thm = |- !n. &0 <= &n
type positivstellensatz =
    Axiom_eq of int
  | Axiom_le of int
  | Axiom_lt of int
  | Rational_eq of num
  | Rational_le of num
  | Rational_lt of num
  | Square of term
  | Eqmul of term * positivstellensatz
  | Sum of positivstellensatz * positivstellensatz
  | Product of positivstellensatz * positivstellensatz
0..0..1..2..solved at 6
0..0..1..solved at 4
0..0..1..solved at 4
0..0..2..4..solved at 13
0..0..2..4..11..32..75..solved at 142
0..0..2..4..12..33..75..solved at 143
0..0..2..4..solved at 8
0..0..1..2..solved at 6
0..0..1..2..4..17..34..solved at 61
0..0..1..2..solved at 6
0..0..1..2..5..18..35..solved at 63
0..0..1..2..solved at 6
0..0..2..4..10..18..34..76..138..336..872..2366..solved at 5076
val GEN_REAL_ARITH :
  (num -> term) * conv * conv * conv * conv * conv * conv * conv * conv *
  conv *
  ((thm list * thm list * thm list -> positivstellensatz -> thm) ->
   thm list * thm list * thm list -> thm) ->
  term -> thm = <fun>
val REAL_LINEAR_PROVER :
  (thm list * thm list * thm list -> positivstellensatz -> '_a) ->
  thm list * thm list * thm list -> '_a = <fun>
val REAL_ARITH : term -> thm = <fun>
CPU time (user): 0.867048
val GEN_REAL_ARITH :
  (num -> term) * conv * conv * conv * conv * conv * conv * conv *
  ((thm list * thm list * thm list -> positivstellensatz -> thm) ->
   thm list * thm list * thm list -> thm) ->
  term -> thm = <fun>
val REAL_ARITH : term -> thm = <fun>
- : unit = ()
File "realarith.ml" already loaded
- : unit = ()
val REAL_OF_NUM_LT : thm = |- !m n. &m < &n <=> m < n
val REAL_OF_NUM_GE : thm = |- !m n. &m >= &n <=> m >= n
val REAL_OF_NUM_GT : thm = |- !m n. &m > &n <=> m > n
val REAL_OF_NUM_MAX : thm = |- !m n. max (&m) (&n) = &(MAX m n)
val REAL_OF_NUM_MIN : thm = |- !m n. min (&m) (&n) = &(MIN m n)
val REAL_OF_NUM_SUC : thm = |- !n. &n + &1 = &(SUC n)
0..0..1..2..7..14..37..72..174..325..solved at 392
val REAL_OF_NUM_SUB : thm = |- !m n. m <= n ==> &n - &m = &(n - m)
0..0..2..solved at 5
val REAL_OF_NUM_SUB_CASES : thm =
  |- !m n. &m - &n = (if n <= m then &(m - n) else -- &(n - m))
val REAL_MUL_AC : thm =
  |- m * n = n * m /\ (m * n) * p = m * n * p /\ m * n * p = n * m * p
0..0..1..2..6..11..21..34..52..73..solved at 103
val REAL_ADD_RDISTRIB : thm = |- !x y z. (x + y) * z = x * z + y * z
val REAL_LT_LADD_IMP : thm = |- !x y z. y < z ==> x + y < x + z
val REAL_LT_MUL : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x * y
val REAL_ARITH_TAC : tactic = <fun>
val REAL_EQ_ADD_LCANCEL_0 : thm = |- !x y. x + y = x <=> y = &0
val REAL_EQ_ADD_RCANCEL_0 : thm = |- !x y. x + y = y <=> x = &0
val REAL_LNEG_UNIQ : thm = |- !x y. x + y = &0 <=> x = --y
val REAL_RNEG_UNIQ : thm = |- !x y. x + y = &0 <=> y = --x
val REAL_NEG_LMUL : thm = |- !x y. --(x * y) = --x * y
val REAL_NEG_RMUL : thm = |- !x y. --(x * y) = x * --y
val REAL_NEGNEG : thm = |- !x. -- --x = x
val REAL_NEG_MUL2 : thm = |- !x y. --x * --y = x * y
val REAL_LT_LADD : thm = |- !x y z. x + y < x + z <=> y < z
val REAL_LT_RADD : thm = |- !x y z. x + z < y + z <=> x < y
val REAL_LT_ANTISYM : thm = |- !x y. ~(x < y /\ y < x)
val REAL_LT_GT : thm = |- !x y. x < y ==> ~(y < x)
val REAL_NOT_EQ : thm = |- !x y. ~(x = y) <=> x < y \/ y < x
val REAL_NOT_LE : thm = |- !x y. ~(x <= y) <=> y < x
val REAL_LET_ANTISYM : thm = |- !x y. ~(x <= y /\ y < x)
val REAL_NEG_LT0 : thm = |- !x. --x < &0 <=> &0 < x
val REAL_NEG_GT0 : thm = |- !x. &0 < --x <=> x < &0
val REAL_NEG_LE0 : thm = |- !x. --x <= &0 <=> &0 <= x
val REAL_NEG_GE0 : thm = |- !x. &0 <= --x <=> x <= &0
val REAL_LT_TOTAL : thm = |- !x y. x = y \/ x < y \/ y < x
val REAL_LT_NEGTOTAL : thm = |- !x. x = &0 \/ &0 < x \/ &0 < --x
val REAL_LE_01 : thm = |- &0 <= &1
val REAL_LT_01 : thm = |- &0 < &1
val REAL_LE_LADD : thm = |- !x y z. x + y <= x + z <=> y <= z
val REAL_LE_RADD : thm = |- !x y z. x + z <= y + z <=> x <= y
val REAL_LT_ADD2 : thm = |- !w x y z. w < x /\ y < z ==> w + y < x + z
val REAL_LE_ADD2 : thm = |- !w x y z. w <= x /\ y <= z ==> w + y <= x + z
val REAL_LT_LNEG : thm = |- !x y. --x < y <=> &0 < x + y
val REAL_LT_RNEG : thm = |- !x y. x < --y <=> x + y < &0
val REAL_LT_ADDNEG : thm = |- !x y z. y < x + --z <=> y + z < x
val REAL_LT_ADDNEG2 : thm = |- !x y z. x + --y < z <=> x < z + y
val REAL_LT_ADD1 : thm = |- !x y. x <= y ==> x < y + &1
val REAL_SUB_ADD : thm = |- !x y. x - y + y = x
val REAL_SUB_ADD2 : thm = |- !x y. y + x - y = x
val REAL_SUB_REFL : thm = |- !x. x - x = &0
val REAL_LE_DOUBLE : thm = |- !x. &0 <= x + x <=> &0 <= x
val REAL_LE_NEGL : thm = |- !x. --x <= x <=> &0 <= x
val REAL_LE_NEGR : thm = |- !x. x <= --x <=> x <= &0
val REAL_NEG_EQ_0 : thm = |- !x. --x = &0 <=> x = &0
val REAL_ADD_SUB : thm = |- !x y. (x + y) - x = y
val REAL_NEG_EQ : thm = |- !x y. --x = y <=> x = --y
val REAL_NEG_MINUS1 : thm = |- !x. --x = -- &1 * x
val REAL_LT_IMP_NE : thm = |- !x y. x < y ==> ~(x = y)
val REAL_LE_ADDR : thm = |- !x y. x <= x + y <=> &0 <= y
val REAL_LE_ADDL : thm = |- !x y. y <= x + y <=> &0 <= x
val REAL_LT_ADDR : thm = |- !x y. x < x + y <=> &0 < y
val REAL_LT_ADDL : thm = |- !x y. y < x + y <=> &0 < x
val REAL_SUB_SUB : thm = |- !x y. x - y - x = --y
val REAL_LT_ADD_SUB : thm = |- !x y z. x + y < z <=> x < z - y
val REAL_LT_SUB_RADD : thm = |- !x y z. x - y < z <=> x < z + y
val REAL_LT_SUB_LADD : thm = |- !x y z. x < y - z <=> x + z < y
val REAL_LE_SUB_LADD : thm = |- !x y z. x <= y - z <=> x + z <= y
val REAL_LE_SUB_RADD : thm = |- !x y z. x - y <= z <=> x <= z + y
val REAL_LT_NEG : thm = |- !x y. --x < --y <=> y < x
val REAL_LE_NEG : thm = |- !x y. --x <= --y <=> y <= x
val REAL_ADD2_SUB2 : thm = |- !a b c d. (a + b) - (c + d) = a - c + b - d
val REAL_SUB_LZERO : thm = |- !x. &0 - x = --x
val REAL_SUB_RZERO : thm = |- !x. x - &0 = x
val REAL_LET_ADD2 : thm = |- !w x y z. w <= x /\ y < z ==> w + y < x + z
val REAL_LTE_ADD2 : thm = |- !w x y z. w < x /\ y <= z ==> w + y < x + z
val REAL_SUB_LNEG : thm = |- !x y. --x - y = --(x + y)
val REAL_SUB_RNEG : thm = |- !x y. x - --y = x + y
val REAL_SUB_NEG2 : thm = |- !x y. --x - --y = y - x
val REAL_SUB_TRIANGLE : thm = |- !a b c. a - b + b - c = a - c
val REAL_EQ_SUB_LADD : thm = |- !x y z. x = y - z <=> x + z = y
val REAL_EQ_SUB_RADD : thm = |- !x y z. x - y = z <=> x = z + y
val REAL_SUB_SUB2 : thm = |- !x y. x - (x - y) = y
val REAL_ADD_SUB2 : thm = |- !x y. x - (x + y) = --y
val REAL_EQ_IMP_LE : thm = |- !x y. x = y ==> x <= y
val REAL_POS_NZ : thm = |- !x. &0 < x ==> ~(x = &0)
val REAL_DIFFSQ : thm = |- !x y. (x + y) * (x - y) = x * x - y * y
val REAL_EQ_NEG2 : thm = |- !x y. --x = --y <=> x = y
val REAL_LT_NEG2 : thm = |- !x y. --x < --y <=> y < x
val REAL_SUB_LDISTRIB : thm = |- !x y z. x * (y - z) = x * y - x * z
val REAL_SUB_RDISTRIB : thm = |- !x y z. (x - y) * z = x * z - y * z
val REAL_ABS_ZERO : thm = |- !x. abs x = &0 <=> x = &0
val REAL_ABS_0 : thm = |- abs (&0) = &0
val REAL_ABS_1 : thm = |- abs (&1) = &1
val REAL_ABS_TRIANGLE : thm = |- !x y. abs (x + y) <= abs x + abs y
val REAL_ABS_TRIANGLE_LE : thm =
  |- !x y z. abs x + abs (y - x) <= z ==> abs y <= z
val REAL_ABS_TRIANGLE_LT : thm =
  |- !x y z. abs x + abs (y - x) < z ==> abs y < z
val REAL_ABS_POS : thm = |- !x. &0 <= abs x
val REAL_ABS_SUB : thm = |- !x y. abs (x - y) = abs (y - x)
val REAL_ABS_NZ : thm = |- !x. ~(x = &0) <=> &0 < abs x
val REAL_ABS_ABS : thm = |- !x. abs (abs x) = abs x
val REAL_ABS_LE : thm = |- !x. x <= abs x
val REAL_ABS_REFL : thm = |- !x. abs x = x <=> &0 <= x
val REAL_ABS_BETWEEN : thm =
  |- !x y d. &0 < d /\ x - d < y /\ y < x + d <=> abs (y - x) < d
val REAL_ABS_BOUND : thm = |- !x y d. abs (x - y) < d ==> y < x + d
val REAL_ABS_STILLNZ : thm = |- !x y. abs (x - y) < abs y ==> ~(x = &0)
val REAL_ABS_CASES : thm = |- !x. x = &0 \/ &0 < abs x
val REAL_ABS_BETWEEN1 : thm =
  |- !x y z. x < z /\ abs (y - x) < z - x ==> y < z
val REAL_ABS_SIGN : thm = |- !x y. abs (x - y) < y ==> &0 < x
val REAL_ABS_SIGN2 : thm = |- !x y. abs (x - y) < --y ==> x < &0
val REAL_ABS_CIRCLE : thm =
  |- !x y h. abs h < abs y - abs x ==> abs (x + h) < abs y
val REAL_SUB_ABS : thm = |- !x y. abs x - abs y <= abs (x - y)
val REAL_ABS_SUB_ABS : thm = |- !x y. abs (abs x - abs y) <= abs (x - y)
val REAL_ABS_BETWEEN2 : thm =
  |- !x0 x y0 y.
         x0 < y0 /\
         &2 * abs (x - x0) < y0 - x0 /\
         &2 * abs (y - y0) < y0 - x0
         ==> x < y
val REAL_ABS_BOUNDS : thm = |- !x k. abs x <= k <=> --k <= x /\ x <= k
val REAL_BOUNDS_LE : thm = |- !x k. --k <= x /\ x <= k <=> abs x <= k
val REAL_BOUNDS_LT : thm = |- !x k. --k < x /\ x < k <=> abs x < k
val REAL_MIN_MAX : thm = |- !x y. min x y = --max (--x) (--y)
val REAL_MAX_MIN : thm = |- !x y. max x y = --min (--x) (--y)
val REAL_MAX_MAX : thm = |- !x y. x <= max x y /\ y <= max x y
val REAL_MIN_MIN : thm = |- !x y. min x y <= x /\ min x y <= y
val REAL_MAX_SYM : thm = |- !x y. max x y = max y x
val REAL_MIN_SYM : thm = |- !x y. min x y = min y x
val REAL_LE_MAX : thm = |- !x y z. z <= max x y <=> z <= x \/ z <= y
val REAL_LE_MIN : thm = |- !x y z. z <= min x y <=> z <= x /\ z <= y
val REAL_LT_MAX : thm = |- !x y z. z < max x y <=> z < x \/ z < y
val REAL_LT_MIN : thm = |- !x y z. z < min x y <=> z < x /\ z < y
val REAL_MAX_LE : thm = |- !x y z. max x y <= z <=> x <= z /\ y <= z
val REAL_MIN_LE : thm = |- !x y z. min x y <= z <=> x <= z \/ y <= z
val REAL_MAX_LT : thm = |- !x y z. max x y < z <=> x < z /\ y < z
val REAL_MIN_LT : thm = |- !x y z. min x y < z <=> x < z \/ y < z
val REAL_MAX_ASSOC : thm = |- !x y z. max x (max y z) = max (max x y) z
val REAL_MIN_ASSOC : thm = |- !x y z. min x (min y z) = min (min x y) z
val REAL_MAX_ACI : thm =
  |- max x y = max y x /\
     max (max x y) z = max x (max y z) /\
     max x (max y z) = max y (max x z) /\
     max x x = x /\
     max x (max x y) = max x y
val REAL_MIN_ACI : thm =
  |- min x y = min y x /\
     min (min x y) z = min x (min y z) /\
     min x (min y z) = min y (min x z) /\
     min x x = x /\
     min x (min x y) = min x y
val REAL_LE_IMP : thm -> thm = <fun>
val REAL_LET_IMP : thm -> thm = <fun>
val REAL_ABS_MUL : thm = |- !x y. abs (x * y) = abs x * abs y
val REAL_POW_LE : thm = |- !x n. &0 <= x ==> &0 <= x pow n
val REAL_POW_LT : thm = |- !x n. &0 < x ==> &0 < x pow n
val REAL_ABS_POW : thm = |- !x n. abs (x pow n) = abs x pow n
val REAL_LE_LMUL : thm = |- !x y z. &0 <= x /\ y <= z ==> x * y <= x * z
0..0..1..2..3..11..21..solved at 28
val REAL_LE_RMUL : thm = |- !x y z. x <= y /\ &0 <= z ==> x * z <= y * z
val REAL_LT_LMUL : thm = |- !x y z. &0 < x /\ y < z ==> x * y < x * z
0..0..1..2..3..11..21..solved at 28
val REAL_LT_RMUL : thm = |- !x y z. x < y /\ &0 < z ==> x * z < y * z
val REAL_EQ_MUL_LCANCEL : thm = |- !x y z. x * y = x * z <=> x = &0 \/ y = z
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
val REAL_EQ_MUL_RCANCEL : thm = |- !x y z. x * z = y * z <=> x = y \/ z = &0
val REAL_MUL_LINV_UNIQ : thm = |- !x y. x * y = &1 ==> inv y = x
val REAL_MUL_RINV_UNIQ : thm = |- !x y. x * y = &1 ==> inv x = y
val REAL_INV_INV : thm = |- !x. inv (inv x) = x
0..0..1..2..6..12..27..solved at 44
0..0..solved at 2
val REAL_EQ_INV2 : thm = |- !x y. inv x = inv y <=> x = y
val REAL_INV_EQ_0 : thm = |- !x. inv x = &0 <=> x = &0
val REAL_LT_INV : thm = |- !x. &0 < x ==> &0 < inv x
val REAL_LT_INV_EQ : thm = |- !x. &0 < inv x <=> &0 < x
val REAL_INV_NEG : thm = |- !x. inv (--x) = --inv x
0..0..solved at 3
0..0..2..4..8..17..30..solved at 47
0..0..solved at 3
0..0..2..4..8..solved at 15
val REAL_LE_INV_EQ : thm = |- !x. &0 <= inv x <=> &0 <= x
val REAL_LE_INV : thm = |- !x. &0 <= x ==> &0 <= inv x
val REAL_MUL_RINV : thm = |- !x. ~(x = &0) ==> x * inv x = &1
val REAL_INV_1 : thm = |- inv (&1) = &1
0..0..1..2..6..14..39..solved at 73
0..0..solved at 2
val REAL_INV_EQ_1 : thm = |- !x. inv x = &1 <=> x = &1
val REAL_DIV_1 : thm = |- !x. x / &1 = x
val REAL_DIV_REFL : thm = |- !x. ~(x = &0) ==> x / x = &1
val REAL_DIV_RMUL : thm = |- !x y. ~(y = &0) ==> x / y * y = x
val REAL_DIV_LMUL : thm = |- !x y. ~(y = &0) ==> y * x / y = x
val REAL_ABS_INV : thm = |- !x. abs (inv x) = inv (abs x)
val REAL_ABS_DIV : thm = |- !x y. abs (x / y) = abs x / abs y
val REAL_INV_MUL : thm = |- !x y. inv (x * y) = inv x * inv y
val REAL_INV_DIV : thm = |- !x y. inv (x / y) = y / x
val REAL_POW_MUL : thm = |- !x y n. (x * y) pow n = x pow n * y pow n
val REAL_POW_INV : thm = |- !x n. inv x pow n = inv (x pow n)
val REAL_INV_POW : thm = |- !x n. inv (x pow n) = inv x pow n
val REAL_POW_DIV : thm = |- !x y n. (x / y) pow n = x pow n / y pow n
val REAL_DIV_EQ_0 : thm = |- !x y. x / y = &0 <=> x = &0 \/ y = &0
val REAL_POW_ADD : thm = |- !x m n. x pow (m + n) = x pow m * x pow n
0..0..solved at 2
0..0..2..4..solved at 8
val REAL_POW_NZ : thm = |- !x n. ~(x = &0) ==> ~(x pow n = &0)
val REAL_POW_SUB : thm =
  |- !x m n. ~(x = &0) /\ m <= n ==> x pow (n - m) = x pow n / x pow m
val REAL_LT_IMP_NZ : thm = |- !x. &0 < x ==> ~(x = &0)
val REAL_LT_LCANCEL_IMP : thm = |- !x y z. &0 < x /\ x * y < x * z ==> y < z
val REAL_LT_RCANCEL_IMP : thm = |- !x y z. &0 < z /\ x * z < y * z ==> x < y
val REAL_LE_LCANCEL_IMP : thm =
  |- !x y z. &0 < x /\ x * y <= x * z ==> y <= z
val REAL_LE_RCANCEL_IMP : thm =
  |- !x y z. &0 < z /\ x * z <= y * z ==> x <= y
0..0..1..3..solved at 8
0..0..1..3..9..solved at 15
val REAL_LE_RMUL_EQ : thm = |- !x y z. &0 < z ==> (x * z <= y * z <=> x <= y)
0..0..1..2..5..11..20..solved at 29
0..0..1..2..5..15..29..solved at 49
val REAL_LE_LMUL_EQ : thm = |- !x y z. &0 < z ==> (z * x <= z * y <=> x <= y)
val REAL_LT_RMUL_EQ : thm = |- !x y z. &0 < z ==> (x * z < y * z <=> x < y)
val REAL_LT_LMUL_EQ : thm = |- !x y z. &0 < z ==> (z * x < z * y <=> x < y)
0..0..1..2..7..19..41..79..146..solved at 200
0..0..1..2..7..19..41..solved at 77
0..0..1..2..7..19..41..79..146..solved at 175
0..0..1..2..7..19..41..solved at 68
val REAL_LE_MUL_EQ : thm =
  |- (!x y. &0 < x ==> (&0 <= x * y <=> &0 <= y)) /\
     (!x y. &0 < y ==> (&0 <= x * y <=> &0 <= x))
0..0..1..2..9..23..64..133..315..solved at 511
0..0..1..2..9..23..64..solved at 116
0..0..1..2..9..23..64..133..315..solved at 415
0..0..1..2..9..23..64..solved at 116
val REAL_LT_MUL_EQ : thm =
  |- (!x y. &0 < x ==> (&0 < x * y <=> &0 < y)) /\
     (!x y. &0 < y ==> (&0 < x * y <=> &0 < x))
val REAL_MUL_POS_LT : thm =
  |- !x y. &0 < x * y <=> &0 < x /\ &0 < y \/ x < &0 /\ y < &0
val REAL_MUL_POS_LE : thm =
  |- !x y.
         &0 <= x * y <=>
         x = &0 \/ y = &0 \/ &0 < x /\ &0 < y \/ x < &0 /\ y < &0
val REAL_LE_RDIV_EQ : thm = |- !x y z. &0 < z ==> (x <= y / z <=> x * z <= y)
val REAL_LE_LDIV_EQ : thm = |- !x y z. &0 < z ==> (x / z <= y <=> x <= y * z)
val REAL_LT_RDIV_EQ : thm = |- !x y z. &0 < z ==> (x < y / z <=> x * z < y)
val REAL_LT_LDIV_EQ : thm = |- !x y z. &0 < z ==> (x / z < y <=> x < y * z)
val REAL_EQ_RDIV_EQ : thm = |- !x y z. &0 < z ==> (x = y / z <=> x * z = y)
val REAL_EQ_LDIV_EQ : thm = |- !x y z. &0 < z ==> (x / z = y <=> x = y * z)
val REAL_LT_DIV2_EQ : thm = |- !x y z. &0 < z ==> (x / z < y / z <=> x < y)
val REAL_LE_DIV2_EQ : thm = |- !x y z. &0 < z ==> (x / z <= y / z <=> x <= y)
val REAL_MUL_2 : thm = |- !x. &2 * x = x + x
val REAL_POW_EQ_0 : thm = |- !x n. x pow n = &0 <=> x = &0 /\ ~(n = 0)
val REAL_LE_MUL2 : thm =
  |- !w x y z. &0 <= w /\ w <= x /\ &0 <= y /\ y <= z ==> w * y <= x * z
val REAL_LT_MUL2 : thm =
  |- !w x y z. &0 <= w /\ w < x /\ &0 <= y /\ y < z ==> w * y < x * z
val REAL_LT_SQUARE : thm = |- !x. &0 < x * x <=> ~(x = &0)
val REAL_POW_1 : thm = |- !x. x pow 1 = x
val REAL_POW_ONE : thm = |- !n. &1 pow n = &1
val REAL_LT_INV2 : thm = |- !x y. &0 < x /\ x < y ==> inv y < inv x
val REAL_LE_INV2 : thm = |- !x y. &0 < x /\ x <= y ==> inv y <= inv x
val REAL_LT_LINV : thm = |- !x y. &0 < y /\ inv y < x ==> inv x < y
val REAL_LT_RINV : thm = |- !x y. &0 < x /\ x < inv y ==> y < inv x
val REAL_LE_LINV : thm = |- !x y. &0 < y /\ inv y <= x ==> inv x <= y
val REAL_LE_RINV : thm = |- !x y. &0 < x /\ x <= inv y ==> y <= inv x
val REAL_INV_LE_1 : thm = |- !x. &1 <= x ==> inv x <= &1
val REAL_INV_1_LE : thm = |- !x. &0 < x /\ x <= &1 ==> &1 <= inv x
val REAL_INV_LT_1 : thm = |- !x. &1 < x ==> inv x < &1
val REAL_INV_1_LT : thm = |- !x. &0 < x /\ x < &1 ==> &1 < inv x
val REAL_SUB_INV : thm =
  |- !x y. ~(x = &0) /\ ~(y = &0) ==> inv x - inv y = (y - x) / (x * y)
val REAL_DOWN : thm = |- !d. &0 < d ==> (?e. &0 < e /\ e < d)
val REAL_DOWN2 : thm =
  |- !d1 d2. &0 < d1 /\ &0 < d2 ==> (?e. &0 < e /\ e < d1 /\ e < d2)
val REAL_POW_LE2 : thm = |- !n x y. &0 <= x /\ x <= y ==> x pow n <= y pow n
val REAL_POW_LE_1 : thm = |- !n x. &1 <= x ==> &1 <= x pow n
val REAL_POW_1_LE : thm = |- !n x. &0 <= x /\ x <= &1 ==> x pow n <= &1
val REAL_POW_MONO : thm = |- !m n x. &1 <= x /\ m <= n ==> x pow m <= x pow n
val REAL_POW_LT2 : thm =
  |- !n x y. ~(n = 0) /\ &0 <= x /\ x < y ==> x pow n < y pow n
val REAL_POW_LT_1 : thm = |- !n x. ~(n = 0) /\ &1 < x ==> &1 < x pow n
val REAL_POW_1_LT : thm =
  |- !n x. ~(n = 0) /\ &0 <= x /\ x < &1 ==> x pow n < &1
val REAL_POW_MONO_LT : thm = |- !m n x. &1 < x /\ m < n ==> x pow m < x pow n
val REAL_POW_POW : thm = |- !x m n. x pow m pow n = x pow (m * n)
val REAL_EQ_RCANCEL_IMP : thm =
  |- !x y z. ~(z = &0) /\ x * z = y * z ==> x = y
val REAL_EQ_LCANCEL_IMP : thm =
  |- !x y z. ~(z = &0) /\ z * x = z * y ==> x = y
val REAL_LT_DIV : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x / y
val REAL_LE_DIV : thm = |- !x y. &0 <= x /\ &0 <= y ==> &0 <= x / y
val REAL_DIV_POW2 : thm =
  |- !x m n.
         ~(x = &0)
         ==> x pow m / x pow n =
             (if n <= m then x pow (m - n) else inv (x pow (n - m)))
val REAL_DIV_POW2_ALT : thm =
  |- !x m n.
         ~(x = &0)
         ==> x pow m / x pow n =
             (if n < m then x pow (m - n) else inv (x pow (n - m)))
val REAL_LT_POW2 : thm = |- !n. &0 < &2 pow n
val REAL_LE_POW2 : thm = |- !n. &1 <= &2 pow n
val REAL_POW2_ABS : thm = |- !x. abs x pow 2 = x pow 2
0..0..2..9..solved at 14
0..0..2..9..20..40..87..solved at 94
val REAL_LE_SQUARE_ABS : thm = |- !x y. abs x <= abs y <=> x pow 2 <= y pow 2
val REAL_LT_SQUARE_ABS : thm = |- !x y. abs x < abs y <=> x pow 2 < y pow 2
val REAL_EQ_SQUARE_ABS : thm = |- !x y. abs x = abs y <=> x pow 2 = y pow 2
val REAL_LE_POW_2 : thm = |- !x. &0 <= x pow 2
val REAL_LT_POW_2 : thm = |- !x. &0 < x pow 2 <=> ~(x = &0)
val REAL_SOS_EQ_0 : thm =
  |- !x y. x pow 2 + y pow 2 = &0 <=> x = &0 /\ y = &0
val REAL_POW_ZERO : thm = |- !n. &0 pow n = (if n = 0 then &1 else &0)
val REAL_POW_MONO_INV : thm =
  |- !m n x. &0 <= x /\ x <= &1 /\ n <= m ==> x pow m <= x pow n
0..0..2..8..18..34..73..solved at 91
val REAL_POW_LE2_REV : thm =
  |- !n x y. ~(n = 0) /\ &0 <= y /\ x pow n <= y pow n ==> x <= y
0..0..1..5..12..23..solved at 29
val REAL_POW_LT2_REV : thm =
  |- !n x y. &0 <= y /\ x pow n < y pow n ==> x < y
0..0..2..4..8..solved at 13
0..0..2..4..8..solved at 13
val REAL_POW_EQ : thm =
  |- !n x y. ~(n = 0) /\ &0 <= x /\ &0 <= y /\ x pow n = y pow n ==> x = y
val REAL_POW_EQ_ABS : thm =
  |- !n x y. ~(n = 0) /\ x pow n = y pow n ==> abs x = abs y
val REAL_POW_EQ_1_IMP : thm =
  |- !x n. ~(n = 0) /\ x pow n = &1 ==> abs x = &1
0..0..2..4..solved at 8
0..0..3..6..solved at 13
0..0..solved at 4
0..0..solved at 3
val REAL_POW_EQ_1 : thm =
  |- !x n. x pow n = &1 <=> abs x = &1 /\ (x < &0 ==> EVEN n) \/ n = 0
val REAL_POW_LT2_ODD : thm = |- !n x y. x < y /\ ODD n ==> x pow n < y pow n
val REAL_POW_LE2_ODD : thm =
  |- !n x y. x <= y /\ ODD n ==> x pow n <= y pow n
0..0..1..4..9..17..solved at 23
0..0..1..4..solved at 9
val REAL_POW_LT2_ODD_EQ : thm =
  |- !n x y. ODD n ==> (x pow n < y pow n <=> x < y)
0..0..1..5..10..18..solved at 24
0..0..1..5..solved at 10
val REAL_POW_LE2_ODD_EQ : thm =
  |- !n x y. ODD n ==> (x pow n <= y pow n <=> x <= y)
val REAL_POW_EQ_ODD_EQ : thm =
  |- !n x y. ODD n ==> (x pow n = y pow n <=> x = y)
0..0..1..2..solved at 6
val REAL_POW_EQ_ODD : thm = |- !n x y. ODD n /\ x pow n = y pow n ==> x = y
0..0..2..5..solved at 10
val REAL_POW_EQ_EQ : thm =
  |- !n x y.
         x pow n = y pow n <=>
         (if EVEN n then n = 0 \/ abs x = abs y else x = y)
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..3..solved at 7
0..0..2..11..34..84..193..424..970..solved at 1151
val REAL_ARCH_SIMPLE : thm = |- !x. ?n. x <= &n
0..0..1..2..3..8..solved at 14
val REAL_ARCH_LT : thm = |- !x. ?n. x < &n
0..0..1..2..solved at 6
val REAL_ARCH : thm = |- !x. &0 < x ==> (!y. ?n. y < &n * x)
val real_sgn : thm =
  |- !x. real_sgn x = (if &0 < x then &1 else if x < &0 then -- &1 else &0)
val REAL_SGN_0 : thm = |- real_sgn (&0) = &0
val REAL_SGN_NEG : thm = |- !x. real_sgn (--x) = --real_sgn x
val REAL_SGN_ABS : thm = |- !x. real_sgn x * abs x = x
0..0..solved at 2
0..0..solved at 2
0..0..1..2..6..12..27..48..solved at 81
val REAL_EQ_SGN_ABS : thm =
  |- !x y. x = y <=> real_sgn x = real_sgn y /\ abs x = abs y
val REAL_ABS_SGN : thm = |- !x. abs (real_sgn x) = real_sgn (abs x)
val REAL_SGN : thm = |- !x. real_sgn x = x / abs x
val REAL_SGN_MUL : thm = |- !x y. real_sgn (x * y) = real_sgn x * real_sgn y
val REAL_SGN_INV : thm = |- !x. real_sgn (inv x) = real_sgn x
val REAL_SGN_DIV : thm = |- !x y. real_sgn (x / y) = real_sgn x / real_sgn y
val REAL_SGN_EQ : thm =
  |- (!x. real_sgn x = &0 <=> x = &0) /\
     (!x. real_sgn x = &1 <=> x > &0) /\
     (!x. real_sgn x = -- &1 <=> x < &0)
val REAL_SGN_CASES : thm =
  |- !x. real_sgn x = &0 \/ real_sgn x = &1 \/ real_sgn x = -- &1
val REAL_SGN_INEQS : thm =
  |- (!x. &0 <= real_sgn x <=> &0 <= x) /\
     (!x. &0 < real_sgn x <=> &0 < x) /\
     (!x. &0 >= real_sgn x <=> &0 >= x) /\
     (!x. &0 > real_sgn x <=> &0 > x) /\
     (!x. &0 = real_sgn x <=> &0 = x) /\
     (!x. real_sgn x <= &0 <=> x <= &0) /\
     (!x. real_sgn x < &0 <=> x < &0) /\
     (!x. real_sgn x >= &0 <=> x >= &0) /\
     (!x. real_sgn x > &0 <=> x > &0) /\
     (!x. real_sgn x = &0 <=> x = &0)
val REAL_SGN_POW : thm = |- !x n. real_sgn (x pow n) = real_sgn x pow n
val REAL_SGN_POW_2 : thm = |- !x. real_sgn (x pow 2) = real_sgn (abs x)
val REAL_SGN_REAL_SGN : thm = |- !x. real_sgn (real_sgn x) = real_sgn x
val REAL_INV_SGN : thm = |- !x. inv (real_sgn x) = real_sgn x
0..0..1..5..13..27..solved at 33
val REAL_WLOG_LE : thm =
  |- (!x y. P x y <=> P y x) /\ (!x y. x <= y ==> P x y) ==> (!x y. P x y)
0..0..1..5..11..22..49..95..171..305..solved at 319
val REAL_WLOG_LT : thm =
  |- (!x. P x x) /\ (!x y. P x y <=> P y x) /\ (!x y. x < y ==> P x y)
     ==> (!x y. P x y)
- : unit = ()
File "real.ml" already loaded
- : unit = ()
val DECIMAL : thm = |- !x y. DECIMAL x y = &x / &y
val RAT_LEMMA1 : thm =
  |- ~(y1 = &0) /\ ~(y2 = &0)
     ==> x1 / y1 + x2 / y2 = (x1 * y2 + x2 * y1) * inv y1 * inv y2
val RAT_LEMMA2 : thm =
  |- &0 < y1 /\ &0 < y2
     ==> x1 / y1 + x2 / y2 = (x1 * y2 + x2 * y1) * inv y1 * inv y2
val RAT_LEMMA3 : thm =
  |- &0 < y1 /\ &0 < y2
     ==> x1 / y1 - x2 / y2 = (x1 * y2 - x2 * y1) * inv y1 * inv y2
val RAT_LEMMA4 : thm =
  |- &0 < y1 /\ &0 < y2 ==> (x1 / y1 <= x2 / y2 <=> x1 * y2 <= x2 * y1)
val RAT_LEMMA5 : thm =
  |- &0 < y1 /\ &0 < y2 ==> (x1 / y1 = x2 / y2 <=> x1 * y2 = x2 * y1)
val REAL_INT_RAT_CONV : conv = <fun>
val REAL_RAT_LE_CONV : conv = <fun>
val REAL_RAT_LT_CONV : conv = <fun>
val REAL_RAT_GE_CONV : conv = <fun>
val REAL_RAT_GT_CONV : conv = <fun>
val REAL_RAT_EQ_CONV : conv = <fun>
val REAL_RAT_NEG_CONV : term -> thm = <fun>
val REAL_RAT_ABS_CONV : conv = <fun>
val REAL_RAT_INV_CONV : conv = <fun>
val REAL_RAT_ADD_CONV : conv = <fun>
val REAL_RAT_SUB_CONV : conv = <fun>
val REAL_RAT_MUL_CONV : conv = <fun>
val REAL_RAT_DIV_CONV : conv = <fun>
val REAL_RAT_POW_CONV : conv = <fun>
val REAL_RAT_MAX_CONV : conv = <fun>
val REAL_RAT_MIN_CONV : conv = <fun>
val REAL_RAT_RED_CONV : term -> thm = <fun>
val REAL_RAT_REDUCE_CONV : conv = <fun>
val REAL_POLY_NEG_CONV : term -> thm = <fun>
val REAL_POLY_ADD_CONV : term -> thm = <fun>
val REAL_POLY_SUB_CONV : term -> thm = <fun>
val REAL_POLY_MUL_CONV : term -> thm = <fun>
val REAL_POLY_POW_CONV : term -> thm = <fun>
val REAL_POLY_CONV : term -> thm = <fun>
val REAL_POLY_CONV : term -> thm = <fun>
0..0..3..solved at 6
0..0..1..4..12..53..156..809..solved at 3536
val REAL_RING : term -> thm = <fun>
val real_ideal_cofactors : term list -> term -> term list = <fun>
val REAL_IDEAL_CONV : term list -> term -> thm = <fun>
val GEN_REAL_ARITH :
  ((thm list * thm list * thm list -> positivstellensatz -> thm) ->
   thm list * thm list * thm list -> thm) ->
  term -> thm = <fun>
val REAL_ARITH : term -> thm = <fun>
val REAL_ARITH_TAC : tactic = <fun>
val ASM_REAL_ARITH_TAC : tactic = <fun>
val REAL_FIELD : term -> thm = <fun>
- : unit = ()
File "calc_rat.ml" already loaded
- : unit = ()
val integer : thm = |- !x. integer x <=> (?n. abs x = &n)
val is_int : thm = |- integer x <=> (?n. x = &n \/ x = -- &n)
val int_tybij : thm =
  |- (!a. int_of_real (real_of_int a) = a) /\
     (!r. integer r <=> real_of_int (int_of_real r) = r)
val int_abstr : thm = |- int_of_real (real_of_int a) = a
val int_rep : thm = |- integer r <=> real_of_int (int_of_real r) = r
val dest_int_rep : thm =
  |- !i. ?n. real_of_int i = &n \/ real_of_int i = -- &n
val int_eq : thm = |- !x y. x = y <=> real_of_int x = real_of_int y
- : unit = ()
val prioritize_int : unit -> unit = <fun>
val int_le : thm = |- !x y. x <= y <=> real_of_int x <= real_of_int y
val int_lt : thm = |- !x y. x < y <=> real_of_int x < real_of_int y
val int_ge : thm = |- !x y. x >= y <=> real_of_int x >= real_of_int y
val int_gt : thm = |- !x y. x > y <=> real_of_int x > real_of_int y
val int_of_num : thm = |- !n. &n = int_of_real (&n)
val int_of_num_th : thm = |- !n. real_of_int (&n) = &n
val int_neg : thm = |- !i. --i = int_of_real (--real_of_int i)
val int_neg_th : thm = |- !x. real_of_int (--x) = --real_of_int x
val int_add : thm =
  |- !x y. x + y = int_of_real (real_of_int x + real_of_int y)
val int_add_th : thm =
  |- !x y. real_of_int (x + y) = real_of_int x + real_of_int y
val int_sub : thm =
  |- !x y. x - y = int_of_real (real_of_int x - real_of_int y)
val int_sub_th : thm =
  |- !x y. real_of_int (x - y) = real_of_int x - real_of_int y
val int_mul : thm =
  |- !x y. x * y = int_of_real (real_of_int x * real_of_int y)
val int_mul_th : thm =
  |- !x y. real_of_int (x * y) = real_of_int x * real_of_int y
val int_abs : thm = |- !x. abs x = int_of_real (abs (real_of_int x))
val int_abs_th : thm = |- !x. real_of_int (abs x) = abs (real_of_int x)
val int_sgn : thm = |- !x. int_sgn x = int_of_real (real_sgn (real_of_int x))
0..0..1..solved at 5
0..0..1..solved at 4
0..0..1..solved at 5
val int_sgn_th : thm =
  |- !x. real_of_int (int_sgn x) = real_sgn (real_of_int x)
val int_max : thm =
  |- !x y. max x y = int_of_real (max (real_of_int x) (real_of_int y))
val int_max_th : thm =
  |- !x y. real_of_int (max x y) = max (real_of_int x) (real_of_int y)
val int_min : thm =
  |- !x y. min x y = int_of_real (min (real_of_int x) (real_of_int y))
val int_min_th : thm =
  |- !x y. real_of_int (min x y) = min (real_of_int x) (real_of_int y)
val int_pow : thm = |- !x n. x pow n = int_of_real (real_of_int x pow n)
val int_pow_th : thm = |- !x n. real_of_int (x pow n) = real_of_int x pow n
val INT_IMAGE : thm = |- !x. (?n. x = &n) \/ (?n. x = -- &n)
val INT_LT_DISCRETE : thm = |- !x y. x < y <=> x + &1 <= y
val INT_GT_DISCRETE : thm = |- !x y. x > y <=> x >= y + &1
val is_intconst : term -> bool = <fun>
val dest_intconst : term -> num = <fun>
val mk_intconst : num -> term = <fun>
val INT_OF_REAL_THM : thm -> thm = <fun>
val INT_ABS_0 : thm = |- abs (&0) = &0
val INT_ABS_1 : thm = |- abs (&1) = &1
val INT_ABS_ABS : thm = |- !x. abs (abs x) = abs x
val INT_ABS_BETWEEN : thm =
  |- !x y d. &0 < d /\ x - d < y /\ y < x + d <=> abs (y - x) < d
val INT_ABS_BETWEEN1 : thm =
  |- !x y z. x < z /\ abs (y - x) < z - x ==> y < z
val INT_ABS_BETWEEN2 : thm =
  |- !x0 x y0 y.
         x0 < y0 /\
         &2 * abs (x - x0) < y0 - x0 /\
         &2 * abs (y - y0) < y0 - x0
         ==> x < y
val INT_ABS_BOUND : thm = |- !x y d. abs (x - y) < d ==> y < x + d
val INT_ABS_CASES : thm = |- !x. x = &0 \/ &0 < abs x
val INT_ABS_CIRCLE : thm =
  |- !x y h. abs h < abs y - abs x ==> abs (x + h) < abs y
val INT_ABS_LE : thm = |- !x. x <= abs x
val INT_ABS_MUL : thm = |- !x y. abs (x * y) = abs x * abs y
val INT_ABS_NEG : thm = |- !x. abs (--x) = abs x
val INT_ABS_NUM : thm = |- !n. abs (&n) = &n
val INT_ABS_NZ : thm = |- !x. ~(x = &0) <=> &0 < abs x
val INT_ABS_POS : thm = |- !x. &0 <= abs x
val INT_ABS_POW : thm = |- !x n. abs (x pow n) = abs x pow n
val INT_ABS_REFL : thm = |- !x. abs x = x <=> &0 <= x
val INT_ABS_SGN : thm = |- !x. abs (int_sgn x) = int_sgn (abs x)
val INT_ABS_SIGN : thm = |- !x y. abs (x - y) < y ==> &0 < x
val INT_ABS_SIGN2 : thm = |- !x y. abs (x - y) < --y ==> x < &0
val INT_ABS_STILLNZ : thm = |- !x y. abs (x - y) < abs y ==> ~(x = &0)
val INT_ABS_SUB : thm = |- !x y. abs (x - y) = abs (y - x)
val INT_ABS_SUB_ABS : thm = |- !x y. abs (abs x - abs y) <= abs (x - y)
val INT_ABS_TRIANGLE : thm = |- !x y. abs (x + y) <= abs x + abs y
val INT_ABS_ZERO : thm = |- !x. abs x = &0 <=> x = &0
val INT_ADD2_SUB2 : thm = |- !a b c d. (a + b) - (c + d) = a - c + b - d
val INT_ADD_AC : thm =
  |- m + n = n + m /\ (m + n) + p = m + n + p /\ m + n + p = n + m + p
val INT_ADD_ASSOC : thm = |- !x y z. x + y + z = (x + y) + z
val INT_ADD_LDISTRIB : thm = |- !x y z. x * (y + z) = x * y + x * z
val INT_ADD_LID : thm = |- !x. &0 + x = x
val INT_ADD_LINV : thm = |- !x. --x + x = &0
val INT_ADD_RDISTRIB : thm = |- !x y z. (x + y) * z = x * z + y * z
val INT_ADD_RID : thm = |- !x. x + &0 = x
val INT_ADD_RINV : thm = |- !x. x + --x = &0
val INT_ADD_SUB : thm = |- !x y. (x + y) - x = y
val INT_ADD_SUB2 : thm = |- !x y. x - (x + y) = --y
val INT_ADD_SYM : thm = |- !x y. x + y = y + x
val INT_BOUNDS_LE : thm = |- !x k. --k <= x /\ x <= k <=> abs x <= k
val INT_BOUNDS_LT : thm = |- !x k. --k < x /\ x < k <=> abs x < k
val INT_DIFFSQ : thm = |- !x y. (x + y) * (x - y) = x * x - y * y
val INT_ENTIRE : thm = |- !x y. x * y = &0 <=> x = &0 \/ y = &0
val INT_EQ_ADD_LCANCEL : thm = |- !x y z. x + y = x + z <=> y = z
val INT_EQ_ADD_LCANCEL_0 : thm = |- !x y. x + y = x <=> y = &0
val INT_EQ_ADD_RCANCEL : thm = |- !x y z. x + z = y + z <=> x = y
val INT_EQ_ADD_RCANCEL_0 : thm = |- !x y. x + y = y <=> x = &0
val INT_EQ_IMP_LE : thm = |- !x y. x = y ==> x <= y
val INT_EQ_MUL_LCANCEL : thm = |- !x y z. x * y = x * z <=> x = &0 \/ y = z
val INT_EQ_MUL_RCANCEL : thm = |- !x y z. x * z = y * z <=> x = y \/ z = &0
val INT_EQ_NEG2 : thm = |- !x y. --x = --y <=> x = y
val INT_EQ_SGN_ABS : thm =
  |- !x y. x = y <=> int_sgn x = int_sgn y /\ abs x = abs y
val INT_EQ_SQUARE_ABS : thm = |- !x y. abs x = abs y <=> x pow 2 = y pow 2
val INT_EQ_SUB_LADD : thm = |- !x y z. x = y - z <=> x + z = y
val INT_EQ_SUB_RADD : thm = |- !x y z. x - y = z <=> x = z + y
val INT_LET_ADD : thm = |- !x y. &0 <= x /\ &0 < y ==> &0 < x + y
val INT_LET_ADD2 : thm = |- !w x y z. w <= x /\ y < z ==> w + y < x + z
val INT_LET_ANTISYM : thm = |- !x y. ~(x <= y /\ y < x)
val INT_LET_TOTAL : thm = |- !x y. x <= y \/ y < x
val INT_LET_TRANS : thm = |- !x y z. x <= y /\ y < z ==> x < z
val INT_LE_01 : thm = |- &0 <= &1
val INT_LE_ADD : thm = |- !x y. &0 <= x /\ &0 <= y ==> &0 <= x + y
val INT_LE_ADD2 : thm = |- !w x y z. w <= x /\ y <= z ==> w + y <= x + z
val INT_LE_ADDL : thm = |- !x y. y <= x + y <=> &0 <= x
val INT_LE_ADDR : thm = |- !x y. x <= x + y <=> &0 <= y
val INT_LE_ANTISYM : thm = |- !x y. x <= y /\ y <= x <=> x = y
val INT_LE_DOUBLE : thm = |- !x. &0 <= x + x <=> &0 <= x
val INT_LE_LADD : thm = |- !x y z. x + y <= x + z <=> y <= z
val INT_LE_LADD_IMP : thm = |- !x y z. y <= z ==> x + y <= x + z
val INT_LE_LMUL : thm = |- !x y z. &0 <= x /\ y <= z ==> x * y <= x * z
val INT_LE_LNEG : thm = |- !x y. --x <= y <=> &0 <= x + y
val INT_LE_LT : thm = |- !x y. x <= y <=> x < y \/ x = y
val INT_LE_MAX : thm = |- !x y z. z <= max x y <=> z <= x \/ z <= y
val INT_LE_MIN : thm = |- !x y z. z <= min x y <=> z <= x /\ z <= y
val INT_LE_MUL : thm = |- !x y. &0 <= x /\ &0 <= y ==> &0 <= x * y
val INT_LE_MUL_EQ : thm =
  |- (!x y. &0 < x ==> (&0 <= x * y <=> &0 <= y)) /\
     (!x y. &0 < y ==> (&0 <= x * y <=> &0 <= x))
val INT_LE_NEG : thm = |- !x y. --x <= --y <=> y <= x
val INT_LE_NEG2 : thm = |- !x y. --x <= --y <=> y <= x
val INT_LE_NEGL : thm = |- !x. --x <= x <=> &0 <= x
val INT_LE_NEGR : thm = |- !x. x <= --x <=> x <= &0
val INT_LE_NEGTOTAL : thm = |- !x. &0 <= x \/ &0 <= --x
val INT_LE_POW2 : thm = |- !n. &1 <= &2 pow n
val INT_LE_RADD : thm = |- !x y z. x + z <= y + z <=> x <= y
val INT_LE_REFL : thm = |- !x. x <= x
val INT_LE_RMUL : thm = |- !x y z. x <= y /\ &0 <= z ==> x * z <= y * z
val INT_LE_RNEG : thm = |- !x y. x <= --y <=> x + y <= &0
val INT_LE_SQUARE : thm = |- !x. &0 <= x * x
val INT_LE_SQUARE_ABS : thm = |- !x y. abs x <= abs y <=> x pow 2 <= y pow 2
val INT_LE_SUB_LADD : thm = |- !x y z. x <= y - z <=> x + z <= y
val INT_LE_SUB_RADD : thm = |- !x y z. x - y <= z <=> x <= z + y
val INT_LE_TOTAL : thm = |- !x y. x <= y \/ y <= x
val INT_LE_TRANS : thm = |- !x y z. x <= y /\ y <= z ==> x <= z
val INT_LNEG_UNIQ : thm = |- !x y. x + y = &0 <=> x = --y
val INT_LTE_ADD : thm = |- !x y. &0 < x /\ &0 <= y ==> &0 < x + y
val INT_LTE_ADD2 : thm = |- !w x y z. w < x /\ y <= z ==> w + y < x + z
val INT_LTE_ANTISYM : thm = |- !x y. ~(x < y /\ y <= x)
val INT_LTE_TOTAL : thm = |- !x y. x < y \/ y <= x
val INT_LTE_TRANS : thm = |- !x y z. x < y /\ y <= z ==> x < z
val INT_LT_01 : thm = |- &0 < &1
val INT_LT_ADD : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x + y
val INT_LT_ADD1 : thm = |- !x y. x <= y ==> x < y + &1
val INT_LT_ADD2 : thm = |- !w x y z. w < x /\ y < z ==> w + y < x + z
val INT_LT_ADDL : thm = |- !x y. y < x + y <=> &0 < x
val INT_LT_ADDNEG : thm = |- !x y z. y < x + --z <=> y + z < x
val INT_LT_ADDNEG2 : thm = |- !x y z. x + --y < z <=> x < z + y
val INT_LT_ADDR : thm = |- !x y. x < x + y <=> &0 < y
val INT_LT_ADD_SUB : thm = |- !x y z. x + y < z <=> x < z - y
val INT_LT_ANTISYM : thm = |- !x y. ~(x < y /\ y < x)
val INT_LT_GT : thm = |- !x y. x < y ==> ~(y < x)
val INT_LT_IMP_LE : thm = |- !x y. x < y ==> x <= y
val INT_LT_IMP_NE : thm = |- !x y. x < y ==> ~(x = y)
val INT_LT_LADD : thm = |- !x y z. x + y < x + z <=> y < z
val INT_LT_LE : thm = |- !x y. x < y <=> x <= y /\ ~(x = y)
val INT_LT_LMUL_EQ : thm = |- !x y z. &0 < z ==> (z * x < z * y <=> x < y)
val INT_LT_MAX : thm = |- !x y z. z < max x y <=> z < x \/ z < y
val INT_LT_MIN : thm = |- !x y z. z < min x y <=> z < x /\ z < y
val INT_LT_MUL : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x * y
val INT_LT_MUL_EQ : thm =
  |- (!x y. &0 < x ==> (&0 < x * y <=> &0 < y)) /\
     (!x y. &0 < y ==> (&0 < x * y <=> &0 < x))
val INT_LT_NEG : thm = |- !x y. --x < --y <=> y < x
val INT_LT_NEG2 : thm = |- !x y. --x < --y <=> y < x
val INT_LT_NEGTOTAL : thm = |- !x. x = &0 \/ &0 < x \/ &0 < --x
val INT_LT_POW2 : thm = |- !n. &0 < &2 pow n
val INT_LT_RADD : thm = |- !x y z. x + z < y + z <=> x < y
val INT_LT_REFL : thm = |- !x. ~(x < x)
val INT_LT_RMUL_EQ : thm = |- !x y z. &0 < z ==> (x * z < y * z <=> x < y)
val INT_LT_SQUARE_ABS : thm = |- !x y. abs x < abs y <=> x pow 2 < y pow 2
val INT_LT_SUB_LADD : thm = |- !x y z. x < y - z <=> x + z < y
val INT_LT_SUB_RADD : thm = |- !x y z. x - y < z <=> x < z + y
val INT_LT_TOTAL : thm = |- !x y. x = y \/ x < y \/ y < x
val INT_LT_TRANS : thm = |- !x y z. x < y /\ y < z ==> x < z
val INT_MAX_ACI : thm =
  |- max x y = max y x /\
     max (max x y) z = max x (max y z) /\
     max x (max y z) = max y (max x z) /\
     max x x = x /\
     max x (max x y) = max x y
val INT_MAX_ASSOC : thm = |- !x y z. max x (max y z) = max (max x y) z
val INT_MAX_LE : thm = |- !x y z. max x y <= z <=> x <= z /\ y <= z
val INT_MAX_LT : thm = |- !x y z. max x y < z <=> x < z /\ y < z
val INT_MAX_MAX : thm = |- !x y. x <= max x y /\ y <= max x y
val INT_MAX_MIN : thm = |- !x y. max x y = --min (--x) (--y)
val INT_MAX_SYM : thm = |- !x y. max x y = max y x
val INT_MIN_ACI : thm =
  |- min x y = min y x /\
     min (min x y) z = min x (min y z) /\
     min x (min y z) = min y (min x z) /\
     min x x = x /\
     min x (min x y) = min x y
val INT_MIN_ASSOC : thm = |- !x y z. min x (min y z) = min (min x y) z
val INT_MIN_LE : thm = |- !x y z. min x y <= z <=> x <= z \/ y <= z
val INT_MIN_LT : thm = |- !x y z. min x y < z <=> x < z \/ y < z
val INT_MIN_MAX : thm = |- !x y. min x y = --max (--x) (--y)
val INT_MIN_MIN : thm = |- !x y. min x y <= x /\ min x y <= y
val INT_MIN_SYM : thm = |- !x y. min x y = min y x
val INT_MUL_AC : thm =
  |- m * n = n * m /\ (m * n) * p = m * n * p /\ m * n * p = n * m * p
val INT_MUL_ASSOC : thm = |- !x y z. x * y * z = (x * y) * z
val INT_MUL_LID : thm = |- !x. &1 * x = x
val INT_MUL_LNEG : thm = |- !x y. --x * y = --(x * y)
val INT_MUL_LZERO : thm = |- !x. &0 * x = &0
val INT_MUL_POS_LE : thm =
  |- !x y.
         &0 <= x * y <=>
         x = &0 \/ y = &0 \/ &0 < x /\ &0 < y \/ x < &0 /\ y < &0
val INT_MUL_POS_LT : thm =
  |- !x y. &0 < x * y <=> &0 < x /\ &0 < y \/ x < &0 /\ y < &0
val INT_MUL_RID : thm = |- !x. x * &1 = x
val INT_MUL_RNEG : thm = |- !x y. x * --y = --(x * y)
val INT_MUL_RZERO : thm = |- !x. x * &0 = &0
val INT_MUL_SYM : thm = |- !x y. x * y = y * x
val INT_NEGNEG : thm = |- !x. -- --x = x
val INT_NEG_0 : thm = |- -- &0 = &0
val INT_NEG_ADD : thm = |- !x y. --(x + y) = --x + --y
val INT_NEG_EQ : thm = |- !x y. --x = y <=> x = --y
val INT_NEG_EQ_0 : thm = |- !x. --x = &0 <=> x = &0
val INT_NEG_GE0 : thm = |- !x. &0 <= --x <=> x <= &0
val INT_NEG_GT0 : thm = |- !x. &0 < --x <=> x < &0
val INT_NEG_LE0 : thm = |- !x. --x <= &0 <=> &0 <= x
val INT_NEG_LMUL : thm = |- !x y. --(x * y) = --x * y
val INT_NEG_LT0 : thm = |- !x. --x < &0 <=> &0 < x
val INT_NEG_MINUS1 : thm = |- !x. --x = -- &1 * x
val INT_NEG_MUL2 : thm = |- !x y. --x * --y = x * y
val INT_NEG_NEG : thm = |- !x. -- --x = x
val INT_NEG_RMUL : thm = |- !x y. --(x * y) = x * --y
val INT_NEG_SUB : thm = |- !x y. --(x - y) = y - x
val INT_NOT_EQ : thm = |- !x y. ~(x = y) <=> x < y \/ y < x
val INT_NOT_LE : thm = |- !x y. ~(x <= y) <=> y < x
val INT_NOT_LT : thm = |- !x y. ~(x < y) <=> y <= x
val INT_OF_NUM_ADD : thm = |- !m n. &m + &n = &(m + n)
val INT_OF_NUM_EQ : thm = |- !m n. &m = &n <=> m = n
val INT_OF_NUM_GE : thm = |- !m n. &m >= &n <=> m >= n
val INT_OF_NUM_GT : thm = |- !m n. &m > &n <=> m > n
val INT_OF_NUM_LE : thm = |- !m n. &m <= &n <=> m <= n
val INT_OF_NUM_LT : thm = |- !m n. &m < &n <=> m < n
val INT_OF_NUM_MAX : thm = |- !m n. max (&m) (&n) = &(MAX m n)
val INT_OF_NUM_MIN : thm = |- !m n. min (&m) (&n) = &(MIN m n)
val INT_OF_NUM_MUL : thm = |- !m n. &m * &n = &(m * n)
val INT_OF_NUM_POW : thm = |- !x n. &x pow n = &(x EXP n)
val INT_OF_NUM_SUB : thm = |- !m n. m <= n ==> &n - &m = &(n - m)
val INT_OF_NUM_SUC : thm = |- !n. &n + &1 = &(SUC n)
val INT_POS : thm = |- !n. &0 <= &n
val INT_POS_NZ : thm = |- !x. &0 < x ==> ~(x = &0)
val INT_POW2_ABS : thm = |- !x. abs x pow 2 = x pow 2
val INT_POW_1 : thm = |- !x. x pow 1 = x
val INT_POW_1_LE : thm = |- !n x. &0 <= x /\ x <= &1 ==> x pow n <= &1
val INT_POW_1_LT : thm =
  |- !n x. ~(n = 0) /\ &0 <= x /\ x < &1 ==> x pow n < &1
val INT_POW_2 : thm = |- !x. x pow 2 = x * x
val INT_POW_ADD : thm = |- !x m n. x pow (m + n) = x pow m * x pow n
val INT_POW_EQ : thm =
  |- !n x y. ~(n = 0) /\ &0 <= x /\ &0 <= y /\ x pow n = y pow n ==> x = y
val INT_POW_EQ_0 : thm = |- !x n. x pow n = &0 <=> x = &0 /\ ~(n = 0)
val INT_POW_EQ_ABS : thm =
  |- !n x y. ~(n = 0) /\ x pow n = y pow n ==> abs x = abs y
val INT_POW_LE : thm = |- !x n. &0 <= x ==> &0 <= x pow n
val INT_POW_LE2 : thm = |- !n x y. &0 <= x /\ x <= y ==> x pow n <= y pow n
val INT_POW_LE2_ODD : thm = |- !n x y. x <= y /\ ODD n ==> x pow n <= y pow n
val INT_POW_LE2_REV : thm =
  |- !n x y. ~(n = 0) /\ &0 <= y /\ x pow n <= y pow n ==> x <= y
val INT_POW_LE_1 : thm = |- !n x. &1 <= x ==> &1 <= x pow n
val INT_POW_LT : thm = |- !x n. &0 < x ==> &0 < x pow n
val INT_POW_LT2 : thm =
  |- !n x y. ~(n = 0) /\ &0 <= x /\ x < y ==> x pow n < y pow n
val INT_POW_LT2_REV : thm = |- !n x y. &0 <= y /\ x pow n < y pow n ==> x < y
val INT_POW_LT_1 : thm = |- !n x. ~(n = 0) /\ &1 < x ==> &1 < x pow n
val INT_POW_MONO : thm = |- !m n x. &1 <= x /\ m <= n ==> x pow m <= x pow n
val INT_POW_MONO_LT : thm = |- !m n x. &1 < x /\ m < n ==> x pow m < x pow n
val INT_POW_MUL : thm = |- !x y n. (x * y) pow n = x pow n * y pow n
val INT_POW_NEG : thm =
  |- !x n. --x pow n = (if EVEN n then x pow n else --(x pow n))
val INT_POW_NZ : thm = |- !x n. ~(x = &0) ==> ~(x pow n = &0)
val INT_POW_ONE : thm = |- !n. &1 pow n = &1
val INT_POW_POW : thm = |- !x m n. x pow m pow n = x pow (m * n)
val INT_POW_ZERO : thm = |- !n. &0 pow n = (if n = 0 then &1 else &0)
val INT_RNEG_UNIQ : thm = |- !x y. x + y = &0 <=> y = --x
val INT_SGN : thm =
  |- !x. int_sgn x = (if &0 < x then &1 else if x < &0 then -- &1 else &0)
val INT_SGN_0 : thm = |- int_sgn (&0) = &0
val INT_SGN_ABS : thm = |- !x. int_sgn x * abs x = x
val INT_SGN_CASES : thm =
  |- !x. int_sgn x = &0 \/ int_sgn x = &1 \/ int_sgn x = -- &1
val INT_SGN_EQ : thm =
  |- (!x. int_sgn x = &0 <=> x = &0) /\
     (!x. int_sgn x = &1 <=> x > &0) /\
     (!x. int_sgn x = -- &1 <=> x < &0)
val INT_SGN_INEQS : thm =
  |- (!x. &0 <= int_sgn x <=> &0 <= x) /\
     (!x. &0 < int_sgn x <=> &0 < x) /\
     (!x. &0 >= int_sgn x <=> &0 >= x) /\
     (!x. &0 > int_sgn x <=> &0 > x) /\
     (!x. &0 = int_sgn x <=> &0 = x) /\
     (!x. int_sgn x <= &0 <=> x <= &0) /\
     (!x. int_sgn x < &0 <=> x < &0) /\
     (!x. int_sgn x >= &0 <=> x >= &0) /\
     (!x. int_sgn x > &0 <=> x > &0) /\
     (!x. int_sgn x = &0 <=> x = &0)
val INT_SGN_MUL : thm = |- !x y. int_sgn (x * y) = int_sgn x * int_sgn y
val INT_SGN_NEG : thm = |- !x. int_sgn (--x) = --int_sgn x
val INT_SGN_POW : thm = |- !x n. int_sgn (x pow n) = int_sgn x pow n
val INT_SGN_POW_2 : thm = |- !x. int_sgn (x pow 2) = int_sgn (abs x)
val INT_SGN_INT_SGN : thm = |- !x. int_sgn (int_sgn x) = int_sgn x
val INT_SOS_EQ_0 : thm = |- !x y. x pow 2 + y pow 2 = &0 <=> x = &0 /\ y = &0
val INT_SUB_0 : thm = |- !x y. x - y = &0 <=> x = y
val INT_SUB_ABS : thm = |- !x y. abs x - abs y <= abs (x - y)
val INT_SUB_ADD : thm = |- !x y. x - y + y = x
val INT_SUB_ADD2 : thm = |- !x y. y + x - y = x
val INT_SUB_LDISTRIB : thm = |- !x y z. x * (y - z) = x * y - x * z
val INT_SUB_LE : thm = |- !x y. &0 <= x - y <=> y <= x
val INT_SUB_LNEG : thm = |- !x y. --x - y = --(x + y)
val INT_SUB_LT : thm = |- !x y. &0 < x - y <=> y < x
val INT_SUB_LZERO : thm = |- !x. &0 - x = --x
val INT_SUB_NEG2 : thm = |- !x y. --x - --y = y - x
val INT_SUB_RDISTRIB : thm = |- !x y z. (x - y) * z = x * z - y * z
val INT_SUB_REFL : thm = |- !x. x - x = &0
val INT_SUB_RNEG : thm = |- !x y. x - --y = x + y
val INT_SUB_RZERO : thm = |- !x. x - &0 = x
val INT_SUB_SUB : thm = |- !x y. x - y - x = --y
val INT_SUB_SUB2 : thm = |- !x y. x - (x - y) = y
val INT_SUB_TRIANGLE : thm = |- !a b c. a - b + b - c = a - c
val INT_FORALL_POS : thm = |- !P. (!n. P (&n)) <=> (!i. &0 <= i ==> P i)
0..0..0..solved at 3
0..0..0..solved at 3
val INT_EXISTS_POS : thm = |- !P. (?n. P (&n)) <=> (?i. &0 <= i /\ P i)
0..0..1..solved at 4
0..0..1..2..5..solved at 11
val INT_FORALL_ABS : thm = |- !P. (!n. P (&n)) <=> (!x. P (abs x))
val INT_EXISTS_ABS : thm = |- !P. (?n. P (&n)) <=> (?x. P (abs x))
val INT_ABS_MUL_1 : thm =
  |- !x y. abs (x * y) = &1 <=> abs x = &1 /\ abs y = &1
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
val INT_WOP : thm =
  |- (?x. &0 <= x /\ P x) <=>
     (?x. &0 <= x /\ P x /\ (!y. &0 <= y /\ P y ==> x <= y))
val INT_POW : thm = |- x pow 0 = &1 /\ (!n. x pow SUC n = x * x pow n)
val INT_ABS : thm = |- !x. abs x = (if &0 <= x then x else --x)
val INT_GE : thm = |- !x y. x >= y <=> y <= x
val INT_GT : thm = |- !x y. x > y <=> y < x
val INT_LT : thm = |- !x y. x < y <=> ~(y <= x)
val INT_ARITH : term -> thm = <fun>
val INT_ARITH_TAC : tactic = <fun>
val ASM_INT_ARITH_TAC : tactic = <fun>
val INT_SUB : thm = |- !x y. x - y = x + --y
val INT_MAX : thm = |- !x y. max x y = (if x <= y then y else x)
val INT_MIN : thm = |- !x y. min x y = (if x <= y then x else y)
val INT_OF_NUM_EXISTS : thm = |- !x. (?n. x = &n) <=> &0 <= x
val INT_LE_DISCRETE : thm = |- !x y. x <= y <=> x < y + &1
0..0..solved at 2
0..0..1..5..solved at 9
0..0..1..2..5..8..solved at 14
0..0..2..5..11..23..42..71..111..171..262..solved at 304
0..0..2..solved at 6
val INT_ARCH : thm = |- !x d. ~(d = &0) ==> (?c. x < c * d)
val INT_DIVMOD_EXIST_0 : thm =
  |- !m n.
         ?q r.
             if n = &0
             then q = &0 /\ r = m
             else &0 <= r /\ r < abs n /\ m = q * n + r
- : unit = ()
- : unit = ()
val INT_DIVISION_0 : thm =
  |- !m n.
         if n = &0
         then m div n = &0 /\ m rem n = m
         else &0 <= m rem n /\ m rem n < abs n /\ m = m div n * n + m rem n
0..0..2..solved at 5
0..0..2..solved at 5
0..0..2..solved at 5
val INT_DIVISION : thm =
  |- !m n.
         ~(n = &0)
         ==> m = m div n * n + m rem n /\ &0 <= m rem n /\ m rem n < abs n
val INT_LE_CONV : conv = <fun>
val INT_LT_CONV : conv = <fun>
val INT_GE_CONV : conv = <fun>
val INT_GT_CONV : conv = <fun>
val INT_EQ_CONV : conv = <fun>
val INT_NEG_CONV : conv = <fun>
val INT_MUL_CONV : conv = <fun>
val INT_ADD_CONV : conv = <fun>
val INT_SUB_CONV : conv = <fun>
val INT_POW_CONV : conv = <fun>
val INT_ABS_CONV : conv = <fun>
val INT_MAX_CONV : conv = <fun>
val INT_MIN_CONV : conv = <fun>
val INT_POLY_CONV : term -> thm = <fun>
val INT_RING : term -> thm = <fun>
val int_ideal_cofactors : term list -> term -> term list = <fun>
4 basis elements and 1 critical pairs
5 basis elements and 0 critical pairs
Translating certificate to HOL inferences
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
3 basis elements and 2 critical pairs
4 basis elements and 3 critical pairs
5 basis elements and 0 critical pairs
Translating certificate to HOL inferences
val INT_DIVMOD_UNIQ : thm =
  |- !m n q r.
         m = q * n + r /\ &0 <= r /\ r < abs n ==> m div n = q /\ m rem n = r
0..0..1..2..5..solved at 13
0..0..1..2..5..solved at 13
val INT_DIV_CONV : term -> thm = <fun>
val INT_REM_CONV : term -> thm = <fun>
val INT_RED_CONV : term -> thm = <fun>
val INT_REDUCE_CONV : conv = <fun>
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val cong : thm = |- !rel x y. (x == y) rel <=> rel x y
val real_mod : thm =
  |- !x y n. real_mod n x y <=> (?q. integer q /\ x - y = q * n)
- : unit = ()
- : unit = ()
- : unit = ()
val int_divides : thm = |- !b a. a divides b <=> (?x. b = a * x)
- : unit = ()
- : unit = ()
val int_mod : thm = |- !n x y. mod n x y <=> n divides x - y
val int_congruent : thm = |- !x y n. (x == y) (mod n) <=> (?d. x - y = n * d)
- : unit = ()
val int_coprime : thm = |- !a b. coprime (a,b) <=> (?x y. a * x + b * y = &1)
Warning: inventing type variables
val INTEGER_TAC : tactic = <fun>
val INTEGER_RULE : term -> thm = <fun>
0..0..1..4..11..25..54..solved at 82
0..0..1..4..solved at 12
val WF_INT_MEASURE : thm =
  |- !P m.
         (!x. &0 <= m x) /\ (!x. (!y. m y < m x ==> P y) ==> P x)
         ==> (!x. P x)
val WF_INT_MEASURE_2 : thm =
  |- !P m.
         (!x y. &0 <= m x y) /\
         (!x y. (!x' y'. m x' y' < m x y ==> P x' y') ==> P x y)
         ==> (!x y. P x y)
1 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
0..0..0..2..6..solved at 11
0..0..0..2..6..solved at 11
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
3 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
3 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
3 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
3 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
val INT_GCD_EXISTS : thm =
  |- !a b. ?d. d divides a /\ d divides b /\ (?x y. d = a * x + b * y)
2 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
2 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
0..0..0..0..0..solved at 5
0..0..0..0..0..2..7..12..27..solved at 38
val INT_GCD_EXISTS_POS : thm =
  |- !a b.
         ?d. &0 <= d /\
             d divides a /\
             d divides b /\
             (?x y. d = a * x + b * y)
- : unit = ()
val int_gcd : thm =
  |- !a b.
         &0 <= gcd (a,b) /\
         gcd (a,b) divides a /\
         gcd (a,b) divides b /\
         (?x y. gcd (a,b) = a * x + b * y)
val INTEGER_TAC : tactic = <fun>
val INTEGER_RULE : term -> thm = <fun>
val num_of_int : thm = |- !x. num_of_int x = (@n. &n = x)
val NUM_OF_INT_OF_NUM : thm = |- !n. num_of_int (&n) = n
0..0..solved at 2
val INT_OF_NUM_OF_INT : thm = |- !x. &0 <= x ==> &(num_of_int x) = x
0..0..1..solved at 4
0..0..1..2..3..solved at 8
val NUM_OF_INT : thm = |- !x. &0 <= x <=> &(num_of_int x) = x
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val num_divides : thm = |- !a b. a divides b <=> &a divides &b
val num_mod : thm = |- !n x y. mod n x y <=> mod &n (&x) (&y)
val num_congruent : thm = |- !x y n. (x == y) (mod n) <=> (&x == &y) (mod &n)
val num_coprime : thm = |- !a b. coprime (a,b) <=> coprime (&a,&b)
val num_gcd : thm = |- !a b. gcd (a,b) = num_of_int (gcd (&a,&b))
0..0..1..solved at 4
0..0..1..solved at 4
val NUM_TO_INT_CONV : conv = <fun>
val ARITH_RULE : term -> thm = <fun>
val ARITH_TAC : tactic = <fun>
val ASM_ARITH_TAC : tactic = <fun>
val NUM_GCD : thm = |- !a b. &(gcd (a,b)) = gcd (&a,&b)
0..0..0..solved at 3
0..0..0..solved at 3
val NUMBER_TAC : tactic = <fun>
val NUMBER_RULE : term -> thm = <fun>
2 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
val divides : thm = |- a divides b <=> (?x. b = a * x)
0..0..2..4..8..16..27..42..58..77..100..128..160..222..solved at 242
val DIVIDES_LE : thm = |- !m n. m divides n ==> m <= n \/ n = 0
- : unit = ()
- : unit = ()
File "int.ml" already loaded
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val IN : thm = |- !P x. x IN P <=> P x
val EXTENSION : thm = |- !s t. s = t <=> (!x. x IN s <=> x IN t)
val GSPEC : thm = |- !p. GSPEC p = p
Warning: inventing type variables
val SETSPEC : thm = |- !P v t. SETSPEC v P t <=> P /\ v = t
Warning: inventing type variables
0..0..solved at 2
0..0..0..solved at 3
0..0..solved at 2
0..0..0..solved at 3
val IN_ELIM_THM : thm =
  |- (!P x. x IN GSPEC (\v. P (SETSPEC v)) <=> P (\p t. p /\ x = t)) /\
     (!p x. x IN {y | p y} <=> p x) /\
     (!P x. GSPEC (\v. P (SETSPEC v)) x <=> P (\p t. p /\ x = t)) /\
     (!p x. {y | p y} x <=> p x) /\
     (!p x. x IN (\y. p y) <=> p x)
val EMPTY : thm = |- {} = (\x. F)
val INSERT_DEF : thm = |- !s x. x INSERT s = (\y. y IN s \/ y = x)
val UNIV : thm = |- (:A) = (\x. T)
val UNION : thm = |- !s t. s UNION t = {x | x IN s \/ x IN t}
val UNIONS : thm = |- !s. UNIONS s = {x | ?u. u IN s /\ x IN u}
val INTER : thm = |- !s t. s INTER t = {x | x IN s /\ x IN t}
val INTERS : thm = |- !s. INTERS s = {x | !u. u IN s ==> x IN u}
val DIFF : thm = |- !s t. s DIFF t = {x | x IN s /\ ~(x IN t)}
val INSERT : thm = |- x INSERT s = {y | y IN s \/ y = x}
val DELETE : thm = |- !s x. s DELETE x = {y | y IN s /\ ~(y = x)}
val SUBSET : thm = |- !s t. s SUBSET t <=> (!x. x IN s ==> x IN t)
val PSUBSET : thm = |- !s t. s PSUBSET t <=> s SUBSET t /\ ~(s = t)
val DISJOINT : thm = |- !s t. DISJOINT s t <=> s INTER t = {}
val SING : thm = |- !s. SING s <=> (?x. s = {x})
val FINITE_RULES : thm =
  |- FINITE {} /\ (!x s. FINITE s ==> FINITE (x INSERT s))
val FINITE_INDUCT : thm =
  |- !FINITE'. FINITE' {} /\ (!x s. FINITE' s ==> FINITE' (x INSERT s))
               ==> (!a. FINITE a ==> FINITE' a)
val FINITE_CASES : thm =
  |- !a. FINITE a <=> a = {} \/ (?x s. a = x INSERT s /\ FINITE s)
val INFINITE : thm = |- !s. INFINITE s <=> ~FINITE s
val IMAGE : thm = |- !s f. IMAGE f s = {y | ?x. x IN s /\ y = f x}
val INJ : thm =
  |- !t s f.
         INJ f s t <=>
         (!x. x IN s ==> f x IN t) /\
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
val SURJ : thm =
  |- !t s f.
         SURJ f s t <=>
         (!x. x IN s ==> f x IN t) /\
         (!x. x IN t ==> (?y. y IN s /\ f y = x))
val BIJ : thm = |- !f s t. BIJ f s t <=> INJ f s t /\ SURJ f s t
val CHOICE : thm = |- !s. CHOICE s = (@x. x IN s)
val REST : thm = |- !s. REST s = s DELETE CHOICE s
val NOT_IN_EMPTY : thm = |- !x. ~(x IN {})
val IN_UNIV : thm = |- !x. x IN (:A)
val IN_UNION : thm = |- !s t x. x IN s UNION t <=> x IN s \/ x IN t
val IN_UNIONS : thm = |- !s x. x IN UNIONS s <=> (?t. t IN s /\ x IN t)
val IN_INTER : thm = |- !s t x. x IN s INTER t <=> x IN s /\ x IN t
val IN_INTERS : thm = |- !s x. x IN INTERS s <=> (!t. t IN s ==> x IN t)
val IN_DIFF : thm = |- !s t x. x IN s DIFF t <=> x IN s /\ ~(x IN t)
val IN_INSERT : thm = |- !x y s. x IN y INSERT s <=> x = y \/ x IN s
val IN_DELETE : thm = |- !s x y. x IN s DELETE y <=> x IN s /\ ~(x = y)
val IN_SING : thm = |- !x y. x IN {y} <=> x = y
val IN_IMAGE : thm = |- !y s f. y IN IMAGE f s <=> (?x. y = f x /\ x IN s)
val IN_REST : thm = |- !x s. x IN REST s <=> x IN s /\ ~(x = CHOICE s)
Warning: inventing type variables
0..0..1..solved at 5
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
val FORALL_IN_INSERT : thm =
  |- !P a s. (!x. x IN a INSERT s ==> P x) <=> P a /\ (!x. x IN s ==> P x)
Warning: inventing type variables
0..0..solved at 2
0..0..1..solved at 5
0..0..0..solved at 4
0..0..0..solved at 3
val EXISTS_IN_INSERT : thm =
  |- !P a s. (?x. x IN a INSERT s /\ P x) <=> P a \/ (?x. x IN s /\ P x)
0..0..1..solved at 5
0..0..1..solved at 4
0..0..1..solved at 5
0..0..1..solved at 4
val FORALL_IN_UNION : thm =
  |- !P s t.
         (!x. x IN s UNION t ==> P x) <=>
         (!x. x IN s ==> P x) /\ (!x. x IN t ==> P x)
0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..solved at 4
0..0..0..solved at 3
val EXISTS_IN_UNION : thm =
  |- !P s t.
         (?x. x IN s UNION t /\ P x) <=>
         (?x. x IN s /\ P x) \/ (?x. x IN t /\ P x)
val CHOICE_DEF : thm = |- !s. ~(s = {}) ==> CHOICE s IN s
val SET_TAC : thm list -> tactic = <fun>
val SET_RULE : term -> thm = <fun>
0..0..solved at 2
0..0..1..solved at 4
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
0..0..1..solved at 4
val NOT_EQUAL_SETS : thm = |- !s t. ~(s = t) <=> (?x. x IN t <=> ~(x IN s))
0..0..solved at 2
0..0..solved at 2
val MEMBER_NOT_EMPTY : thm = |- !s. (?x. x IN s) <=> ~(s = {})
val UNIV_NOT_EMPTY : thm = |- ~((:A) = {})
val EMPTY_NOT_UNIV : thm = |- ~({} = (:A))
val EQ_UNIV : thm = |- (!x. x IN s) <=> s = (:A)
0..0..1..3..solved at 7
val SUBSET_TRANS : thm = |- !s t u. s SUBSET t /\ t SUBSET u ==> s SUBSET u
val SUBSET_REFL : thm = |- !s. s SUBSET s
0..0..1..solved at 4
0..0..1..solved at 4
val SUBSET_ANTISYM : thm = |- !s t. s SUBSET t /\ t SUBSET s ==> s = t
0..0..solved at 2
0..0..1..solved at 4
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
0..0..1..solved at 4
val SUBSET_ANTISYM_EQ : thm = |- !s t. s SUBSET t /\ t SUBSET s <=> s = t
val EMPTY_SUBSET : thm = |- !s. {} SUBSET s
val SUBSET_EMPTY : thm = |- !s. s SUBSET {} <=> s = {}
val SUBSET_UNIV : thm = |- !s. s SUBSET (:A)
val UNIV_SUBSET : thm = |- !s. (:A) SUBSET s <=> s = (:A)
Warning: inventing type variables
0..0..1..solved at 4
0..0..solved at 2
val SING_SUBSET : thm = |- !s x. {x} SUBSET s <=> x IN s
Warning: inventing type variables
val SUBSET_RESTRICT : thm = |- !s P. {x | x IN s /\ P x} SUBSET s
0..0..3..solved at 8
0..0..2..solved at 6
0..0..3..solved at 10
0..0..2..solved at 7
0..0..3..solved at 8
0..0..2..solved at 6
0..0..3..8..solved at 12
0..0..2..6..solved at 10
val PSUBSET_TRANS : thm =
  |- !s t u. s PSUBSET t /\ t PSUBSET u ==> s PSUBSET u
0..0..2..solved at 7
0..0..1..solved at 4
0..0..2..5..solved at 9
0..0..1..3..solved at 7
val PSUBSET_SUBSET_TRANS : thm =
  |- !s t u. s PSUBSET t /\ t SUBSET u ==> s PSUBSET u
0..0..2..solved at 7
0..0..1..solved at 5
0..0..2..6..solved at 10
0..0..1..3..solved at 7
val SUBSET_PSUBSET_TRANS : thm =
  |- !s t u. s SUBSET t /\ t PSUBSET u ==> s PSUBSET u
val PSUBSET_IRREFL : thm = |- !s. ~(s PSUBSET s)
0..0..solved at 2
val NOT_PSUBSET_EMPTY : thm = |- !s. ~(s PSUBSET {})
0..0..solved at 2
val NOT_UNIV_PSUBSET : thm = |- !s. ~((:A) PSUBSET s)
0..0..solved at 2
0..0..solved at 2
val PSUBSET_UNIV : thm = |- !s. s PSUBSET (:A) <=> (?x. ~(x IN s))
0..0..solved at 3
0..0..solved at 2
0..0..2..solved at 5
0..0..1..solved at 4
0..0..2..solved at 5
0..0..1..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..2..solved at 5
0..0..1..solved at 4
val PSUBSET_ALT : thm =
  |- !s t. s PSUBSET t <=> s SUBSET t /\ (?a. a IN t /\ ~(a IN s))
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 4
val UNION_ASSOC : thm = |- !s t u. (s UNION t) UNION u = s UNION t UNION u
val UNION_IDEMPOT : thm = |- !s. s UNION s = s
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
val UNION_COMM : thm = |- !s t. s UNION t = t UNION s
0..0..solved at 3
0..0..solved at 2
val SUBSET_UNION : thm =
  |- (!s t. s SUBSET s UNION t) /\ (!s t. s SUBSET t UNION s)
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
val SUBSET_UNION_ABSORPTION : thm = |- !s t. s SUBSET t <=> s UNION t = t
val UNION_EMPTY : thm = |- (!s. {} UNION s = s) /\ (!s. s UNION {} = s)
val UNION_UNIV : thm =
  |- (!s. (:A) UNION s = (:A)) /\ (!s. s UNION (:A) = (:A))
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
val EMPTY_UNION : thm = |- !s t. s UNION t = {} <=> s = {} /\ t = {}
Warning: inventing type variables
0..0..1..solved at 5
0..0..1..solved at 4
0..0..1..solved at 5
0..0..1..solved at 4
val UNION_SUBSET : thm =
  |- !s t u. s UNION t SUBSET u <=> s SUBSET u /\ t SUBSET u
0..0..2..solved at 7
0..0..2..solved at 5
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..2..4..solved at 8
val FORALL_SUBSET_UNION : thm =
  |- !t u.
         (!s. s SUBSET t UNION u ==> P s) <=>
         (!t' u'. t' SUBSET t /\ u' SUBSET u ==> P (t' UNION u'))
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
0..0..0..0..solved at 4
0..0..0..0..solved at 4
val EXISTS_SUBSET_UNION : thm =
  |- !t u.
         (?s. s SUBSET t UNION u /\ P s) <=>
         (?t' u'. t' SUBSET t /\ u' SUBSET u /\ P (t' UNION u'))
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..5..solved at 11
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
Warning: inventing type variables
0..0..1..2..7..12..solved at 26
0..0..1..2..solved at 6
0..0..1..3..9..17..46..solved at 96
0..0..1..solved at 4
val FORALL_SUBSET_INSERT : thm =
  |- !a t.
         (!s. s SUBSET a INSERT t ==> P s) <=>
         (!s. s SUBSET t ==> P s /\ P (a INSERT s))
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
0..0..0..solved at 5
0..0..0..solved at 3
0..0..0..solved at 5
0..0..0..solved at 3
val EXISTS_SUBSET_INSERT : thm =
  |- !a t.
         (?s. s SUBSET a INSERT t /\ P s) <=>
         (?s. s SUBSET t /\ (P s \/ P (a INSERT s)))
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val INTER_ASSOC : thm = |- !s t u. (s INTER t) INTER u = s INTER t INTER u
val INTER_IDEMPOT : thm = |- !s. s INTER s = s
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val INTER_COMM : thm = |- !s t. s INTER t = t INTER s
0..0..solved at 2
0..0..solved at 2
val INTER_SUBSET : thm =
  |- (!s t. s INTER t SUBSET s) /\ (!s t. t INTER s SUBSET s)
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
val SUBSET_INTER_ABSORPTION : thm = |- !s t. s SUBSET t <=> s INTER t = s
val INTER_EMPTY : thm = |- (!s. {} INTER s = {}) /\ (!s. s INTER {} = {})
val INTER_UNIV : thm = |- (!s. (:A) INTER s = s) /\ (!s. s INTER (:A) = s)
Warning: inventing type variables
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
val SUBSET_INTER : thm =
  |- !s t u. s SUBSET t INTER u <=> s SUBSET t /\ s SUBSET u
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val UNION_OVER_INTER : thm =
  |- !s t u. s INTER (t UNION u) = s INTER t UNION s INTER u
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val INTER_OVER_UNION : thm =
  |- !s t u. s UNION t INTER u = (s UNION t) INTER (s UNION u)
0..0..0..solved at 3
0..0..0..solved at 3
val IN_DISJOINT : thm = |- !s t. DISJOINT s t <=> ~(?x. x IN s /\ x IN t)
0..0..0..solved at 3
0..0..0..solved at 3
val DISJOINT_SYM : thm = |- !s t. DISJOINT s t <=> DISJOINT t s
val DISJOINT_EMPTY : thm = |- !s. DISJOINT {} s /\ DISJOINT s {}
val DISJOINT_EMPTY_REFL : thm = |- !s. s = {} <=> DISJOINT s s
0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..solved at 4
0..0..0..solved at 3
val DISJOINT_UNION : thm =
  |- !s t u. DISJOINT (s UNION t) u <=> DISJOINT s u /\ DISJOINT t u
val DIFF_EMPTY : thm = |- !s. s DIFF {} = s
val EMPTY_DIFF : thm = |- !s. {} DIFF s = {}
val DIFF_UNIV : thm = |- !s. s DIFF (:A) = {}
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val DIFF_DIFF : thm = |- !s t. s DIFF t DIFF t = s DIFF t
0..0..solved at 2
val DIFF_EQ_EMPTY : thm = |- !s. s DIFF s = {}
Warning: inventing type variables
0..0..solved at 3
val SUBSET_DIFF : thm = |- !s t. s DIFF t SUBSET s
val COMPONENT : thm = |- !x s. x IN x INSERT s
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
val DECOMPOSITION : thm =
  |- !s x. x IN s <=> (?t. s = x INSERT t /\ ~(x IN t))
0..0..1..5..16..36..114..solved at 121
val SET_CASES : thm = |- !s. s = {} \/ (?x t. s = x INSERT t /\ ~(x IN t))
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
val ABSORPTION : thm = |- !x s. x IN s <=> x INSERT s = s
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
val INSERT_INSERT : thm = |- !x s. x INSERT x INSERT s = x INSERT s
0..0..solved at 3
0..0..solved at 4
0..0..solved at 2
0..0..solved at 3
0..0..solved at 4
0..0..solved at 2
val INSERT_COMM : thm = |- !x y s. x INSERT y INSERT s = y INSERT x INSERT s
val INSERT_UNIV : thm = |- !x. x INSERT (:A) = (:A)
0..0..solved at 3
val NOT_INSERT_EMPTY : thm = |- !x s. ~(x INSERT s = {})
0..0..solved at 3
val NOT_EMPTY_INSERT : thm = |- !x s. ~({} = x INSERT s)
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 4
val INSERT_UNION : thm =
  |- !x s t.
         x INSERT s UNION t =
         (if x IN t then s UNION t else x INSERT (s UNION t))
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 4
val INSERT_UNION_EQ : thm =
  |- !x s t. x INSERT s UNION t = x INSERT (s UNION t)
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val INSERT_INTER : thm =
  |- !x s t.
         x INSERT s INTER t =
         (if x IN t then x INSERT (s INTER t) else s INTER t)
0..0..0..solved at 3
0..0..0..solved at 4
0..0..solved at 2
0..0..1..solved at 5
val DISJOINT_INSERT : thm =
  |- !x s t. DISJOINT (x INSERT s) t <=> DISJOINT s t /\ ~(x IN t)
0..0..1..solved at 5
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
val INSERT_SUBSET : thm =
  |- !x s t. x INSERT s SUBSET t <=> x IN t /\ s SUBSET t
0..0..2..4..12..21..solved at 31
0..0..3..solved at 6
val SUBSET_INSERT : thm =
  |- !x s. ~(x IN s) ==> (!t. s SUBSET x INSERT t <=> s SUBSET t)
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val INSERT_DIFF : thm =
  |- !s t x.
         x INSERT s DIFF t =
         (if x IN t then s DIFF t else x INSERT (s DIFF t))
Warning: inventing type variables
val INSERT_AC : thm =
  |- x INSERT y INSERT s = y INSERT x INSERT s /\
     x INSERT x INSERT s = x INSERT s
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val INTER_ACI : thm =
  |- p INTER q = q INTER p /\
     (p INTER q) INTER r = p INTER q INTER r /\
     p INTER q INTER r = q INTER p INTER r /\
     p INTER p = p /\
     p INTER p INTER q = p INTER q
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 4
0..0..solved at 3
0..0..solved at 4
0..0..solved at 2
0..0..solved at 3
0..0..solved at 4
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
val UNION_ACI : thm =
  |- p UNION q = q UNION p /\
     (p UNION q) UNION r = p UNION q UNION r /\
     p UNION q UNION r = q UNION p UNION r /\
     p UNION p = p /\
     p UNION p UNION q = p UNION q
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..0..solved at 3
val DELETE_NON_ELEMENT : thm = |- !x s. ~(x IN s) <=> s DELETE x = s
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val IN_DELETE_EQ : thm =
  |- !s x x'. (x IN s <=> x' IN s) <=> x IN s DELETE x' <=> x' IN s DELETE x
val EMPTY_DELETE : thm = |- !x. {} DELETE x = {}
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val DELETE_DELETE : thm = |- !x s. s DELETE x DELETE x = s DELETE x
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
val DELETE_COMM : thm = |- !x y s. s DELETE x DELETE y = s DELETE y DELETE x
0..0..solved at 3
val DELETE_SUBSET : thm = |- !x s. s DELETE x SUBSET s
0..0..0..solved at 3
0..0..1..solved at 4
0..0..2..solved at 5
0..0..solved at 2
val SUBSET_DELETE : thm =
  |- !x s t. s SUBSET t DELETE x <=> ~(x IN s) /\ s SUBSET t
0..0..2..4..solved at 8
0..0..2..4..solved at 8
val SUBSET_INSERT_DELETE : thm =
  |- !x s t. s SUBSET x INSERT t <=> s DELETE x SUBSET t
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
val DIFF_INSERT : thm = |- !s t x. s DIFF x INSERT t = s DELETE x DIFF t
0..0..solved at 2
0..0..1..3..9..18..34..59..100..167..solved at 240
0..0..1..solved at 4
0..0..solved at 2
0..0..2..solved at 5
0..0..1..3..solved at 7
val PSUBSET_INSERT_SUBSET : thm =
  |- !s t. s PSUBSET t <=> (?x. ~(x IN s) /\ x INSERT s SUBSET t)
0..0..solved at 3
0..0..solved at 2
0..0..2..solved at 5
0..0..1..solved at 4
0..0..2..solved at 5
0..0..1..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..2..solved at 5
0..0..1..solved at 4
val PSUBSET_MEMBER : thm =
  |- !s t. s PSUBSET t <=> s SUBSET t /\ (?y. y IN t /\ ~(y IN s))
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val DELETE_INSERT : thm =
  |- !x y s.
         (x INSERT s) DELETE y =
         (if x = y then s DELETE y else x INSERT (s DELETE y))
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val INSERT_DELETE : thm = |- !x s. x IN s ==> x INSERT (s DELETE x) = s
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val DELETE_INTER : thm = |- !s t x. s DELETE x INTER t = (s INTER t) DELETE x
0..0..1..2..solved at 6
0..0..1..2..solved at 6
val DISJOINT_DELETE_SYM : thm =
  |- !s t x. DISJOINT (s DELETE x) t <=> DISJOINT (t DELETE x) s
Warning: inventing type variables
val UNIONS_0 : thm = |- UNIONS {} = {}
Warning: inventing type variables
0..0..solved at 2
0..0..0..solved at 3
val UNIONS_1 : thm = |- UNIONS {s} = s
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..0..solved at 5
0..0..0..solved at 3
val UNIONS_2 : thm = |- UNIONS {s, t} = s UNION t
Warning: inventing type variables
0..0..solved at 2
0..0..1..solved at 5
0..0..0..solved at 4
0..0..0..solved at 3
val UNIONS_INSERT : thm = |- UNIONS (s INSERT u) = s UNION UNIONS u
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..2..solved at 6
val FORALL_IN_UNIONS : thm =
  |- !P s. (!x. x IN UNIONS s ==> P x) <=> (!t x. t IN s /\ x IN t ==> P x)
Warning: inventing type variables
0..0..0..0..solved at 4
0..0..0..0..solved at 4
val EXISTS_IN_UNIONS : thm =
  |- !P s. (?x. x IN UNIONS s /\ P x) <=> (?t x. t IN s /\ x IN t /\ P x)
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
val EMPTY_UNIONS : thm = |- !s. UNIONS s = {} <=> (!t. t IN s ==> t = {})
Warning: inventing type variables
0..0..0..0..3..11..solved at 23
0..0..0..2..solved at 7
0..0..1..solved at 4
0..0..0..0..3..11..solved at 23
0..0..1..solved at 5
0..0..0..2..solved at 6
val INTER_UNIONS : thm =
  |- (!s t. UNIONS s INTER t = UNIONS {x INTER t | x IN s}) /\
     (!s t. t INTER UNIONS s = UNIONS {t INTER x | x IN s})
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..2..solved at 6
val UNIONS_SUBSET : thm =
  |- !f t. UNIONS f SUBSET t <=> (!s. s IN f ==> s SUBSET t)
Warning: inventing type variables
0..0..0..1..solved at 5
val SUBSET_UNIONS : thm = |- !f g. f SUBSET g ==> UNIONS f SUBSET UNIONS g
Warning: inventing type variables
0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..solved at 4
0..0..0..solved at 3
val UNIONS_UNION : thm =
  |- !s t. UNIONS (s UNION t) = UNIONS s UNION UNIONS t
Warning: inventing type variables
0..0..1..solved at 5
0..0..1..solved at 4
0..0..1..solved at 5
0..0..1..solved at 4
val INTERS_UNION : thm =
  |- !s t. INTERS (s UNION t) = INTERS s INTER INTERS t
Warning: inventing type variables
0..0..0..1..3..5..solved at 11
val UNIONS_MONO : thm =
  |- (!x. x IN s ==> (?y. y IN t /\ x SUBSET y)) ==> UNIONS s SUBSET UNIONS t
Warning: inventing type variables
0..0..0..0..3..8..solved at 14
val UNIONS_MONO_IMAGE : thm =
  |- (!x. x IN s ==> f x SUBSET g x)
     ==> UNIONS (IMAGE f s) SUBSET UNIONS (IMAGE g s)
val INTERS_0 : thm = |- INTERS {} = (:A)
Warning: inventing type variables
0..0..1..solved at 4
0..0..solved at 2
val INTERS_1 : thm = |- INTERS {s} = s
Warning: inventing type variables
0..0..1..solved at 5
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
val INTERS_2 : thm = |- INTERS {s, t} = s INTER t
Warning: inventing type variables
0..0..1..solved at 5
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
val INTERS_INSERT : thm = |- INTERS (s INSERT u) = s INTER INTERS u
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..2..solved at 6
val SUBSET_INTERS : thm =
  |- !s f. s SUBSET INTERS f <=> (!t. t IN f ==> s SUBSET t)
Warning: inventing type variables
0..0..solved at 2
0..0..1..solved at 6
0..0..0..solved at 4
0..0..0..solved at 3
val IMAGE_CLAUSES : thm =
  |- IMAGE f {} = {} /\ IMAGE f (x INSERT s) = f x INSERT IMAGE f s
Warning: inventing type variables
0..0..0..solved at 5
0..0..0..solved at 3
0..0..0..solved at 5
0..0..0..solved at 3
val IMAGE_UNION : thm =
  |- !f s t. IMAGE f (s UNION t) = IMAGE f s UNION IMAGE f t
Warning: inventing type variables
val IMAGE_ID : thm = |- !s. IMAGE (\x. x) s = s
Warning: inventing type variables
val IMAGE_I : thm = |- !s. IMAGE I s = s
Warning: inventing type variables
0..0..0..0..solved at 4
0..0..0..solved at 3
val IMAGE_o : thm = |- !f g s. IMAGE (f o g) s = IMAGE f (IMAGE g s)
Warning: inventing type variables
0..0..0..2..solved at 6
val IMAGE_SUBSET : thm = |- !f s t. s SUBSET t ==> IMAGE f s SUBSET IMAGE f t
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
0..0..0..0..4..10..16..31..solved at 42
val IMAGE_INTER_INJ : thm =
  |- !f s t.
         (!x y. f x = f y ==> x = y)
         ==> IMAGE f (s INTER t) = IMAGE f s INTER IMAGE f t
Warning: inventing type variables
0..0..1..solved at 5
0..0..1..2..3..7..solved at 16
0..0..0..2..4..solved at 9
val IMAGE_DIFF_INJ : thm =
  |- !f s t.
         (!x y. f x = f y ==> x = y)
         ==> IMAGE f (s DIFF t) = IMAGE f s DIFF IMAGE f t
Warning: inventing type variables
0..0..1..solved at 6
0..0..1..3..7..solved at 12
0..0..1..3..7..solved at 12
val IMAGE_DELETE_INJ : thm =
  |- !f s a.
         (!x. f x = f a ==> x = a)
         ==> IMAGE f (s DELETE a) = IMAGE f s DELETE f a
Warning: inventing type variables
0..0..0..solved at 3
0..0..solved at 2
val IMAGE_EQ_EMPTY : thm = |- !f s. IMAGE f s = {} <=> s = {}
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..solved at 4
val FORALL_IN_IMAGE : thm =
  |- !f s. (!y. y IN IMAGE f s ==> P y) <=> (!x. x IN s ==> P (f x))
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..0..solved at 4
val EXISTS_IN_IMAGE : thm =
  |- !f s. (?y. y IN IMAGE f s /\ P y) <=> (?x. x IN s /\ P (f x))
0..0..1..solved at 4
0..0..solved at 2
0..0..0..0..1..2..3..6..11..19..solved at 31
0..0..solved at 2
val SUBSET_IMAGE : thm =
  |- !f s t. s SUBSET IMAGE f t <=> (?u. u SUBSET t /\ s = IMAGE f u)
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..solved at 4
val FORALL_SUBSET_IMAGE : thm =
  |- !P f s.
         (!t. t SUBSET IMAGE f s ==> P t) <=>
         (!t. t SUBSET s ==> P (IMAGE f t))
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..0..solved at 4
val EXISTS_SUBSET_IMAGE : thm =
  |- !P f s.
         (?t. t SUBSET IMAGE f s /\ P t) <=>
         (?t. t SUBSET s /\ P (IMAGE f t))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..2..solved at 5
val IMAGE_CONST : thm =
  |- !s c. IMAGE (\x. c) s = (if s = {} then {} else {c})
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
val SIMPLE_IMAGE : thm = |- !f s. {f x | x IN s} = IMAGE f s
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
val SIMPLE_IMAGE_GEN : thm = |- !f P. {f x | P x} = IMAGE f {x | P x}
Warning: inventing type variables
0..0..0..0..solved at 4
0..0..0..0..solved at 4
val IMAGE_UNIONS : thm =
  |- !f s. IMAGE f (UNIONS s) = UNIONS (IMAGE (IMAGE f) s)
Warning: inventing type variables
0..0..0..solved at 3
val FUN_IN_IMAGE : thm = |- !f s x. x IN s ==> f x IN IMAGE f s
Warning: inventing type variables
0..0..1..solved at 4
0..0..0..1..2..3..5..7..9..15..21..27..solved at 44
val SURJECTIVE_IMAGE_EQ : thm =
  |- !s t.
         (!y. y IN t ==> (?x. f x = y)) /\ (!x. f x IN t <=> x IN s)
         ==> IMAGE f s = t
Warning: inventing type variables
val EMPTY_GSPEC : thm = |- {x | F} = {}
Warning: inventing type variables
val UNIV_GSPEC : thm = |- {x | T} = (:?52305)
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
val SING_GSPEC : thm = |- (!a. {x | x = a} = {a}) /\ (!a. {x | a = x} = {a})
Warning: inventing type variables
0..0..1..2..3..7..12..17..28..39..50..77..104..131..solved at 160
0..0..0..solved at 3
val IN_ELIM_PAIR_THM : thm = |- !P a b. a,b IN {x,y | P x y} <=> P a b
Warning: inventing type variables
val SET_PAIR_THM : thm = |- !P. {p | P p} = {a,b | P (a,b)}
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..solved at 4
0..0..1..2..solved at 6
0..0..1..solved at 4
0..0..1..2..solved at 6
0..0..1..solved at 4
0..0..1..2..solved at 6
0..0..1..solved at 4
val FORALL_IN_GSPEC : thm =
  |- (!P f. (!z. z IN {f x | P x} ==> Q z) <=> (!x. P x ==> Q (f x))) /\
     (!P f.
          (!z. z IN {f x y | P x y} ==> Q z) <=> (!x y. P x y ==> Q (f x y))) /\
     (!P f.
          (!z. z IN {f w x y | P w x y} ==> Q z) <=>
          (!w x y. P w x y ==> Q (f w x y))) /\
     (!P f.
          (!z. z IN {f v w x y | P v w x y} ==> Q z) <=>
          (!v w x y. P v w x y ==> Q (f v w x y)))
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..0..solved at 4
val EXISTS_IN_GSPEC : thm =
  |- (!P f. (?z. z IN {f x | P x} /\ Q z) <=> (?x. P x /\ Q (f x))) /\
     (!P f. (?z. z IN {f x y | P x y} /\ Q z) <=> (?x y. P x y /\ Q (f x y))) /\
     (!P f.
          (?z. z IN {f w x y | P w x y} /\ Q z) <=>
          (?w x y. P w x y /\ Q (f w x y))) /\
     (!P f.
          (?z. z IN {f v w x y | P v w x y} /\ Q z) <=>
          (?v w x y. P v w x y /\ Q (f v w x y)))
0..0..1..2..5..9..15..25..40..66..123..229..496..solved at 530
val SET_PROVE_CASES : thm =
  |- !P. P {} /\ (!a s. ~(a IN s) ==> P (a INSERT s)) ==> (!s. P s)
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..0..solved at 4
val UNIONS_IMAGE : thm =
  |- !f s. UNIONS (IMAGE f s) = {y | ?x. x IN s /\ y IN f x}
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..solved at 4
val INTERS_IMAGE : thm =
  |- !f s. INTERS (IMAGE f s) = {y | !x. x IN s ==> y IN f x}
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..0..solved at 4
val UNIONS_GSPEC : thm =
  |- (!P f. UNIONS {f x | P x} = {a | ?x. P x /\ a IN f x}) /\
     (!P f. UNIONS {f x y | P x y} = {a | ?x y. P x y /\ a IN f x y}) /\
     (!P f.
          UNIONS {f x y z | P x y z} = {a | ?x y z. P x y z /\ a IN f x y z})
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..solved at 4
0..0..1..2..solved at 6
0..0..1..solved at 4
0..0..1..2..solved at 6
0..0..1..solved at 4
val INTERS_GSPEC : thm =
  |- (!P f. INTERS {f x | P x} = {a | !x. P x ==> a IN f x}) /\
     (!P f. INTERS {f x y | P x y} = {a | !x y. P x y ==> a IN f x y}) /\
     (!P f.
          INTERS {f x y z | P x y z} = {a | !x y z. P x y z ==> a IN f x y z})
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..solved at 2
0..0..1..solved at 4
val DIFF_INTERS : thm = |- !u s. u DIFF INTERS s = UNIONS {u DIFF t | t IN s}
Warning: inventing type variables
val INTERS_UNIONS : thm =
  |- !s. INTERS s = (:?53528) DIFF UNIONS {(:?53528) DIFF t | t IN s}
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
val UNIONS_INTERS : thm =
  |- !s. UNIONS s = (:?53563) DIFF INTERS {(:?53563) DIFF t | t IN s}
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..solved at 5
0..0..solved at 2
val UNIONS_DIFF : thm = |- !s t. UNIONS s DIFF t = UNIONS {x DIFF t | x IN s}
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..0..solved at 3
0..0..solved at 2
0..0..0..solved at 3
val DIFF_UNIONS : thm =
  |- !u s. u DIFF UNIONS s = u INTER INTERS {u DIFF t | t IN s}
Warning: inventing type variables
0..0..solved at 2
0..0..0..solved at 3
0..0..1..solved at 4
0..0..0..solved at 3
val DIFF_UNIONS_NONEMPTY : thm =
  |- !u s. ~(s = {}) ==> u DIFF UNIONS s = INTERS {u DIFF t | t IN s}
0..0..0..1..2..3..6..9..12..solved at 20
0..0..0..1..2..3..solved at 8
val INTERS_OVER_UNIONS : thm =
  |- !f s.
         INTERS {UNIONS (f x) | x IN s} =
         UNIONS {INTERS {g x | x IN s} | g | !x. x IN s ==> g x IN f x}
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val FINITE_INDUCT_STRONG : thm =
  |- !P. P {} /\ (!x s. P s /\ ~(x IN s) /\ FINITE s ==> P (x INSERT s))
         ==> (!s. FINITE s ==> P s)
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..1..2..5..solved at 13
0..0..solved at 2
0..0..1..2..5..solved at 13
val INJECTIVE_ON_ALT : thm =
  |- !P f.
         (!x y. P x /\ P y /\ f x = f y ==> x = y) <=>
         (!x y. P x /\ P y ==> (f x = f y <=> x = y))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
val INJECTIVE_ALT : thm =
  |- !f. (!x y. f x = f y ==> x = y) <=> (!x y. f x = f y <=> x = y)
Warning: inventing type variables
val SURJECTIVE_ON_RIGHT_INVERSE : thm =
  |- !f t.
         (!y. y IN t ==> (?x. x IN s /\ f x = y)) <=>
         (?g. !y. y IN t ==> g y IN s /\ f (g y) = y)
Warning: inventing type variables
0..0..1..solved at 4
0..0..1..2..solved at 6
Warning: inventing type variables
0..0..1..3..8..21..46..solved at 96
0..0..1..2..5..9..15..22..29..36..solved at 45
val INJECTIVE_ON_LEFT_INVERSE : thm =
  |- !f s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) <=>
         (?g. !x. x IN s ==> g (f x) = x)
Warning: inventing type variables
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..2..5..9..15..29..44..68..108..150..213..348..523..solved at 570
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
val BIJECTIVE_ON_LEFT_RIGHT_INVERSE : thm =
  |- !f s t.
         (!x. x IN s ==> f x IN t)
         ==> ((!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) /\
              (!y. y IN t ==> (?x. x IN s /\ f x = y)) <=>
              (?g. (!y. y IN t ==> g y IN s) /\
                   (!y. y IN t ==> f (g y) = y) /\
                   (!x. x IN s ==> g (f x) = x)))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
val SURJECTIVE_RIGHT_INVERSE : thm =
  |- (!y. ?x. f x = y) <=> (?g. !y. f (g y) = y)
Warning: inventing type variables
val INJECTIVE_LEFT_INVERSE : thm =
  |- (!x y. f x = f y ==> x = y) <=> (?g. !x. g (f x) = x)
val BIJECTIVE_LEFT_RIGHT_INVERSE : thm =
  |- !f. (!x y. f x = f y ==> x = y) /\ (!y. ?x. f x = y) <=>
         (?g. (!y. f (g y) = y) /\ (!x. g (f x) = x))
Warning: inventing type variables
0..0..1..solved at 4
0..0..1..2..solved at 6
Warning: inventing type variables
0..0..1..3..8..18..40..86..solved at 175
0..0..1..3..7..15..26..46..68..96..129..166..207..268..333..414..solved at 465
val FUNCTION_FACTORS_LEFT_GEN : thm =
  |- !P f g.
         (!x y. P x /\ P y /\ g x = g y ==> f x = f y) <=>
         (?h. !x. P x ==> f x = h (g x))
Warning: inventing type variables
Warning: inventing type variables
val FUNCTION_FACTORS_LEFT : thm =
  |- !f g. (!x y. g x = g y ==> f x = f y) <=> (?h. f = h o g)
Warning: inventing type variables
0..0..1..2..5..solved at 11
0..0..1..2..5..solved at 11
val FUNCTION_FACTORS_RIGHT_GEN : thm =
  |- !P f g.
         (!x. P x ==> (?y. g y = f x)) <=> (?h. !x. P x ==> f x = g (h x))
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..2..solved at 6
val FUNCTION_FACTORS_RIGHT : thm =
  |- !f g. (!x. ?y. g y = f x) <=> (?h. f = g o h)
0..0..1..2..solved at 6
0..0..solved at 2
0..0..solved at 2
val SURJECTIVE_FORALL_THM : thm =
  |- !f. (!y. ?x. f x = y) <=> (!P. (!x. P (f x)) <=> (!y. P y))
0..0..solved at 2
0..0..1..2..6..11..solved at 22
0..0..solved at 3
0..0..solved at 2
val SURJECTIVE_EXISTS_THM : thm =
  |- !f. (!y. ?x. f x = y) <=> (!P. (?x. P (f x)) <=> (?y. P y))
0..0..solved at 2
0..0..0..1..2..3..4..5..6..solved at 20
0..0..1..2..solved at 6
val SURJECTIVE_IMAGE_THM : thm =
  |- !f. (!y. ?x. f x = y) <=> (!P. IMAGE f {x | P (f x)} = {x | P x})
0..0..0..solved at 3
0..0..1..2..solved at 6
0..0..0..0..0..2..9..20..46..solved at 72
0..0..0..2..6..solved at 11
0..0..1..3..8..17..33..59..98..146..217..solved at 276
val IMAGE_INJECTIVE_IMAGE_OF_SUBSET : thm =
  |- !f s.
         ?t. t SUBSET s /\
             IMAGE f s = IMAGE f t /\
             (!x y. x IN t /\ y IN t /\ f x = f y ==> x = y)
Warning: inventing type variables
val FINITE_EMPTY : thm = |- FINITE {}
0..0..1..2..5..9..15..solved at 24
0..0..2..4..solved at 8
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..2..4..12..21..solved at 31
val FINITE_SUBSET : thm = |- !s t. FINITE t /\ s SUBSET t ==> FINITE s
0..0..1..2..solved at 6
val FINITE_RESTRICT : thm = |- !s P. FINITE s ==> FINITE {x | x IN s /\ P x}
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 4
0..0..1..3..solved at 7
val FINITE_UNION_IMP : thm =
  |- !s t. FINITE s /\ FINITE t ==> FINITE (s UNION t)
0..0..solved at 3
0..0..solved at 2
val FINITE_UNION : thm = |- !s t. FINITE (s UNION t) <=> FINITE s /\ FINITE t
0..0..1..2..solved at 6
0..0..1..2..solved at 6
val FINITE_INTER : thm = |- !s t. FINITE s \/ FINITE t ==> FINITE (s INTER t)
0..0..solved at 2
val FINITE_INSERT : thm = |- !s x. FINITE (x INSERT s) <=> FINITE s
Warning: inventing type variables
val FINITE_SING : thm = |- !a. FINITE {a}
0..0..0..4..solved at 10
val FINITE_DELETE_IMP : thm = |- !s x. FINITE s ==> FINITE (s DELETE x)
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val FINITE_DELETE : thm = |- !s x. FINITE (s DELETE x) <=> FINITE s
Warning: inventing type variables
0..0..solved at 2
0..0..1..solved at 4
0..0..1..solved at 5
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..3..solved at 7
0..0..3..solved at 9
val FINITE_FINITE_UNIONS : thm =
  |- !s. FINITE s ==> (FINITE (UNIONS s) <=> (!t. t IN s ==> FINITE t))
0..0..solved at 2
0..0..1..solved at 6
0..0..0..solved at 3
0..0..0..solved at 4
val FINITE_IMAGE_EXPAND : thm =
  |- !f s. FINITE s ==> FINITE {y | ?x. x IN s /\ y = f x}
val FINITE_IMAGE : thm = |- !f s. FINITE s ==> FINITE (IMAGE f s)
0..0..0..1..3..7..solved at 14
val FINITE_IMAGE_INJ_GENERAL : thm =
  |- !f A s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) /\ FINITE A
         ==> FINITE {x | x IN s /\ f x IN A}
0..0..0..0..solved at 4
0..0..solved at 2
0..0..solved at 2
val FINITE_FINITE_PREIMAGE_GENERAL : thm =
  |- !f s t.
         FINITE t /\ (!y. y IN t ==> FINITE {x | x IN s /\ f x = y})
         ==> FINITE {x | x IN s /\ f x IN t}
val FINITE_FINITE_PREIMAGE : thm =
  |- !f t.
         FINITE t /\ (!y. y IN t ==> FINITE {x | f x = y})
         ==> FINITE {x | f x IN t}
0..0..solved at 2
0..0..solved at 2
0..0..0..solved at 3
val FINITE_IMAGE_INJ_EQ : thm =
  |- !f s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
         ==> (FINITE (IMAGE f s) <=> FINITE s)
val FINITE_IMAGE_INJ : thm =
  |- !f A. (!x y. f x = f y ==> x = y) /\ FINITE A ==> FINITE {x | f x IN A}
0..0..0..solved at 3
val INFINITE_IMAGE_INJ : thm =
  |- !f. (!x y. f x = f y ==> x = y)
         ==> (!s. INFINITE s ==> INFINITE (IMAGE f s))
Warning: inventing type variables
0..0..0..solved at 3
val INFINITE_NONEMPTY : thm = |- !s. INFINITE s ==> ~(s = {})
0..0..solved at 2
0..0..solved at 2
val INFINITE_DIFF_FINITE : thm =
  |- !s t. INFINITE s /\ FINITE t ==> INFINITE (s DIFF t)
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..2..5..11..18..30..47..64..100..164..229..solved at 260
0..0..0..2..4..8..15..25..36..52..71..99..148..216..304..431..solved at 473
0..0..1..2..4..9..17..32..57..89..138..228..321..452..649..887..1226..1746..2324..3091..solved at 3446
val FINITE_SUBSET_IMAGE : thm =
  |- !f s t.
         FINITE t /\ t SUBSET IMAGE f s <=>
         (?s'. FINITE s' /\ s' SUBSET s /\ t = IMAGE f s')
Warning: inventing type variables
0..0..0..0..solved at 4
0..0..0..0..0..solved at 5
val EXISTS_FINITE_SUBSET_IMAGE : thm =
  |- !P f s.
         (?t. FINITE t /\ t SUBSET IMAGE f s /\ P t) <=>
         (?t. FINITE t /\ t SUBSET s /\ P (IMAGE f t))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
val FORALL_FINITE_SUBSET_IMAGE : thm =
  |- !P f s.
         (!t. FINITE t /\ t SUBSET IMAGE f s ==> P t) <=>
         (!t. FINITE t /\ t SUBSET s ==> P (IMAGE f t))
0..0..0..0..1..4..9..17..26..35..50..65..105..solved at 128
val FINITE_SUBSET_IMAGE_IMP : thm =
  |- !f s t.
         FINITE t /\ t SUBSET IMAGE f s
         ==> (?s'. FINITE s' /\ s' SUBSET s /\ t SUBSET IMAGE f s')
Warning: inventing type variables
0..0..1..2..solved at 6
val FINITE_DIFF : thm = |- !s t. FINITE s ==> FINITE (s DIFF t)
Warning: inventing type variables
0..0..1..2..solved at 6
val INFINITE_SUPERSET : thm =
  |- !s t. INFINITE s /\ s SUBSET t ==> INFINITE t
0..0..solved at 2
0..0..solved at 2
0..0..3..6..solved at 10
0..0..3..6..solved at 10
0..0..2..6..11..23..47..91..186..333..537..880..1386..2121..3496..5629..8957..14874..24097..37962..solved at 40441
0..0..2..7..13..27..57..114..242..439..707..1140..1754..2620..4198..6611..10369..17055..27259..42383..solved at 45658
0..0..3..6..13..31..58..118..solved at 181
0..0..solved at 2
val FINITE_TRANSITIVITY_CHAIN : thm =
  |- !R s.
         FINITE s /\
         (!x. ~R x x) /\
         (!x y z. R x y /\ R y z ==> R x z) /\
         (!x. x IN s ==> (?y. y IN s /\ R x y))
         ==> s = {}
0..0..3..solved at 8
0..0..2..solved at 6
0..0..3..solved at 11
0..0..2..solved at 8
0..0..3..solved at 8
0..0..2..solved at 6
0..0..3..10..solved at 14
0..0..2..8..solved at 12
0..0..0..2..solved at 6
0..0..0..1..7..18..40..73..113..191..298..467..830..solved at 1350
val UNIONS_MAXIMAL_SETS : thm =
  |- !f. FINITE f
         ==> UNIONS {t | t IN f /\ (!u. u IN f ==> ~(t PSUBSET u))} =
             UNIONS f
val FINREC : thm =
  |- (FINREC f b s a 0 <=> s = {} /\ a = b) /\
     (FINREC f b s a (SUC n) <=>
      (?x c. x IN s /\ FINREC f b (s DELETE x) c n /\ a = f x c))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..0..0..1..5..11..solved at 19
val FINREC_1_LEMMA : thm =
  |- !f b s a. FINREC f b s a (SUC 0) <=> (?x. s = {x} /\ a = f x b)
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val FINREC_SUC_LEMMA : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> (!n s z.
                  FINREC f b s z (SUC n)
                  ==> (!x. x IN s
                           ==> (?w. FINREC f b (s DELETE x) w n /\ z = f x w)))
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..1..2..7..13..23..34..45..56..80..104..141..237..solved at 327
0..0..1..3..7..17..solved at 23
val FINREC_UNIQUE_LEMMA : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> (!n1 n2 s a1 a2.
                  FINREC f b s a1 n1 /\ FINREC f b s a2 n2
                  ==> a1 = a2 /\ n1 = n2)
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val FINREC_EXISTS_LEMMA : thm =
  |- !f b s. FINITE s ==> (?a n. FINREC f b s a n)
0..0..1..2..solved at 6
0..0..solved at 2
0..0..1..solved at 4
val FINREC_FUN_LEMMA : thm =
  |- !P R.
         (!s. P s ==> (?a n. R s a n)) /\
         (!n1 n2 s a1 a2. R s a1 n1 /\ R s a2 n2 ==> a1 = a2 /\ n1 = n2)
         ==> (?f. !s a. P s ==> ((?n. R s a n) <=> f s = a))
0..0..solved at 3
val FINREC_FUN : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> (?g. g {} = b /\
                  (!s x. FINITE s /\ x IN s ==> g s = f x (g (s DELETE x))))
0..0..2..solved at 5
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val SET_RECURSION_LEMMA : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> (?g. g {} = b /\
                  (!x s.
                       FINITE s
                       ==> g (x INSERT s) =
                           (if x IN s then g s else f x (g s))))
Warning: inventing type variables
val ITSET : thm =
  |- !b f s.
         ITSET f s b =
         (@g. g {} = b /\
              (!x s.
                   FINITE s
                   ==> g (x INSERT s) = (if x IN s then g s else f x (g s))))
         s
val FINITE_RECURSION : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> ITSET f {} b = b /\
             (!x s.
                  FINITE s
                  ==> ITSET f (x INSERT s) b =
                      (if x IN s then ITSET f s b else f x (ITSET f s b)))
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
val FINITE_RECURSION_DELETE : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> ITSET f {} b = b /\
             (!x s.
                  FINITE s
                  ==> ITSET f s b =
                      (if x IN s
                       then f x (ITSET f (s DELETE x) b)
                       else ITSET f (s DELETE x) b))
Warning: inventing type variables
0..0..2..solved at 5
0..0..3..solved at 6
0..0..3..solved at 6
val ITSET_EQ : thm =
  |- !s f g b.
         FINITE s /\
         (!x. x IN s ==> f x = g x) /\
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s)) /\
         (!x y s. ~(x = y) ==> g x (g y s) = g y (g x s))
         ==> ITSET f s b = ITSET g s b
Warning: inventing type variables
val CARD : thm = |- !s. CARD s = ITSET (\x n. SUC n) s 0
val CARD_CLAUSES : thm =
  |- CARD {} = 0 /\
     (!x s.
          FINITE s
          ==> CARD (x INSERT s) = (if x IN s then CARD s else SUC (CARD s)))
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 4
0..0..0..solved at 4
0..0..0..solved at 3
val CARD_UNION : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ s INTER t = {}
         ==> CARD (s UNION t) = CARD s + CARD t
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val CARD_DELETE : thm =
  |- !x s.
         FINITE s
         ==> CARD (s DELETE x) = (if x IN s then CARD s - 1 else CARD s)
Warning: inventing type variables
0..0..1..2..5..9..15..25..35..47..67..87..114..solved at 152
val CARD_UNION_EQ : thm =
  |- !s t u.
         FINITE u /\ s INTER t = {} /\ s UNION t = u
         ==> CARD s + CARD t = CARD u
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 3
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
val CARD_DIFF : thm =
  |- !s t. FINITE s /\ t SUBSET s ==> CARD (s DIFF t) = CARD s - CARD t
Warning: inventing type variables
val CARD_EQ_0 : thm = |- !s. FINITE s ==> (CARD s = 0 <=> s = {})
val CARD_SING : thm = |- !a. CARD {a} = 1
val FINITE_INDUCT_DELETE : thm =
  |- !P. P {} /\
         (!s. FINITE s /\ ~(s = {})
              ==> (?x. x IN s /\ (P (s DELETE x) ==> P s)))
         ==> (!s. FINITE s ==> P s)
Warning: inventing type variables
val HAS_SIZE : thm = |- !s n. s HAS_SIZE n <=> FINITE s /\ CARD s = n
Warning: inventing type variables
val HAS_SIZE_CARD : thm = |- !s n. s HAS_SIZE n ==> CARD s = n
val HAS_SIZE_0 : thm = |- !s. s HAS_SIZE 0 <=> s = {}
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..2..4..10..18..30..48..66..88..solved at 99
val HAS_SIZE_SUC : thm =
  |- !s n.
         s HAS_SIZE SUC n <=>
         ~(s = {}) /\ (!a. a IN s ==> s DELETE a HAS_SIZE n)
Warning: inventing type variables
val HAS_SIZE_UNION : thm =
  |- !s t m n.
         s HAS_SIZE m /\ t HAS_SIZE n /\ DISJOINT s t
         ==> s UNION t HAS_SIZE m + n
Warning: inventing type variables
val HAS_SIZE_DIFF : thm =
  |- !s t m n.
         s HAS_SIZE m /\ t HAS_SIZE n /\ t SUBSET s
         ==> s DIFF t HAS_SIZE m - n
Warning: inventing type variables
0..0..0..0..solved at 4
0..0..0..0..solved at 4
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..solved at 7
0..0..0..0..solved at 5
0..0..0..0..solved at 4
0..0..2..4..7..17..31..66..117..228..383..696..1122..1957..solved at 2075
val HAS_SIZE_UNIONS : thm =
  |- !s t m n.
         s HAS_SIZE m /\
         (!x. x IN s ==> t x HAS_SIZE n) /\
         (!x y. x IN s /\ y IN s /\ ~(x = y) ==> DISJOINT (t x) (t y))
         ==> UNIONS {t x | x IN s} HAS_SIZE m * n
Warning: inventing type variables
val FINITE_HAS_SIZE : thm = |- !s. FINITE s <=> s HAS_SIZE CARD s
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
Warning: inventing type variables
0..0..0..2..8..20..49..103..solved at 184
val HAS_SIZE_CLAUSES : thm =
  |- (s HAS_SIZE 0 <=> s = {}) /\
     (s HAS_SIZE SUC n <=>
      (?a t. t HAS_SIZE n /\ ~(a IN t) /\ s = a INSERT t))
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
0..0..0..solved at 3
0..0..1..2..solved at 6
0..0..1..2..3..solved at 8
val HAS_SIZE_CONV : term -> thm = <fun>
0..0..1..2..solved at 6
0..0..solved at 3
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..1..solved at 4
val CARD_SUBSET_EQ : thm =
  |- !a b. FINITE b /\ a SUBSET b /\ CARD a = CARD b ==> a = b
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
val CARD_SUBSET : thm = |- !a b. a SUBSET b /\ FINITE b ==> CARD a <= CARD b
0..0..1..2..5..12..22..37..56..solved at 74
val CARD_SUBSET_LE : thm =
  |- !a b. FINITE b /\ a SUBSET b /\ CARD b <= CARD a ==> a = b
Warning: inventing type variables
0..0..1..2..5..solved at 13
0..0..solved at 2
val SUBSET_CARD_EQ : thm =
  |- !s t. FINITE t /\ s SUBSET t ==> (CARD s = CARD t <=> s = t)
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..7..15..25..40..62..93..159..253..solved at 294
0..0..1..solved at 4
0..0..solved at 2
0..0..2..solved at 5
0..0..1..solved at 4
0..0..1..5..14..solved at 24
val CARD_PSUBSET : thm = |- !a b. a PSUBSET b /\ FINITE b ==> CARD a < CARD b
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
val CARD_UNION_LE : thm =
  |- !s t. FINITE s /\ FINITE t ==> CARD (s UNION t) <= CARD s + CARD t
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..solved at 7
0..0..0..0..solved at 5
0..0..0..0..solved at 4
Warning: inventing type variables
val CARD_UNIONS_LE : thm =
  |- !s t m n.
         s HAS_SIZE m /\ (!x. x IN s ==> FINITE (t x) /\ CARD (t x) <= n)
         ==> CARD (UNIONS {t x | x IN s}) <= m * n
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
Warning: inventing type variables
0..0..solved at 2
val CARD_UNION_GEN : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> CARD (s UNION t) = (CARD s + CARD t) - CARD (s INTER t)
Warning: inventing type variables
0..0..0..solved at 3
0..0..solved at 2
0..0..0..solved at 4
0..0..0..solved at 3
val CARD_UNION_OVERLAP_EQ : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> (CARD (s UNION t) = CARD s + CARD t <=> s INTER t = {})
Warning: inventing type variables
val CARD_UNION_OVERLAP : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ CARD (s UNION t) < CARD s + CARD t
         ==> ~(s INTER t = {})
0..0..3..6..16..33..60..123..solved at 148
0..0..2..4..10..20..35..77..136..243..470..842..1459..solved at 2793
0..0..3..9..24..59..112..228..solved at 259
0..0..2..solved at 5
val CARD_IMAGE_INJ : thm =
  |- !f s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) /\ FINITE s
         ==> CARD (IMAGE f s) = CARD s
0..0..1..2..9..21..47..87..161..241..405..578..951..1711..2759..solved at 3322
val HAS_SIZE_IMAGE_INJ : thm =
  |- !f s n.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) /\ s HAS_SIZE n
         ==> IMAGE f s HAS_SIZE n
val CARD_IMAGE_LE : thm = |- !f s. FINITE s ==> CARD (IMAGE f s) <= CARD s
0..0..0..1..2..3..8..solved at 16
0..0..1..solved at 4
0..0..1..2..5..9..15..23..solved at 37
0..0..solved at 2
val CARD_IMAGE_INJ_EQ : thm =
  |- !f s t.
         FINITE s /\
         (!x. x IN s ==> f x IN t) /\
         (!y. y IN t ==> (?!x. x IN s /\ f x = y))
         ==> CARD t = CARD s
Warning: inventing type variables
0..0..1..2..4..6..8..18..solved at 30
val CARD_SUBSET_IMAGE : thm =
  |- !f s t. FINITE t /\ s SUBSET IMAGE f t ==> CARD s <= CARD t
Warning: inventing type variables
val HAS_SIZE_IMAGE_INJ_EQ : thm =
  |- !f s n.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
         ==> (IMAGE f s HAS_SIZE n <=> s HAS_SIZE n)
0..0..1..2..9..21..47..87..161..241..405..578..951..1711..2759..solved at 3322
0..0..1..2..6..13..24..41..61..90..135..187..273..solved at 328
0..0..2..solved at 7
0..0..solved at 3
val CARD_IMAGE_EQ_INJ : thm =
  |- !f s.
         FINITE s
         ==> (CARD (IMAGE f s) = CARD s <=>
              (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
0..0..1..solved at 5
0..0..0..solved at 3
0..0..solved at 5
0..0..4..solved at 10
0..0..solved at 4
0..0..3..solved at 8
0..0..solved at 5
0..0..solved at 4
0..0..3..solved at 7
0..0..3..solved at 7
0..0..2..solved at 5
0..0..2..solved at 5
val CHOOSE_SUBSET_STRONG : thm =
  |- !n s. (FINITE s ==> n <= CARD s) ==> (?t. t SUBSET s /\ t HAS_SIZE n)
0..0..0..1..2..3..solved at 8
val CHOOSE_SUBSET : thm =
  |- !s. FINITE s ==> (!n. n <= CARD s ==> (?t. t SUBSET s /\ t HAS_SIZE n))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..1..4..14..41..solved at 109
0..0..1..4..14..41..solved at 109
0..0..solved at 4
0..0..solved at 3
0..0..2..solved at 7
0..0..2..solved at 6
0..0..1..solved at 5
0..0..1..solved at 4
0..0..1..solved at 5
0..0..0..solved at 3
val CHOOSE_SUBSET_BETWEEN : thm =
  |- !n s u.
         s SUBSET u /\ FINITE s /\ CARD s <= n /\ (FINITE u ==> n <= CARD u)
         ==> (?t. s SUBSET t /\ t SUBSET u /\ t HAS_SIZE n)
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..1..solved at 6
0..0..0..0..solved at 4
0..0..0..0..solved at 5
0..0..1..2..3..7..14..26..47..77..solved at 94
val HAS_SIZE_PRODUCT_DEPENDENT : thm =
  |- !s m t n.
         s HAS_SIZE m /\ (!x. x IN s ==> t x HAS_SIZE n)
         ==> {x,y | x IN s /\ y IN t x} HAS_SIZE m * n
0..0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..1..solved at 6
0..0..0..0..solved at 5
0..0..0..0..solved at 4
val FINITE_PRODUCT_DEPENDENT : thm =
  |- !f s t.
         FINITE s /\ (!x. x IN s ==> FINITE (t x))
         ==> FINITE {f x y | x IN s /\ y IN t x}
val FINITE_PRODUCT : thm =
  |- !s t. FINITE s /\ FINITE t ==> FINITE {x,y | x IN s /\ y IN t}
val CARD_PRODUCT : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> CARD {x,y | x IN s /\ y IN t} = CARD s * CARD t
val HAS_SIZE_PRODUCT : thm =
  |- !s m t n.
         s HAS_SIZE m /\ t HAS_SIZE n
         ==> {x,y | x IN s /\ y IN t} HAS_SIZE m * n
- : unit = ()
Warning: inventing type variables
val CROSS : thm = |- !s t. s CROSS t = {x,y | x IN s /\ y IN t}
Warning: inventing type variables
val IN_CROSS : thm = |- !x y s t. x,y IN s CROSS t <=> x IN s /\ y IN t
Warning: inventing type variables
val HAS_SIZE_CROSS : thm =
  |- !s t m n. s HAS_SIZE m /\ t HAS_SIZE n ==> s CROSS t HAS_SIZE m * n
Warning: inventing type variables
val FINITE_CROSS : thm = |- !s t. FINITE s /\ FINITE t ==> FINITE (s CROSS t)
Warning: inventing type variables
val CARD_CROSS : thm =
  |- !s t. FINITE s /\ FINITE t ==> CARD (s CROSS t) = CARD s * CARD t
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val CROSS_EQ_EMPTY : thm = |- !s t. s CROSS t = {} <=> s = {} \/ t = {}
val CROSS_UNIV : thm = |- (:A) CROSS (:B) = (:A#B)
0..0..solved at 2
0..0..solved at 2
0..0..4..8..solved at 12
0..0..2..solved at 6
0..0..2..solved at 5
0..0..solved at 2
0..0..3..solved at 6
0..0..4..solved at 7
0..0..2..6..14..46..85..182..345..630..solved at 708
val HAS_SIZE_FUNSPACE : thm =
  |- !d n t m s.
         s HAS_SIZE m /\ t HAS_SIZE n
         ==> {f | (!x. x IN s ==> f x IN t) /\ (!x. ~(x IN s) ==> f x = d)} HAS_SIZE
             n EXP m
Warning: inventing type variables
0..0..1..3..7..13..24..63..102..180..268..solved at 277
val CARD_FUNSPACE : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> CARD
             {f | (!x. x IN s ==> f x IN t) /\ (!x. ~(x IN s) ==> f x = d)} =
             CARD t EXP CARD s
Warning: inventing type variables
0..0..1..3..5..11..21..32..45..68..91..solved at 100
val FINITE_FUNSPACE : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> FINITE
             {f | (!x. x IN s ==> f x IN t) /\ (!x. ~(x IN s) ==> f x = d)}
val HAS_SIZE_FUNSPACE_UNIV : thm =
  |- !m n. (:A) HAS_SIZE m /\ (:B) HAS_SIZE n ==> (:A->B) HAS_SIZE n EXP m
0..0..1..3..7..13..24..55..86..143..207..solved at 216
val CARD_FUNSPACE_UNIV : thm =
  |- FINITE (:A) /\ FINITE (:B) ==> CARD (:A->B) = CARD (:B) EXP CARD (:A)
0..0..1..3..7..12..20..30..40..71..106..solved at 115
val FINITE_FUNSPACE_UNIV : thm =
  |- FINITE (:A) /\ FINITE (:B) ==> FINITE (:A->B)
val HAS_SIZE_BOOL : thm = |- (:bool) HAS_SIZE 2
0..0..1..solved at 4
val CARD_BOOL : thm = |- CARD (:bool) = 2
0..0..1..solved at 4
val FINITE_BOOL : thm = |- FINITE (:bool)
val HAS_SIZE_POWERSET : thm =
  |- !s n. s HAS_SIZE n ==> {t | t SUBSET s} HAS_SIZE 2 EXP n
0..0..1..3..8..14..solved at 20
val CARD_POWERSET : thm =
  |- !s. FINITE s ==> CARD {t | t SUBSET s} = 2 EXP CARD s
0..0..1..3..8..13..solved at 19
val FINITE_POWERSET : thm = |- !s. FINITE s ==> FINITE {t | t SUBSET s}
0..0..0..solved at 3
val FINITE_UNIONS : thm =
  |- !s. FINITE (UNIONS s) <=> FINITE s /\ (!t. t IN s ==> FINITE t)
Warning: inventing type variables
0..0..2..solved at 6
0..0..solved at 2
0..0..2..solved at 6
0..0..2..4..10..22..42..solved at 53
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..2..4..solved at 8
val POWERSET_CLAUSES : thm =
  |- {s | s SUBSET {}} = {{}} /\
     (!a t.
          {s | s SUBSET a INSERT t} =
          {s | s SUBSET t} UNION IMAGE (\s. a INSERT s) {s | s SUBSET t})
val HAS_SIZE_NUMSEG_LT : thm = |- !n. {m | m < n} HAS_SIZE n
val CARD_NUMSEG_LT : thm = |- !n. CARD {m | m < n} = n
val FINITE_NUMSEG_LT : thm = |- !n. FINITE {m | m < n}
val HAS_SIZE_NUMSEG_LE : thm = |- !n. {m | m <= n} HAS_SIZE n + 1
val FINITE_NUMSEG_LE : thm = |- !n. FINITE {m | m <= n}
val CARD_NUMSEG_LE : thm = |- !n. CARD {m | m <= n} = n + 1
0..0..2..7..14..32..82..191..466..1144..2508..5758..13277..28479..solved at 31328
val num_FINITE : thm = |- !s. FINITE s <=> (?a. !x. x IN s ==> x <= a)
0..0..1..4..8..15..solved at 34
val num_FINITE_AVOID : thm = |- !s. FINITE s ==> (?a. ~(a IN s))
0..0..0..solved at 3
val num_INFINITE : thm = |- INFINITE (:num)
0..0..1..2..solved at 6
val string_INFINITE : thm = |- INFINITE (:(char)list)
Warning: inventing type variables
5 basis elements and 1 critical pairs
5 basis elements and 0 critical pairs
5 basis elements and 3 critical pairs
6 basis elements and 4 critical pairs
6 basis elements and 3 critical pairs
7 basis elements and 4 critical pairs
7 basis elements and 3 critical pairs
8 basis elements and 3 critical pairs
8 basis elements and 2 critical pairs
8 basis elements and 1 critical pairs
8 basis elements and 0 critical pairs
5 basis elements and 2 critical pairs
6 basis elements and 2 critical pairs
6 basis elements and 1 critical pairs
7 basis elements and 1 critical pairs
7 basis elements and 0 critical pairs
5 basis elements and 3 critical pairs
6 basis elements and 4 critical pairs
6 basis elements and 3 critical pairs
7 basis elements and 5 critical pairs
7 basis elements and 4 critical pairs
8 basis elements and 5 critical pairs
9 basis elements and 0 critical pairs
4 basis elements and 1 critical pairs
5 basis elements and 1 critical pairs
5 basis elements and 0 critical pairs
2 basis elements and 0 critical pairs
5 basis elements and 2 critical pairs
6 basis elements and 0 critical pairs
5 basis elements and 3 critical pairs
6 basis elements and 4 critical pairs
6 basis elements and 3 critical pairs
7 basis elements and 0 critical pairs
val FINITE_REAL_INTERVAL : thm =
  |- (!a. ~FINITE {x | a < x}) /\
     (!a. ~FINITE {x | a <= x}) /\
     (!b. ~FINITE {x | x < b}) /\
     (!b. ~FINITE {x | x <= b}) /\
     (!a b. FINITE {x | a < x /\ x < b} <=> b <= a) /\
     (!a b. FINITE {x | a <= x /\ x < b} <=> b <= a) /\
     (!a b. FINITE {x | a < x /\ x <= b} <=> b <= a) /\
     (!a b. FINITE {x | a <= x /\ x <= b} <=> b <= a)
val real_INFINITE : thm = |- INFINITE (:real)
0..0..1..5..solved at 10
0..0..solved at 2
0..0..1..solved at 5
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..2..6..solved at 19
0..0..3..8..solved at 22
0..0..2..6..solved at 19
0..0..solved at 2
0..0..3..8..solved at 22
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..2..6..solved at 22
0..0..solved at 3
0..0..solved at 2
0..0..2..solved at 9
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..3..7..22..54..solved at 65
val HAS_SIZE_INDEX : thm =
  |- !s n.
         s HAS_SIZE n
         ==> (?f. (!m. m < n ==> f m IN s) /\
                  (!x. x IN s ==> (?!m. m < n /\ f m = x)))
0..0..0..4..11..21..46..76..solved at 89
0..0..2..4..14..solved at 32
0..0..1..2..8..solved at 17
0..0..solved at 2
0..0..1..2..8..solved at 18
0..0..1..2..5..12..21..solved at 30
0..0..1..2..5..12..23..solved at 35
0..0..1..solved at 4
0..0..1..2..solved at 6
0..0..0..2..14..38..solved at 134
0..0..0..2..14..solved at 42
0..0..0..solved at 3
0..0..0..1..solved at 8
val INFINITE_ENUMERATE : thm =
  |- !s. INFINITE s
         ==> (?r. (!m n. m < n ==> r m < r n) /\ IMAGE r (:num) = s)
val set_of_list : thm =
  |- set_of_list [] = {} /\ set_of_list (CONS h t) = h INSERT set_of_list t
Warning: inventing type variables
val list_of_set : thm =
  |- !s. list_of_set s = (@l. set_of_list l = s /\ LENGTH l = CARD s)
val LIST_OF_SET_PROPERTIES : thm =
  |- !s. FINITE s
         ==> set_of_list (list_of_set s) = s /\
             LENGTH (list_of_set s) = CARD s
Warning: inventing type variables
0..0..1..solved at 4
val SET_OF_LIST_OF_SET : thm =
  |- !s. FINITE s ==> set_of_list (list_of_set s) = s
Warning: inventing type variables
0..0..1..solved at 4
val LENGTH_LIST_OF_SET : thm =
  |- !s. FINITE s ==> LENGTH (list_of_set s) = CARD s
val MEM_LIST_OF_SET : thm =
  |- !s. FINITE s ==> (!x. MEM x (list_of_set s) <=> x IN s)
Warning: inventing type variables
val FINITE_SET_OF_LIST : thm = |- !l. FINITE (set_of_list l)
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 5
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 5
0..0..solved at 2
0..0..solved at 2
val IN_SET_OF_LIST : thm = |- !x l. x IN set_of_list l <=> MEM x l
Warning: inventing type variables
val SET_OF_LIST_APPEND : thm =
  |- !l1 l2. set_of_list (APPEND l1 l2) = set_of_list l1 UNION set_of_list l2
Warning: inventing type variables
val SET_OF_LIST_MAP : thm =
  |- !f l. set_of_list (MAP f l) = IMAGE f (set_of_list l)
Warning: inventing type variables
val SET_OF_LIST_EQ_EMPTY : thm = |- !l. set_of_list l = {} <=> l = []
Warning: inventing type variables
val LIST_OF_SET_EMPTY : thm = |- list_of_set {} = []
Warning: inventing type variables
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val LIST_OF_SET_SING : thm = |- !x. list_of_set {a} = [a]
val dest_setenum : term -> term list = <fun>
val is_setenum : term -> bool = <fun>
val mk_setenum : term list * hol_type -> term = <fun>
val mk_fset : term list -> term = <fun>
Warning: inventing type variables
val pairwise : thm =
  |- !s r. pairwise r s <=> (!x y. x IN s /\ y IN s /\ ~(x = y) ==> r x y)
val PAIRWISE : thm =
  |- (PAIRWISE r [] <=> T) /\
     (PAIRWISE r (CONS h t) <=> ALL (r h) t /\ PAIRWISE r t)
Warning: inventing type variables
val PAIRWISE_EMPTY : thm = |- !r. pairwise r {} <=> T
Warning: inventing type variables
0..0..solved at 2
val PAIRWISE_SING : thm = |- !r x. pairwise r {x} <=> T
Warning: inventing type variables
0..0..2..4..8..18..31..46..solved at 60
val PAIRWISE_MONO : thm =
  |- !r s t. pairwise r s /\ t SUBSET s ==> pairwise r t
Warning: inventing type variables
0..0..2..4..8..28..54..solved at 68
0..0..2..4..8..solved at 13
0..0..2..4..8..solved at 19
0..0..solved at 2
0..0..2..4..solved at 8
0..0..2..4..10..22..solved at 31
0..0..2..4..8..solved at 16
val PAIRWISE_INSERT : thm =
  |- !r x s.
         pairwise r (x INSERT s) <=>
         (!y. y IN s /\ ~(y = x) ==> r x y /\ r y x) /\ pairwise r s
Warning: inventing type variables
0..0..3..7..15..31..53..solved at 71
0..0..2..5..10..22..44..solved at 56
val PAIRWISE_IMAGE : thm =
  |- !r f.
         pairwise r (IMAGE f s) <=>
         pairwise (\x y. ~(f x = f y) ==> r (f x) (f y)) s
Warning: inventing type variables
val CARD_SET_OF_LIST_LE : thm = |- !l. CARD (set_of_list l) <= LENGTH l
Warning: inventing type variables
0..0..1..3..7..solved at 13
0..0..3..7..15..solved at 28
0..0..solved at 2
0..0..4..9..18..solved at 35
0..0..2..solved at 7
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val HAS_SIZE_SET_OF_LIST : thm =
  |- !l. set_of_list l HAS_SIZE LENGTH l <=> PAIRWISE (\x y. ~(x = y)) l
0..0..1..2..6..12..22..34..48..69..99..140..211..307..435..642..905..1303..1847..solved at 2499
0..0..1..7..23..57..137..284..501..solved at 666
0..0..0..1..2..3..12..solved at 21
0..0..1..2..5..12..22..36..52..74..106..152..212..321..452..711..1026..1572..2205..3406..5353..8956..solved at 11113
val SURJECTIVE_IFF_INJECTIVE_GEN : thm =
  |- !s t f.
         FINITE s /\ FINITE t /\ CARD s = CARD t /\ IMAGE f s SUBSET t
         ==> ((!y. y IN t ==> (?x. x IN s /\ f x = y)) <=>
              (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
val SURJECTIVE_IFF_INJECTIVE : thm =
  |- !s f.
         FINITE s /\ IMAGE f s SUBSET s
         ==> ((!y. y IN s ==> (?x. x IN s /\ f x = y)) <=>
              (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
0..0..1..2..5..solved at 13
0..0..2..9..20..43..82..solved at 135
val IMAGE_IMP_INJECTIVE_GEN : thm =
  |- !s t f.
         FINITE s /\ CARD s = CARD t /\ IMAGE f s = t
         ==> (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
Warning: inventing type variables
0..0..1..2..5..9..15..22..solved at 38
val IMAGE_IMP_INJECTIVE : thm =
  |- !s f.
         FINITE s /\ IMAGE f s = s
         ==> (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
0..0..solved at 3
0..0..solved at 3
0..0..5..10..24..51..solved at 66
0..0..solved at 2
0..0..4..8..19..41..solved at 64
0..0..4..8..19..42..solved at 65
0..0..5..10..24..solved at 32
val CARD_LE_INJ : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ CARD s <= CARD t
         ==> (?f. IMAGE f s SUBSET t /\
                  (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
Warning: inventing type variables
0..0..1..solved at 5
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
val FORALL_IN_CLAUSES : thm =
  |- (!P. (!x. x IN {} ==> P x) <=> T) /\
     (!P a s. (!x. x IN a INSERT s ==> P x) <=> P a /\ (!x. x IN s ==> P x))
Warning: inventing type variables
0..0..solved at 2
0..0..1..solved at 5
0..0..0..solved at 4
0..0..0..solved at 3
val EXISTS_IN_CLAUSES : thm =
  |- (!P. (?x. x IN {} /\ P x) <=> F) /\
     (!P a s. (?x. x IN a INSERT s /\ P x) <=> P a \/ (?x. x IN s /\ P x))
0..0..1..2..5..8..11..14..17..20..36..56..78..109..148..191..248..317..solved at 371
0..0..1..2..5..8..11..14..17..20..36..56..78..109..148..191..248..317..solved at 375
0..0..1..solved at 4
val INJECTIVE_ON_IMAGE : thm =
  |- !f u.
         (!s t. s SUBSET u /\ t SUBSET u /\ IMAGE f s = IMAGE f t ==> s = t) <=>
         (!x y. x IN u /\ y IN u /\ f x = f y ==> x = y)
val INJECTIVE_IMAGE : thm =
  |- !f. (!s t. IMAGE f s = IMAGE f t ==> s = t) <=>
         (!x y. f x = f y ==> x = y)
0..0..solved at 2
0..0..0..1..2..3..5..7..9..solved at 17
0..0..solved at 2
0..0..solved at 2
0..0..0..0..1..2..3..4..5..6..9..12..15..21..27..33..solved at 55
val SURJECTIVE_ON_IMAGE : thm =
  |- !f u v.
         (!t. t SUBSET v ==> (?s. s SUBSET u /\ IMAGE f s = t)) <=>
         (!y. y IN v ==> (?x. x IN u /\ f x = y))
val SURJECTIVE_IMAGE : thm =
  |- !f. (!t. ?s. IMAGE f s = t) <=> (!y. ?x. f x = y)
0..0..1..2..5..11..solved at 18
0..0..1..2..5..solved at 13
val CARD_EQ_BIJECTION : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ CARD s = CARD t
         ==> (?f. (!x. x IN s ==> f x IN t) /\
                  (!y. y IN t ==> (?x. x IN s /\ f x = y)) /\
                  (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
0..0..1..solved at 4
0..0..1..2..5..10..18..31..46..63..88..solved at 117
0..0..1..solved at 4
0..0..1..solved at 4
val CARD_EQ_BIJECTIONS : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ CARD s = CARD t
         ==> (?f g.
                  (!x. x IN s ==> f x IN t /\ g (f x) = x) /\
                  (!y. y IN t ==> g y IN s /\ f (g y) = y))
0..0..0..1..2..3..8..solved at 16
0..0..1..solved at 4
0..0..1..2..5..9..15..30..47..76..solved at 120
0..0..solved at 2
val BIJECTIONS_HAS_SIZE : thm =
  |- !s t f g.
         (!x. x IN s ==> f x IN t /\ g (f x) = x) /\
         (!y. y IN t ==> g y IN s /\ f (g y) = y) /\
         s HAS_SIZE n
         ==> t HAS_SIZE n
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
val BIJECTIONS_HAS_SIZE_EQ : thm =
  |- !s t f g.
         (!x. x IN s ==> f x IN t /\ g (f x) = x) /\
         (!y. y IN t ==> g y IN s /\ f (g y) = y)
         ==> (!n. s HAS_SIZE n <=> t HAS_SIZE n)
0..0..1..3..8..15..29..60..solved at 90
0..0..1..3..8..15..solved at 21
val BIJECTIONS_CARD_EQ : thm =
  |- !s t f g.
         (FINITE s \/ FINITE t) /\
         (!x. x IN s ==> f x IN t /\ g (f x) = x) /\
         (!y. y IN t ==> g y IN s /\ f (g y) = y)
         ==> CARD s = CARD t
0..0..2..4..solved at 8
0..0..solved at 2
0..0..2..5..13..34..70..160..300..605..1071..2263..3998..8099..solved at 12555
0..0..3..solved at 6
0..0..3..solved at 6
val WF_FINITE : thm =
  |- !(<<). (!x. ~(x << x)) /\
            (!x y z. x << y /\ y << z ==> x << z) /\
            (!x. FINITE {y | y << x})
            ==> WF (<<)
Warning: inventing type variables
val le_c : thm =
  |- !t s.
         s <=_c t <=>
         (?f. (!x. x IN s ==> f x IN t) /\
              (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
Warning: inventing type variables
val lt_c : thm = |- !t s. s <_c t <=> s <=_c t /\ ~(t <=_c s)
Warning: inventing type variables
val eq_c : thm =
  |- !t s.
         s =_c t <=>
         (?f. (!x. x IN s ==> f x IN t) /\
              (!y. y IN t ==> (?!x. x IN s /\ f x = y)))
Warning: inventing type variables
val ge_c : thm = |- !t s. s >=_c t <=> t <=_c s
Warning: inventing type variables
val gt_c : thm = |- !t s. s >_c t <=> t <_c s
Warning: inventing type variables
0..0..0..1..2..3..solved at 8
0..0..0..1..2..3..6..9..12..21..30..39..58..77..96..solved at 107
val LE_C : thm =
  |- !s t. s <=_c t <=> (?g. !x. x IN s ==> (?y. y IN t /\ g y = x))
Warning: inventing type variables
0..0..0..1..2..3..8..solved at 16
0..0..0..1..2..3..8..solved at 16
val GE_C : thm =
  |- !s t. s >=_c t <=> (?f. !y. y IN t ==> (?x. x IN s /\ y = f x))
Warning: inventing type variables
val COUNTABLE : thm = |- !t. COUNTABLE t <=> (:num) >=_c t
val sup : thm =
  |- !s. sup s =
         (@a. (!x. x IN s ==> x <= a) /\
              (!b. (!x. x IN s ==> x <= b) ==> a <= b))
val SUP_EQ : thm =
  |- !s t.
         (!b. (!x. x IN s ==> x <= b) <=> (!x. x IN t ==> x <= b))
         ==> sup s = sup t
0..0..2..solved at 5
0..0..2..solved at 5
val SUP : thm =
  |- !s. ~(s = {}) /\ (?b. !x. x IN s ==> x <= b)
         ==> (!x. x IN s ==> x <= sup s) /\
             (!b. (!x. x IN s ==> x <= b) ==> sup s <= b)
0..0..2..7..17..36..76..145..262..solved at 474
0..0..1..6..16..31..71..132..229..443..713..1082..1694..2623..4077..6756..11110..18048..29639..47994..76336..solved at 115499
val SUP_FINITE_LEMMA : thm =
  |- !s. FINITE s /\ ~(s = {}) ==> (?b. b IN s /\ (!x. x IN s ==> x <= b))
0..0..2..4..8..22..42..66..112..161..223..297..381..481..707..949..1227..1650..2105..2606..3270..3978..4770..5888..7090..8445..10095..11890..14206..solved at 14609
0..0..2..8..16..42..99..163..346..solved at 408
val SUP_FINITE : thm =
  |- !s. FINITE s /\ ~(s = {}) ==> sup s IN s /\ (!x. x IN s ==> x <= sup s)
0..0..1..3..10..solved at 15
0..0..2..4..12..30..56..solved at 64
val REAL_LE_SUP_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (a <= sup s <=> (?x. x IN s /\ a <= x))
0..0..2..4..11..26..47..solved at 55
0..0..2..5..13..solved at 18
val REAL_SUP_LE_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (sup s <= a <=> (!x. x IN s ==> x <= a))
0..0..1..3..10..solved at 15
0..0..2..4..12..27..47..solved at 54
val REAL_LT_SUP_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (a < sup s <=> (?x. x IN s /\ a < x))
0..0..2..4..11..26..46..solved at 53
0..0..2..5..13..solved at 18
val REAL_SUP_LT_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (sup s < a <=> (!x. x IN s ==> x < a))
0..0..1..3..8..14..36..77..126..246..516..1204..3264..solved at 3298
0..0..1..solved at 7
0..0..1..7..15..33..83..171..solved at 204
val REAL_SUP_UNIQUE : thm =
  |- !s b.
         (!x. x IN s ==> x <= b) /\ (!b'. b' < b ==> (?x. x IN s /\ b' < x))
         ==> sup s = b
0..0..2..5..10..33..62..93..150..209..272..339..414..499..747..1045..1349..solved at 1473
val REAL_SUP_LE : thm =
  |- !b. ~(s = {}) /\ (!x. x IN s ==> x <= b) ==> sup s <= b
0..0..solved at 2
0..0..2..solved at 6
0..0..solved at 3
0..0..2..solved at 5
0..0..solved at 2
0..0..1..3..solved at 7
val REAL_SUP_LE_SUBSET : thm =
  |- !s t.
         ~(s = {}) /\ s SUBSET t /\ (?b. !x. x IN t ==> x <= b)
         ==> sup s <= sup t
0..0..solved at 2
0..0..2..solved at 5
0..0..1..4..8..12..16..solved at 25
0..0..1..5..14..solved at 20
val REAL_SUP_BOUNDS : thm =
  |- !s a b.
         ~(s = {}) /\ (!x. x IN s ==> a <= x /\ x <= b)
         ==> a <= sup s /\ sup s <= b
val REAL_ABS_SUP_LE : thm =
  |- !s a. ~(s = {}) /\ (!x. x IN s ==> abs x <= a) ==> abs (sup s) <= a
val REAL_SUP_ASCLOSE : thm =
  |- !s l e.
         ~(s = {}) /\ (!x. x IN s ==> abs (x - l) <= e)
         ==> abs (sup s - l) <= e
val inf : thm =
  |- !s. inf s =
         (@a. (!x. x IN s ==> a <= x) /\
              (!b. (!x. x IN s ==> b <= x) ==> b <= a))
val INF_EQ : thm =
  |- !s t.
         (!a. (!x. x IN s ==> a <= x) <=> (!x. x IN t ==> a <= x))
         ==> inf s = inf t
0..0..2..solved at 9
0..0..3..12..30..77..192..408..957..2317..5293..solved at 9312
0..0..2..8..solved at 14
0..0..2..10..solved at 17
0..0..3..11..28..74..192..410..solved at 619
0..0..2..10..31..89..255..622..1544..3861..9467..solved at 9606
val INF : thm =
  |- !s. ~(s = {}) /\ (?b. !x. x IN s ==> b <= x)
         ==> (!x. x IN s ==> inf s <= x) /\
             (!b. (!x. x IN s ==> b <= x) ==> b <= inf s)
0..0..2..7..17..36..76..145..262..solved at 483
0..0..1..6..16..31..71..132..229..443..713..1082..1694..2617..4067..6744..11120..18071..29739..48196..76749..solved at 117331
val INF_FINITE_LEMMA : thm =
  |- !s. FINITE s /\ ~(s = {}) ==> (?b. b IN s /\ (!x. x IN s ==> b <= x))
0..0..2..4..8..22..42..66..112..161..223..297..381..481..707..949..1227..1650..2105..2606..3270..3978..4770..5891..7096..8454..10131..11953..14289..solved at 14763
0..0..2..8..16..42..99..163..346..solved at 408
val INF_FINITE : thm =
  |- !s. FINITE s /\ ~(s = {}) ==> inf s IN s /\ (!x. x IN s ==> inf s <= x)
0..0..2..4..12..27..48..solved at 56
0..0..2..5..13..solved at 18
val REAL_LE_INF_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (a <= inf s <=> (!x. x IN s ==> a <= x))
0..0..1..3..10..solved at 15
0..0..2..4..11..29..55..solved at 63
val REAL_INF_LE_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (inf s <= a <=> (?x. x IN s /\ x <= a))
0..0..2..4..12..27..47..solved at 54
0..0..2..5..13..solved at 18
val REAL_LT_INF_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (a < inf s <=> (!x. x IN s ==> a < x))
0..0..1..3..10..solved at 15
0..0..2..4..11..26..46..solved at 53
val REAL_INF_LT_FINITE : thm =
  |- !s a. FINITE s /\ ~(s = {}) ==> (inf s < a <=> (?x. x IN s /\ x < a))
0..0..1..3..8..14..36..77..126..246..516..1202..3262..solved at 3309
0..0..1..solved at 7
0..0..1..7..15..33..83..171..solved at 204
val REAL_INF_UNIQUE : thm =
  |- !s b.
         (!x. x IN s ==> b <= x) /\ (!b'. b < b' ==> (?x. x IN s /\ x < b'))
         ==> inf s = b
0..0..2..5..10..33..62..93..150..209..272..339..414..499..749..1049..1355..solved at 1479
val REAL_LE_INF : thm =
  |- !b. ~(s = {}) /\ (!x. x IN s ==> b <= x) ==> b <= inf s
0..0..solved at 2
0..0..2..solved at 6
0..0..solved at 3
0..0..2..solved at 5
0..0..solved at 2
0..0..1..3..solved at 7
val REAL_LE_INF_SUBSET : thm =
  |- !s t.
         ~(t = {}) /\ t SUBSET s /\ (?b. !x. x IN s ==> b <= x)
         ==> inf s <= inf t
0..0..solved at 2
0..0..2..solved at 5
0..0..1..5..14..solved at 20
0..0..1..4..8..12..16..solved at 27
val REAL_INF_BOUNDS : thm =
  |- !s a b.
         ~(s = {}) /\ (!x. x IN s ==> a <= x /\ x <= b)
         ==> a <= inf s /\ inf s <= b
val REAL_ABS_INF_LE : thm =
  |- !s a. ~(s = {}) /\ (!x. x IN s ==> abs x <= a) ==> abs (inf s) <= a
val REAL_INF_ASCLOSE : thm =
  |- !s l e.
         ~(s = {}) /\ (!x. x IN s ==> abs (x - l) <= e)
         ==> abs (inf s - l) <= e
0..0..2..4..8..16..28..44..solved at 54
0..0..2..solved at 7
0..0..2..solved at 7
0..0..1..solved at 5
val SUP_UNIQUE_FINITE : thm =
  |- !s. FINITE s /\ ~(s = {})
         ==> (sup s = a <=> a IN s /\ (!y. y IN s ==> y <= a))
0..0..2..4..8..16..28..45..solved at 55
0..0..2..solved at 7
0..0..1..solved at 5
0..0..2..solved at 7
val INF_UNIQUE_FINITE : thm =
  |- !s. FINITE s /\ ~(s = {})
         ==> (inf s = a <=> a IN s /\ (!y. y IN s ==> a <= y))
0..0..3..10..23..57..122..234..solved at 262
val SUP_INSERT_FINITE : thm =
  |- !x s.
         FINITE s
         ==> sup (x INSERT s) = (if s = {} then x else max x (sup s))
val SUP_SING : thm = |- !a. sup {a} = a
0..0..2..6..16..41..78..solved at 112
0..0..3..solved at 6
val INF_INSERT_FINITE : thm =
  |- !x s.
         FINITE s
         ==> inf (x INSERT s) = (if s = {} then x else min x (inf s))
val INF_SING : thm = |- !a. inf {a} = a
Warning: inventing type variables
0..0..1..solved at 4
0..0..1..2..5..solved at 11
0..0..2..5..11..43..97..169..307..507..781..1260..1924..solved at 2571
0..0..2..5..11..40..91..161..351..626..solved at 723
val REAL_SUP_EQ_INF : thm =
  |- !s. ~(s = {}) /\ (?B. !x. x IN s ==> abs x <= B)
         ==> (sup s = inf s <=> (?a. s = {a}))
0..0..1..4..12..31..76..162..294..558..959..1533..2548..solved at 2588
val REAL_LE_SUP : thm =
  |- !s a b y. y IN s /\ a <= y /\ (!x. x IN s ==> x <= b) ==> a <= sup s
0..0..1..4..11..30..75..161..294..559..961..1532..2548..solved at 2599
val REAL_INF_LE : thm =
  |- !s a b y. y IN s /\ y <= b /\ (!x. x IN s ==> a <= x) ==> inf s <= b
0..0..2..4..9..25..48..84..142..210..337..solved at 387
0..0..2..5..11..35..65..100..176..254..338..437..544..687..1040..1443..1912..solved at 2135
val REAL_SUP_LE_EQ : thm =
  |- !s y.
         ~(s = {}) /\ (?b. !x. x IN s ==> x <= b)
         ==> (sup s <= y <=> (!x. x IN s ==> x <= y))
Warning: inventing type variables
0..0..2..4..10..26..49..86..143..211..338..solved at 362
0..0..2..5..11..35..65..100..176..254..338..437..544..687..1042..1447..1918..solved at 2141
val REAL_LE_INF_EQ : thm =
  |- !s t.
         ~(s = {}) /\ (?b. !x. x IN s ==> b <= x)
         ==> (y <= inf s <=> (!x. x IN s ==> y <= x))
0..0..1..5..11..solved at 16
0..0..1..3..7..solved at 17
val SUP_UNIQUE : thm =
  |- !s b. (!c. (!x. x IN s ==> x <= c) <=> b <= c) ==> sup s = b
0..0..1..5..11..solved at 16
0..0..1..3..7..solved at 17
val INF_UNIQUE : thm =
  |- !s b. (!c. (!x. x IN s ==> c <= x) <=> c <= b) ==> inf s = b
0..0..3..8..18..53..99..155..287..423..569..733..913..1145..1693..2329..3064..solved at 3378
0..0..3..8..18..53..99..155..287..423..569..733..913..1145..1693..2329..3064..solved at 3370
0..0..3..6..14..41..79..141..244..366..591..solved at 701
0..0..3..6..14..41..79..141..244..366..591..solved at 662
val SUP_UNION : thm =
  |- !s t.
         ~(s = {}) /\
         ~(t = {}) /\
         (?b. !x. x IN s ==> x <= b) /\
         (?c. !x. x IN t ==> x <= c)
         ==> sup (s UNION t) = max (sup s) (sup t)
0..0..3..8..18..53..99..155..287..423..569..733..913..1145..1695..2333..3070..solved at 3384
0..0..3..8..18..53..99..155..287..423..569..733..913..1145..1695..2333..3070..solved at 3376
0..0..3..6..16..43..81..145..246..368..593..solved at 658
0..0..3..6..16..43..81..145..246..368..593..solved at 619
val INF_UNION : thm =
  |- !s t.
         ~(s = {}) /\
         ~(t = {}) /\
         (?b. !x. x IN s ==> b <= x) /\
         (?c. !x. x IN t ==> c <= x)
         ==> inf (s UNION t) = min (inf s) (inf t)
val new_inductive_set : term -> thm * thm * thm = <fun>
- : unit = ()
File "sets.ml" already loaded
- : unit = ()
- : unit = ()
- : unit = ()
val numseg : thm = |- !m n. m..n = {x | m <= x /\ x <= n}
val FINITE_NUMSEG : thm = |- !m n. FINITE (m..n)
val NUMSEG_COMBINE_R : thm =
  |- !m p n. m <= p + 1 /\ p <= n ==> (m..p) UNION (p + 1..n) = m..n
val NUMSEG_COMBINE_L : thm =
  |- !m p n. m <= p /\ p <= n + 1 ==> (m..p - 1) UNION (p..n) = m..n
val NUMSEG_LREC : thm = |- !m n. m <= n ==> m INSERT (m + 1..n) = m..n
val NUMSEG_RREC : thm = |- !m n. m <= n ==> n INSERT (m..n - 1) = m..n
val NUMSEG_REC : thm = |- !m n. m <= SUC n ==> m..SUC n = SUC n INSERT (m..n)
val IN_NUMSEG : thm = |- !m n p. p IN m..n <=> m <= p /\ p <= n
val IN_NUMSEG_0 : thm = |- !m n. m IN 0..n <=> m <= n
val NUMSEG_SING : thm = |- !n. n..n = {n}
0..0..1..7..solved at 11
0..0..0..4..13..solved at 25
val NUMSEG_EMPTY : thm = |- !m n. m..n = {} <=> n < m
val CARD_NUMSEG_LEMMA : thm = |- !m d. CARD (m..m + d) = d + 1
0..0..1..2..5..9..15..24..33..44..67..90..125..solved at 185
val CARD_NUMSEG : thm = |- !m n. CARD (m..n) = (n + 1) - m
val HAS_SIZE_NUMSEG : thm = |- !m n. m..n HAS_SIZE (n + 1) - m
val CARD_NUMSEG_1 : thm = |- !n. CARD (1..n) = n
val HAS_SIZE_NUMSEG_1 : thm = |- !n. 1..n HAS_SIZE n
val NUMSEG_CLAUSES : thm =
  |- (!m. m..0 = (if m = 0 then {0} else {})) /\
     (!m n. m..SUC n = (if m <= SUC n then SUC n INSERT (m..n) else m..n))
0..0..1..2..5..8..11..solved at 19
0..0..3..6..15..54..118..265..680..1689..5287..solved at 11598
0..0..0..0..2..4..6..10..14..18..30..42..68..114..161..216..305..399..508..670..875..1105..solved at 1498
0..0..1..3..8..solved at 13
val FINITE_INDEX_NUMSEG : thm =
  |- !s. FINITE s <=>
         (?f. (!i j. i IN 1..CARD s /\ j IN 1..CARD s /\ f i = f j ==> i = j) /\
              s = IMAGE f (1..CARD s))
0..0..0..0..1..3..5..12..21..41..70..112..159..242..330..451..600..781..1008..1316..1670..solved at 2062
0..0..1..solved at 4
val FINITE_INDEX_NUMBERS : thm =
  |- !s. FINITE s <=>
         (?k f.
              (!i j. i IN k /\ j IN k /\ f i = f j ==> i = j) /\
              FINITE k /\
              s = IMAGE f k)
0..0..4..9..14..29..48..67..120..173..226..279..360..441..542..703..864..1089..1314..1539..1868..2321..2774..3227..solved at 3486
val DISJOINT_NUMSEG : thm =
  |- !m n p q. DISJOINT (m..n) (p..q) <=> n < p \/ q < m \/ n < m \/ q < p
val NUMSEG_ADD_SPLIT : thm =
  |- !m n p. m <= n + 1 ==> m..n + p = (m..n) UNION (n + 1..n + p)
val NUMSEG_OFFSET_IMAGE : thm =
  |- !m n p. m + p..n + p = IMAGE (\i. i + p) (m..n)
0..0..2..8..19..solved at 25
0..0..2..8..18..solved at 24
val SUBSET_NUMSEG : thm =
  |- !m n p q. m..n SUBSET p..q <=> n < m \/ p <= m /\ n <= q
val NUMSEG_LE : thm = |- !n. {x | x <= n} = 0..n
val NUMSEG_LT : thm = |- !n. {x | x < n} = (if n = 0 then {} else 0..n - 1)
0..0..1..solved at 4
0..0..solved at 2
0..0..1..2..5..9..15..27..41..66..107..solved at 125
val NUMSEG_CONV : conv = <fun>
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..3..6..19..42..78..127..186..270..412..638..solved at 776
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..4..8..23..51..93..156..solved at 192
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..1..2..solved at 9
0..0..2..4..solved at 8
0..0..1..2..solved at 9
val TOPOLOGICAL_SORT : thm =
  |- !(<<). (!x y. x << y /\ y << x ==> x = y) /\
            (!x y z. x << y /\ y << z ==> x << z)
            ==> (!n s.
                     s HAS_SIZE n
                     ==> (?f. s = IMAGE f (1..n) /\
                              (!j k.
                                   j IN 1..n /\ k IN 1..n /\ j < k
                                   ==> ~(f k << f j))))
val FINITE_INTSEG : thm =
  |- (!l r. FINITE {x | l <= x /\ x <= r}) /\
     (!l r. FINITE {x | l <= x /\ x < r}) /\
     (!l r. FINITE {x | l < x /\ x <= r}) /\
     (!l r. FINITE {x | l < x /\ x < r})
Warning: inventing type variables
val neutral : thm = |- !op. neutral op = (@x. !y. op x y = y /\ op y x = y)
val monoidal : thm =
  |- !op. monoidal op <=>
          (!x y. op x y = op y x) /\
          (!x y z. op x (op y z) = op (op x y) z) /\
          (!x. op (neutral op) x = x)
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..solved at 7
0..0..solved at 2
0..0..1..2..solved at 7
0..0..1..2..8..17..53..104..solved at 158
val MONOIDAL_AC : thm =
  |- !op. monoidal op
          ==> (!a. op (neutral op) a = a) /\
              (!a. op a (neutral op) = a) /\
              (!a b. op a b = op b a) /\
              (!a b c. op (op a b) c = op a (op b c)) /\
              (!a b c. op a (op b c) = op b (op a c))
val support : thm =
  |- !s f op. support op f s = {x | x IN s /\ ~(f x = neutral op)}
Warning: inventing type variables
val iterate : thm =
  |- !f s op.
         iterate op s f =
         (if FINITE (support op f s)
          then ITSET (\x a. op (f x) a) (support op f s) (neutral op)
          else neutral op)
Warning: inventing type variables
val IN_SUPPORT : thm =
  |- !op f x s. x IN support op f s <=> x IN s /\ ~(f x = neutral op)
Warning: inventing type variables
val SUPPORT_SUPPORT : thm =
  |- !op f s. support op f (support op f s) = support op f s
Warning: inventing type variables
0..0..1..solved at 4
0..0..1..solved at 4
val SUPPORT_EMPTY : thm =
  |- !op f s. (!x. x IN s ==> f x = neutral op) <=> support op f s = {}
Warning: inventing type variables
val SUPPORT_SUBSET : thm = |- !op f s. support op f s SUBSET s
Warning: inventing type variables
0..0..1..2..solved at 6
val FINITE_SUPPORT : thm = |- !op f s. FINITE s ==> FINITE (support op f s)
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..solved at 5
0..0..solved at 2
val SUPPORT_CLAUSES : thm =
  |- (!f. support op f {} = {}) /\
     (!f x s.
          support op f (x INSERT s) =
          (if f x = neutral op
           then support op f s
           else x INSERT support op f s)) /\
     (!f x s. support op f (s DELETE x) = support op f s DELETE x) /\
     (!f s t. support op f (s UNION t) = support op f s UNION support op f t) /\
     (!f s t. support op f (s INTER t) = support op f s INTER support op f t) /\
     (!f s t. support op f (s DIFF t) = support op f s DIFF support op f t) /\
     (!f g s. support op g (IMAGE f s) = IMAGE f (support op (g o f) s))
Warning: inventing type variables
val SUPPORT_DELTA : thm =
  |- !op s f a.
         support op (\x. if x = a then f x else neutral op) s =
         (if a IN s then support op f {a} else {})
Warning: inventing type variables
val FINITE_SUPPORT_DELTA : thm =
  |- !op f a. FINITE (support op (\x. if x = a then f x else neutral op) s)
Warning: inventing type variables
val ITERATE_SUPPORT : thm =
  |- !op f s. iterate op (support op f s) f = iterate op s f
Warning: inventing type variables
val ITERATE_EXPAND_CASES : thm =
  |- !op f s.
         iterate op s f =
         (if FINITE (support op f s)
          then iterate op (support op f s) f
          else neutral op)
0..0..2..4..11..20..34..72..114..190..381..solved at 438
0..0..solved at 2
0..0..2..4..10..solved at 16
val ITERATE_CLAUSES_GEN : thm =
  |- !op. monoidal op
          ==> (!f. iterate op {} f = neutral op) /\
              (!f x s.
                   monoidal op /\ FINITE (support op f s)
                   ==> iterate op (x INSERT s) f =
                       (if x IN s
                        then iterate op s f
                        else op (f x) (iterate op s f)))
Warning: inventing type variables
val ITERATE_CLAUSES : thm =
  |- !op. monoidal op
          ==> (!f. iterate op {} f = neutral op) /\
              (!f x s.
                   FINITE s
                   ==> iterate op (x INSERT s) f =
                       (if x IN s
                        then iterate op s f
                        else op (f x) (iterate op s f)))
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 4
0..0..solved at 2
0..0..solved at 3
0..0..solved at 4
0..0..solved at 2
0..0..0..solved at 5
0..0..0..solved at 3
0..0..solved at 2
0..0..1..solved at 5
Warning: inventing type variables
0..0..1..2..5..9..15..solved at 22
0..0..solved at 2
0..0..3..6..12..25..46..94..155..254..479..solved at 599
val ITERATE_UNION : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE s /\ FINITE t /\ DISJOINT s t
                   ==> iterate op (s UNION t) f =
                       op (iterate op s f) (iterate op t f))
val ITERATE_UNION_GEN : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE (support op f s) /\
                   FINITE (support op f t) /\
                   DISJOINT (support op f s) (support op f t)
                   ==> iterate op (s UNION t) f =
                       op (iterate op s f) (iterate op t f))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..1..solved at 4
0..0..solved at 2
Warning: inventing type variables
0..0..1..2..5..9..15..22..29..36..53..70..97..132..167..210..282..354..455..576..697..838..1034..1230..1481..solved at 1835
val ITERATE_DIFF : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE s /\ t SUBSET s
                   ==> op (iterate op (s DIFF t) f) (iterate op t f) =
                       iterate op s f)
val ITERATE_DIFF_GEN : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE (support op f s) /\
                   support op f t SUBSET support op f s
                   ==> op (iterate op (s DIFF t) f) (iterate op t f) =
                       iterate op s f)
Warning: inventing type variables
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
Warning: inventing type variables
val ITERATE_INCL_EXCL : thm =
  |- !op. monoidal op
          ==> (!s t f.
                   FINITE s /\ FINITE t
                   ==> op (iterate op s f) (iterate op t f) =
                       op (iterate op (s UNION t) f)
                       (iterate op (s INTER t) f))
val ITERATE_CLOSED : thm =
  |- !op. monoidal op
          ==> (!P. P (neutral op) /\ (!x y. P x /\ P y ==> P (op x y))
                   ==> (!f s.
                            (!x. x IN s /\ ~(f x = neutral op) ==> P (f x))
                            ==> P (iterate op s f)))
val ITERATE_RELATED : thm =
  |- !op. monoidal op
          ==> (!R. R (neutral op) (neutral op) /\
                   (!x1 y1 x2 y2.
                        R x1 x2 /\ R y1 y2 ==> R (op x1 y1) (op x2 y2))
                   ==> (!f g s.
                            FINITE s /\ (!x. x IN s ==> R (f x) (g x))
                            ==> R (iterate op s f) (iterate op s g)))
0..0..2..10..33..89..264..814..2481..solved at 6396
0..0..1..2..6..solved at 11
val ITERATE_EQ_NEUTRAL : thm =
  |- !op. monoidal op
          ==> (!f s.
                   (!x. x IN s ==> f x = neutral op)
                   ==> iterate op s f = neutral op)
0..0..1..2..5..9..15..solved at 26
val ITERATE_SING : thm =
  |- !op. monoidal op ==> (!f x. iterate op {x} f = f x)
0..0..1..6..22..48..121..253..441..992..1771..3020..5157..8831..solved at 12430
val ITERATE_DELETE : thm =
  |- !op. monoidal op
          ==> (!f s a.
                   FINITE s /\ a IN s
                   ==> op (f a) (iterate op (s DELETE a) f) = iterate op s f)
Warning: inventing type variables
val ITERATE_DELTA : thm =
  |- !op. monoidal op
          ==> (!f a s.
                   iterate op s (\x. if x = a then f x else neutral op) =
                   (if a IN s then f a else neutral op))
Warning: inventing type variables
0..0..3..6..13..solved at 24
0..0..2..4..8..16..28..43..67..95..155..236..348..490..727..solved at 823
0..0..4..8..19..solved at 30
0..0..3..6..solved at 13
0..0..1..9..19..37..76..127..solved at 141
0..0..solved at 2
0..0..1..8..17..34..67..112..solved at 126
val ITERATE_IMAGE : thm =
  |- !op. monoidal op
          ==> (!f g s.
                   (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
                   ==> iterate op (IMAGE f s) g = iterate op s (g o f))
0..0..0..1..3..7..20..solved at 34
0..0..1..solved at 4
0..0..1..2..5..9..15..35..solved at 65
val ITERATE_BIJECTION : thm =
  |- !op. monoidal op
          ==> (!f p s.
                   (!x. x IN s ==> p x IN s) /\
                   (!y. y IN s ==> (?!x. x IN s /\ p x = y))
                   ==> iterate op s f = iterate op s (f o p))
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..1..solved at 6
0..0..0..0..solved at 5
0..0..0..0..solved at 4
Warning: inventing type variables
0..0..solved at 2
val ITERATE_ITERATE_PRODUCT : thm =
  |- !op. monoidal op
          ==> (!s t x.
                   FINITE s /\ (!i. i IN s ==> FINITE (t i))
                   ==> iterate op s (\i. iterate op (t i) (x i)) =
                       iterate op {i,j | i IN s /\ j IN t i} (\(i,j). x i j))
0..0..solved at 2
0..0..1..2..5..solved at 11
0..0..solved at 2
0..0..1..2..5..10..20..solved at 31
0..0..solved at 2
0..0..1..7..solved at 11
0..0..3..7..solved at 11
0..0..2..4..12..24..44..84..solved at 142
val ITERATE_EQ : thm =
  |- !op. monoidal op
          ==> (!f g s.
                   (!x. x IN s ==> f x = g x)
                   ==> iterate op s f = iterate op s g)
0..0..0..1..2..3..8..solved at 16
0..0..1..solved at 4
0..0..1..2..10..22..49..93..171..282..522..811..solved at 842
0..0..1..2..5..9..15..23..solved at 37
val ITERATE_EQ_GENERAL : thm =
  |- !op. monoidal op
          ==> (!s t f g h.
                   (!y. y IN t ==> (?!x. x IN s /\ h x = y)) /\
                   (!x. x IN s ==> h x IN t /\ g (h x) = f x)
                   ==> iterate op s f = iterate op t g)
0..0..0..1..2..3..solved at 8
0..0..1..2..5..9..15..30..47..76..solved at 121
0..0..1..solved at 4
0..0..1..solved at 4
val ITERATE_EQ_GENERAL_INVERSES : thm =
  |- !op. monoidal op
          ==> (!s t f g h k.
                   (!y. y IN t ==> k y IN s /\ h (k y) = y) /\
                   (!x. x IN s ==> h x IN t /\ k (h x) = x /\ g (h x) = f x)
                   ==> iterate op s f = iterate op t g)
0..0..1..solved at 4
0..0..2..solved at 6
0..0..0..2..4..8..solved at 18
0..0..1..2..5..solved at 13
val ITERATE_INJECTION : thm =
  |- !op. monoidal op
          ==> (!f p s.
                   FINITE s /\
                   (!x. x IN s ==> p x IN s) /\
                   (!x y. x IN s /\ y IN s /\ p x = p y ==> x = y)
                   ==> iterate op s (f o p) = iterate op s f)
0..0..3..11..31..solved at 42
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
val ITERATE_UNION_NONZERO : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE s /\
                   FINITE t /\
                   (!x. x IN s INTER t ==> f x = neutral op)
                   ==> iterate op (s UNION t) f =
                       op (iterate op s f) (iterate op t f))
Warning: inventing type variables
val ITERATE_OP : thm =
  |- !op. monoidal op
          ==> (!f g s.
                   FINITE s
                   ==> iterate op s (\x. op (f x) (g x)) =
                       op (iterate op s f) (iterate op s g))
0..0..2..4..solved at 9
0..0..solved at 2
0..0..2..4..solved at 8
0..0..solved at 2
val ITERATE_SUPERSET : thm =
  |- !op. monoidal op
          ==> (!f u v.
                   u SUBSET v /\
                   (!x. x IN v /\ ~(x IN u) ==> f x = neutral op)
                   ==> iterate op v f = iterate op u f)
0..0..4..8..18..34..solved at 48
0..0..2..4..solved at 8
0..0..4..8..18..34..solved at 48
0..0..2..4..8..16..39..83..147..248..472..749..1436..solved at 2196
0..0..4..8..18..solved at 32
0..0..2..4..8..solved at 14
val ITERATE_IMAGE_NONZERO : thm =
  |- !op. monoidal op
          ==> (!g f s.
                   FINITE s /\
                   (!x y.
                        x IN s /\ y IN s /\ ~(x = y) /\ f x = f y
                        ==> g (f x) = neutral op)
                   ==> iterate op (IMAGE f s) g = iterate op s (g o f))
Warning: inventing type variables
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
val ITERATE_CASES : thm =
  |- !op. monoidal op
          ==> (!s P f g.
                   FINITE s
                   ==> iterate op s (\x. if P x then f x else g x) =
                       op (iterate op {x | x IN s /\ P x} f)
                       (iterate op {x | x IN s /\ ~P x} g))
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..1..2..5..11..25..55..100..209..399..solved at 697
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
val ITERATE_OP_GEN : thm =
  |- !op. monoidal op
          ==> (!f g s.
                   FINITE (support op f s) /\ FINITE (support op g s)
                   ==> iterate op s (\x. op (f x) (g x)) =
                       op (iterate op s f) (iterate op s g))
Warning: inventing type variables
0..0..1..2..5..9..15..solved at 26
0..0..1..solved at 4
val ITERATE_CLAUSES_NUMSEG : thm =
  |- !op. monoidal op
          ==> (!m. iterate op (m..0) f = (if m = 0 then f 0 else neutral op)) /\
              (!m n.
                   iterate op (m..SUC n) f =
                   (if m <= SUC n
                    then op (iterate op (m..n) f) (f (SUC n))
                    else iterate op (m..n) f))
Warning: inventing type variables
0..0..1..2..6..solved at 12
val ITERATE_PAIR : thm =
  |- !op. monoidal op
          ==> (!f m n.
                   iterate op (2 * m..2 * n + 1) f =
                   iterate op (m..n) (\i. op (f (2 * i)) (f (2 * i + 1))))
- : unit = ()
Warning: inventing type variables
val nsum : thm = |- nsum = iterate (+)
0..0..1..2..solved at 8
0..0..solved at 2
0..0..solved at 2
val NEUTRAL_ADD : thm = |- neutral (+) = 0
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
val NEUTRAL_MUL : thm = |- neutral (*) = 1
val MONOIDAL_ADD : thm = |- monoidal (+)
val MONOIDAL_MUL : thm = |- monoidal (*)
Warning: inventing type variables
val NSUM_DEGENERATE : thm =
  |- !f s. ~FINITE {x | x IN s /\ ~(f x = 0)} ==> nsum s f = 0
Warning: inventing type variables
val NSUM_CLAUSES : thm =
  |- (!f. nsum {} f = 0) /\
     (!x f s.
          FINITE s
          ==> nsum (x INSERT s) f =
              (if x IN s then nsum s f else f x + nsum s f))
Warning: inventing type variables
val NSUM_UNION : thm =
  |- !f s t.
         FINITE s /\ FINITE t /\ DISJOINT s t
         ==> nsum (s UNION t) f = nsum s f + nsum t f
Warning: inventing type variables
val NSUM_DIFF : thm =
  |- !f s t.
         FINITE s /\ t SUBSET s ==> nsum (s DIFF t) f = nsum s f - nsum t f
val NSUM_INCL_EXCL : thm =
  |- !s t f.
         FINITE s /\ FINITE t
         ==> nsum s f + nsum t f = nsum (s UNION t) f + nsum (s INTER t) f
Warning: inventing type variables
val NSUM_SUPPORT : thm = |- !f s. nsum (support (+) f s) f = nsum s f
Warning: inventing type variables
val NSUM_ADD : thm =
  |- !f g s. FINITE s ==> nsum s (\x. f x + g x) = nsum s f + nsum s g
Warning: inventing type variables
val NSUM_ADD_GEN : thm =
  |- !f g s.
         FINITE {x | x IN s /\ ~(f x = 0)} /\
         FINITE {x | x IN s /\ ~(g x = 0)}
         ==> nsum s (\x. f x + g x) = nsum s f + nsum s g
val NSUM_EQ_0 : thm = |- !f s. (!x. x IN s ==> f x = 0) ==> nsum s f = 0
val NSUM_0 : thm = |- !s. nsum s (\n. 0) = 0
val NSUM_LMUL : thm = |- !f c s. nsum s (\x. c * f x) = c * nsum s f
val NSUM_RMUL : thm = |- !f c s. nsum s (\x. f x * c) = nsum s f * c
Warning: inventing type variables
val NSUM_LE : thm =
  |- !f g s. FINITE s /\ (!x. x IN s ==> f x <= g x) ==> nsum s f <= nsum s g
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
val NSUM_LT : thm =
  |- !f g s.
         FINITE s /\ (!x. x IN s ==> f x <= g x) /\ (?x. x IN s /\ f x < g x)
         ==> nsum s f < nsum s g
Warning: inventing type variables
0..0..2..6..15..30..73..134..229..368..553..800..1208..1747..2508..3645..5152..7046..solved at 7159
val NSUM_LT_ALL : thm =
  |- !f g s.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < g x)
         ==> nsum s f < nsum s g
Warning: inventing type variables
val NSUM_EQ : thm =
  |- !f g s. (!x. x IN s ==> f x = g x) ==> nsum s f = nsum s g
Warning: inventing type variables
val NSUM_CONST : thm = |- !c s. FINITE s ==> nsum s (\n. c) = CARD s * c
0..0..3..6..9..solved at 14
0..0..3..6..9..solved at 14
0..0..2..5..8..solved at 18
0..0..2..solved at 6
val NSUM_POS_BOUND : thm =
  |- !f b s. FINITE s /\ nsum s f <= b ==> (!x. x IN s ==> f x <= b)
Warning: inventing type variables
0..0..1..3..7..13..30..solved at 37
val NSUM_EQ_0_IFF : thm =
  |- !s. FINITE s ==> (nsum s f = 0 <=> (!x. x IN s ==> f x = 0))
0..0..1..solved at 4
val NSUM_POS_LT : thm =
  |- !f s. FINITE s /\ (?x. x IN s /\ 0 < f x) ==> 0 < nsum s f
0..0..solved at 2
0..0..1..5..15..30..solved at 36
val NSUM_POS_LT_ALL : thm =
  |- !s f. FINITE s /\ ~(s = {}) /\ (!i. i IN s ==> 0 < f i) ==> 0 < nsum s f
Warning: inventing type variables
val NSUM_DELETE : thm =
  |- !f s a. FINITE s /\ a IN s ==> f a + nsum (s DELETE a) f = nsum s f
Warning: inventing type variables
val NSUM_SING : thm = |- !f x. nsum {x} f = f x
val NSUM_DELTA : thm =
  |- !s a. nsum s (\x. if x = a then b else 0) = (if a IN s then b else 0)
val NSUM_SWAP : thm =
  |- !f s t.
         FINITE s /\ FINITE t
         ==> nsum s (\i. nsum t (f i)) = nsum t (\j. nsum s (\i. f i j))
Warning: inventing type variables
val NSUM_IMAGE : thm =
  |- !f g s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
         ==> nsum (IMAGE f s) g = nsum s (g o f)
val NSUM_SUPERSET : thm =
  |- !f u v.
         u SUBSET v /\ (!x. x IN v /\ ~(x IN u) ==> f x = 0)
         ==> nsum v f = nsum u f
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..1..5..15..solved at 22
0..0..2..6..22..76..261..solved at 597
val NSUM_UNION_RZERO : thm =
  |- !f u v.
         FINITE u /\ (!x. x IN v /\ ~(x IN u) ==> f x = 0)
         ==> nsum (u UNION v) f = nsum u f
0..0..1..2..7..13..26..42..67..97..161..234..375..537..790..1087..1727..2450..solved at 2485
val NSUM_UNION_LZERO : thm =
  |- !f u v.
         FINITE v /\ (!x. x IN u /\ ~(x IN v) ==> f x = 0)
         ==> nsum (u UNION v) f = nsum v f
Warning: inventing type variables
val NSUM_RESTRICT : thm =
  |- !f s. FINITE s ==> nsum s (\x. if x IN s then f x else 0) = nsum s f
val NSUM_BOUND : thm =
  |- !s f b. FINITE s /\ (!x. x IN s ==> f x <= b) ==> nsum s f <= CARD s * b
val NSUM_BOUND_GEN : thm =
  |- !s f b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x <= b DIV CARD s)
         ==> nsum s f <= b
0..0..0..solved at 3
val NSUM_BOUND_LT : thm =
  |- !s f b.
         FINITE s /\ (!x. x IN s ==> f x <= b) /\ (?x. x IN s /\ f x < b)
         ==> nsum s f < CARD s * b
Warning: inventing type variables
0..0..2..6..15..30..77..142..261..426..699..1038..1725..2554..4260..6426..11402..17097..solved at 17200
val NSUM_BOUND_LT_ALL : thm =
  |- !s f b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < b)
         ==> nsum s f < CARD s * b
val NSUM_BOUND_LT_GEN : thm =
  |- !s f b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < b DIV CARD s)
         ==> nsum s f < b
Warning: inventing type variables
0..0..1..2..5..9..15..23..31..39..57..75..103..solved at 139
val NSUM_UNION_EQ : thm =
  |- !s t u.
         FINITE u /\ s INTER t = {} /\ s UNION t = u
         ==> nsum s f + nsum t f = nsum u f
0..0..1..2..6..11..19..34..49..70..117..164..237..386..553..836..1215..1685..2287..solved at 2748
val NSUM_EQ_SUPERSET : thm =
  |- !f s t.
         FINITE t /\
         t SUBSET s /\
         (!x. x IN t ==> f x = g x) /\
         (!x. x IN s /\ ~(x IN t) ==> f x = 0)
         ==> nsum s f = nsum t g
Warning: inventing type variables
val NSUM_RESTRICT_SET : thm =
  |- !P s f. nsum {x | x IN s /\ P x} f = nsum s (\x. if P x then f x else 0)
Warning: inventing type variables
val NSUM_NSUM_RESTRICT : thm =
  |- !R f s t.
         FINITE s /\ FINITE t
         ==> nsum s (\x. nsum {y | y IN t /\ R x y} (\y. f x y)) =
             nsum t (\y. nsum {x | x IN s /\ R x y} (\x. f x y))
Warning: inventing type variables
val CARD_EQ_NSUM : thm = |- !s. FINITE s ==> CARD s = nsum s (\x. 1)
val NSUM_MULTICOUNT_GEN : thm =
  |- !R s t k.
         FINITE s /\
         FINITE t /\
         (!j. j IN t ==> CARD {i | i IN s /\ R i j} = k j)
         ==> nsum s (\i. CARD {j | j IN t /\ R i j}) = nsum t (\i. k i)
val NSUM_MULTICOUNT : thm =
  |- !R s t k.
         FINITE s /\
         FINITE t /\
         (!j. j IN t ==> CARD {i | i IN s /\ R i j} = k)
         ==> nsum s (\i. CARD {j | j IN t /\ R i j}) = k * CARD t
0..0..1..3..solved at 8
0..0..0..solved at 3
0..0..solved at 2
val NSUM_IMAGE_GEN : thm =
  |- !f g s.
         FINITE s
         ==> nsum s g = nsum (IMAGE f s) (\y. nsum {x | x IN s /\ f x = y} g)
0..0..1..solved at 5
val NSUM_GROUP : thm =
  |- !f g s t.
         FINITE s /\ IMAGE f s SUBSET t
         ==> nsum t (\y. nsum {x | x IN s /\ f x = y} g) = nsum s g
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val NSUM_SUBSET : thm =
  |- !u v f.
         FINITE u /\ FINITE v /\ (!x. x IN u DIFF v ==> f x = 0)
         ==> nsum u f <= nsum v f
Warning: inventing type variables
0..0..1..3..solved at 7
0..0..solved at 2
0..0..1..4..12..30..solved at 51
val NSUM_SUBSET_SIMPLE : thm =
  |- !u v f. FINITE v /\ u SUBSET v ==> nsum u f <= nsum v f
0..0..solved at 2
0..0..1..3..7..14..32..solved at 40
0..0..solved at 2
0..0..1..3..7..14..30..solved at 38
val NSUM_LE_GEN : thm =
  |- !f g s.
         (!x. x IN s ==> f x <= g x) /\ FINITE {x | x IN s /\ ~(g x = 0)}
         ==> nsum s f <= nsum s g
val NSUM_IMAGE_NONZERO : thm =
  |- !d i s.
         FINITE s /\
         (!x y. x IN s /\ y IN s /\ ~(x = y) /\ i x = i y ==> d (i x) = 0)
         ==> nsum (IMAGE i s) d = nsum s (d o i)
val NSUM_BIJECTION : thm =
  |- !f p s.
         (!x. x IN s ==> p x IN s) /\
         (!y. y IN s ==> (?!x. x IN s /\ p x = y))
         ==> nsum s f = nsum s (f o p)
val NSUM_NSUM_PRODUCT : thm =
  |- !s t x.
         FINITE s /\ (!i. i IN s ==> FINITE (t i))
         ==> nsum s (\i. nsum (t i) (x i)) =
             nsum {i,j | i IN s /\ j IN t i} (\(i,j). x i j)
val NSUM_EQ_GENERAL : thm =
  |- !s t f g h.
         (!y. y IN t ==> (?!x. x IN s /\ h x = y)) /\
         (!x. x IN s ==> h x IN t /\ g (h x) = f x)
         ==> nsum s f = nsum t g
val NSUM_EQ_GENERAL_INVERSES : thm =
  |- !s t f g h k.
         (!y. y IN t ==> k y IN s /\ h (k y) = y) /\
         (!x. x IN s ==> h x IN t /\ k (h x) = x /\ g (h x) = f x)
         ==> nsum s f = nsum t g
Warning: inventing type variables
val NSUM_INJECTION : thm =
  |- !f p s.
         FINITE s /\
         (!x. x IN s ==> p x IN s) /\
         (!x y. x IN s /\ y IN s /\ p x = p y ==> x = y)
         ==> nsum s (f o p) = nsum s f
Warning: inventing type variables
val NSUM_UNION_NONZERO : thm =
  |- !f s t.
         FINITE s /\ FINITE t /\ (!x. x IN s INTER t ==> f x = 0)
         ==> nsum (s UNION t) f = nsum s f + nsum t f
0..0..2..4..10..18..30..solved at 46
0..0..2..4..8..16..28..59..103..173..solved at 212
val NSUM_UNIONS_NONZERO : thm =
  |- !f s.
         FINITE s /\
         (!t. t IN s ==> FINITE t) /\
         (!t1 t2 x.
              t1 IN s /\ t2 IN s /\ ~(t1 = t2) /\ x IN t1 /\ x IN t2
              ==> f x = 0)
         ==> nsum (UNIONS s) f = nsum s (\t. nsum t f)
val NSUM_CASES : thm =
  |- !s P f g.
         FINITE s
         ==> nsum s (\x. if P x then f x else g x) =
             nsum {x | x IN s /\ P x} f + nsum {x | x IN s /\ ~P x} g
val NSUM_CLOSED : thm =
  |- !P f s.
         P 0 /\ (!x y. P x /\ P y ==> P (x + y)) /\ (!a. a IN s ==> P (f a))
         ==> P (nsum s f)
val NSUM_ADD_NUMSEG : thm =
  |- !f g m n. nsum (m..n) (\i. f i + g i) = nsum (m..n) f + nsum (m..n) g
val NSUM_LE_NUMSEG : thm =
  |- !f g m n.
         (!i. m <= i /\ i <= n ==> f i <= g i)
         ==> nsum (m..n) f <= nsum (m..n) g
0..0..1..4..13..29..64..122..204..solved at 247
val NSUM_EQ_NUMSEG : thm =
  |- !f g m n.
         (!i. m <= i /\ i <= n ==> f i = g i)
         ==> nsum (m..n) f = nsum (m..n) g
val NSUM_CONST_NUMSEG : thm =
  |- !c m n. nsum (m..n) (\n. c) = ((n + 1) - m) * c
val NSUM_EQ_0_NUMSEG : thm =
  |- !f m n. (!i. m <= i /\ i <= n ==> f i = 0) ==> nsum (m..n) f = 0
val NSUM_EQ_0_IFF_NUMSEG : thm =
  |- !f m n. nsum (m..n) f = 0 <=> (!i. m <= i /\ i <= n ==> f i = 0)
0..0..1..7..18..38..78..147..solved at 161
val NSUM_TRIV_NUMSEG : thm = |- !f m n. n < m ==> nsum (m..n) f = 0
val NSUM_SING_NUMSEG : thm = |- !f n. nsum (n..n) f = f n
val NSUM_CLAUSES_NUMSEG : thm =
  |- (!m. nsum (m..0) f = (if m = 0 then f 0 else 0)) /\
     (!m n.
          nsum (m..SUC n) f =
          (if m <= SUC n then nsum (m..n) f + f (SUC n) else nsum (m..n) f))
val NSUM_SWAP_NUMSEG : thm =
  |- !a b c d f.
         nsum (a..b) (\i. nsum (c..d) (f i)) =
         nsum (c..d) (\j. nsum (a..b) (\i. f i j))
val NSUM_ADD_SPLIT : thm =
  |- !f m n p.
         m <= n + 1
         ==> nsum (m..n + p) f = nsum (m..n) f + nsum (n + 1..n + p) f
val NSUM_OFFSET : thm =
  |- !p f m n. nsum (m + p..n + p) f = nsum (m..n) (\i. f (i + p))
val NSUM_OFFSET_0 : thm =
  |- !f m n. m <= n ==> nsum (m..n) f = nsum (0..n - m) (\i. f (i + m))
val NSUM_CLAUSES_LEFT : thm =
  |- !f m n. m <= n ==> nsum (m..n) f = f m + nsum (m + 1..n) f
val NSUM_CLAUSES_RIGHT : thm =
  |- !f m n. 0 < n /\ m <= n ==> nsum (m..n) f = nsum (m..n - 1) f + f n
val NSUM_PAIR : thm =
  |- !f m n.
         nsum (2 * m..2 * n + 1) f =
         nsum (m..n) (\i. f (2 * i) + f (2 * i + 1))
val MOD_NSUM_MOD : thm =
  |- !f n s.
         FINITE s /\ ~(n = 0)
         ==> nsum s f MOD n = nsum s (\i. f i MOD n) MOD n
0..0..2..4..solved at 8
val MOD_NSUM_MOD_NUMSEG : thm =
  |- !f a b n.
         ~(n = 0) ==> nsum (a..b) f MOD n = nsum (a..b) (\i. f i MOD n) MOD n
Warning: inventing type variables
- : unit = ()
0..0..2..4..8..27..52..93..143..223..solved at 280
val CARD_UNIONS : thm =
  |- !s. FINITE s /\
         (!t. t IN s ==> FINITE t) /\
         (!t u. t IN s /\ u IN s /\ ~(t = u) ==> t INTER u = {})
         ==> CARD (UNIONS s) = nsum s CARD
- : unit = ()
Warning: inventing type variables
val sum : thm = |- sum = iterate (+)
0..0..1..2..solved at 8
0..0..solved at 2
0..0..solved at 2
val NEUTRAL_REAL_ADD : thm = |- neutral (+) = &0
0..0..1..2..solved at 8
0..0..solved at 2
0..0..solved at 2
val NEUTRAL_REAL_MUL : thm = |- neutral (*) = &1
val MONOIDAL_REAL_ADD : thm = |- monoidal (+)
val MONOIDAL_REAL_MUL : thm = |- monoidal (*)
Warning: inventing type variables
val SUM_DEGENERATE : thm =
  |- !f s. ~FINITE {x | x IN s /\ ~(f x = &0)} ==> sum s f = &0
Warning: inventing type variables
val SUM_CLAUSES : thm =
  |- (!f. sum {} f = &0) /\
     (!x f s.
          FINITE s
          ==> sum (x INSERT s) f =
              (if x IN s then sum s f else f x + sum s f))
Warning: inventing type variables
val SUM_UNION : thm =
  |- !f s t.
         FINITE s /\ FINITE t /\ DISJOINT s t
         ==> sum (s UNION t) f = sum s f + sum t f
Warning: inventing type variables
val SUM_DIFF : thm =
  |- !f s t. FINITE s /\ t SUBSET s ==> sum (s DIFF t) f = sum s f - sum t f
val SUM_INCL_EXCL : thm =
  |- !s t f.
         FINITE s /\ FINITE t
         ==> sum s f + sum t f = sum (s UNION t) f + sum (s INTER t) f
Warning: inventing type variables
val SUM_SUPPORT : thm = |- !f s. sum (support (+) f s) f = sum s f
Warning: inventing type variables
val SUM_ADD : thm =
  |- !f g s. FINITE s ==> sum s (\x. f x + g x) = sum s f + sum s g
Warning: inventing type variables
val SUM_ADD_GEN : thm =
  |- !f g s.
         FINITE {x | x IN s /\ ~(f x = &0)} /\
         FINITE {x | x IN s /\ ~(g x = &0)}
         ==> sum s (\x. f x + g x) = sum s f + sum s g
val SUM_EQ_0 : thm = |- !f s. (!x. x IN s ==> f x = &0) ==> sum s f = &0
val SUM_0 : thm = |- !s. sum s (\n. &0) = &0
val SUM_LMUL : thm = |- !f c s. sum s (\x. c * f x) = c * sum s f
val SUM_RMUL : thm = |- !f c s. sum s (\x. f x * c) = sum s f * c
Warning: inventing type variables
val SUM_NEG : thm = |- !f s. sum s (\x. --f x) = --sum s f
Warning: inventing type variables
val SUM_SUB : thm =
  |- !f g s. FINITE s ==> sum s (\x. f x - g x) = sum s f - sum s g
Warning: inventing type variables
val SUM_LE : thm =
  |- !f g s. FINITE s /\ (!x. x IN s ==> f x <= g x) ==> sum s f <= sum s g
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
val SUM_LT : thm =
  |- !f g s.
         FINITE s /\ (!x. x IN s ==> f x <= g x) /\ (?x. x IN s /\ f x < g x)
         ==> sum s f < sum s g
Warning: inventing type variables
0..0..2..6..15..30..73..134..229..368..553..800..1208..1747..2508..3645..5152..7046..solved at 7159
val SUM_LT_ALL : thm =
  |- !f g s.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < g x)
         ==> sum s f < sum s g
0..0..solved at 2
0..0..1..solved at 4
0..0..0..solved at 3
val SUM_POS_LT : thm =
  |- !f s.
         FINITE s /\ (!x. x IN s ==> &0 <= f x) /\ (?x. x IN s /\ &0 < f x)
         ==> &0 < sum s f
0..0..solved at 2
0..0..2..8..solved at 12
0..0..1..5..15..31..solved at 37
val SUM_POS_LT_ALL : thm =
  |- !s f.
         FINITE s /\ ~(s = {}) /\ (!i. i IN s ==> &0 < f i) ==> &0 < sum s f
Warning: inventing type variables
val SUM_EQ : thm =
  |- !f g s. (!x. x IN s ==> f x = g x) ==> sum s f = sum s g
Warning: inventing type variables
val SUM_ABS : thm =
  |- !f s. FINITE s ==> abs (sum s f) <= sum s (\x. abs (f x))
val SUM_ABS_LE : thm =
  |- !f g s.
         FINITE s /\ (!x. x IN s ==> abs (f x) <= g x)
         ==> abs (sum s f) <= sum s g
Warning: inventing type variables
val SUM_CONST : thm = |- !c s. FINITE s ==> sum s (\n. c) = &(CARD s) * c
val SUM_POS_LE : thm = |- !s. (!x. x IN s ==> &0 <= f x) ==> &0 <= sum s f
0..0..3..solved at 6
0..0..3..solved at 6
0..0..3..6..9..25..47..79..153..solved at 167
0..0..3..6..9..25..48..84..158..solved at 175
0..0..2..5..8..19..37..63..117..solved at 165
0..0..2..solved at 6
val SUM_POS_BOUND : thm =
  |- !f b s.
         FINITE s /\ (!x. x IN s ==> &0 <= f x) /\ sum s f <= b
         ==> (!x. x IN s ==> f x <= b)
Warning: inventing type variables
0..0..1..2..3..4..9..22..35..56..81..solved at 94
0..0..1..solved at 4
val SUM_POS_EQ_0 : thm =
  |- !f s.
         FINITE s /\ (!x. x IN s ==> &0 <= f x) /\ sum s f = &0
         ==> (!x. x IN s ==> f x = &0)
0..0..2..9..16..26..59..solved at 68
val SUM_ZERO_EXISTS : thm =
  |- !u s.
         FINITE s /\ sum s u = &0
         ==> (!i. i IN s ==> u i = &0) \/
             (?j k. j IN s /\ u j < &0 /\ k IN s /\ u k > &0)
Warning: inventing type variables
val SUM_DELETE : thm =
  |- !f s a. FINITE s /\ a IN s ==> sum (s DELETE a) f = sum s f - f a
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
val SUM_DELETE_CASES : thm =
  |- !f s a.
         FINITE s
         ==> sum (s DELETE a) f = (if a IN s then sum s f - f a else sum s f)
Warning: inventing type variables
val SUM_SING : thm = |- !f x. sum {x} f = f x
val SUM_DELTA : thm =
  |- !s a. sum s (\x. if x = a then b else &0) = (if a IN s then b else &0)
val SUM_SWAP : thm =
  |- !f s t.
         FINITE s /\ FINITE t
         ==> sum s (\i. sum t (f i)) = sum t (\j. sum s (\i. f i j))
Warning: inventing type variables
val SUM_IMAGE : thm =
  |- !f g s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
         ==> sum (IMAGE f s) g = sum s (g o f)
val SUM_SUPERSET : thm =
  |- !f u v.
         u SUBSET v /\ (!x. x IN v /\ ~(x IN u) ==> f x = &0)
         ==> sum v f = sum u f
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..1..5..15..solved at 22
0..0..2..6..22..76..261..solved at 597
val SUM_UNION_RZERO : thm =
  |- !f u v.
         FINITE u /\ (!x. x IN v /\ ~(x IN u) ==> f x = &0)
         ==> sum (u UNION v) f = sum u f
0..0..1..2..7..13..26..42..67..97..161..234..375..537..790..1087..1727..2450..solved at 2485
val SUM_UNION_LZERO : thm =
  |- !f u v.
         FINITE v /\ (!x. x IN u /\ ~(x IN v) ==> f x = &0)
         ==> sum (u UNION v) f = sum v f
Warning: inventing type variables
val SUM_RESTRICT : thm =
  |- !f s. FINITE s ==> sum s (\x. if x IN s then f x else &0) = sum s f
val SUM_BOUND : thm =
  |- !s f b.
         FINITE s /\ (!x. x IN s ==> f x <= b) ==> sum s f <= &(CARD s) * b
0..0..2..5..10..21..39..63..93..149..232..400..714..1313..2437..solved at 3778
val SUM_BOUND_GEN : thm =
  |- !s f b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x <= b / &(CARD s))
         ==> sum s f <= b
val SUM_ABS_BOUND : thm =
  |- !s f b.
         FINITE s /\ (!x. x IN s ==> abs (f x) <= b)
         ==> abs (sum s f) <= &(CARD s) * b
0..0..0..solved at 3
val SUM_BOUND_LT : thm =
  |- !s f b.
         FINITE s /\ (!x. x IN s ==> f x <= b) /\ (?x. x IN s /\ f x < b)
         ==> sum s f < &(CARD s) * b
Warning: inventing type variables
0..0..2..6..15..30..77..142..253..408..645..946..1535..2256..3565..5301..8800..12859..solved at 12962
val SUM_BOUND_LT_ALL : thm =
  |- !s f b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < b)
         ==> sum s f < &(CARD s) * b
0..0..2..5..10..25..47..75..111..180..279..473..834..1570..2960..5933..11269..solved at 19226
val SUM_BOUND_LT_GEN : thm =
  |- !s f b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < b / &(CARD s))
         ==> sum s f < b
Warning: inventing type variables
0..0..1..2..5..9..15..23..31..39..57..75..103..solved at 139
val SUM_UNION_EQ : thm =
  |- !s t u.
         FINITE u /\ s INTER t = {} /\ s UNION t = u
         ==> sum s f + sum t f = sum u f
0..0..1..2..6..11..19..34..49..70..117..164..237..386..553..836..1213..1681..2277..solved at 2734
val SUM_EQ_SUPERSET : thm =
  |- !f s t.
         FINITE t /\
         t SUBSET s /\
         (!x. x IN t ==> f x = g x) /\
         (!x. x IN s /\ ~(x IN t) ==> f x = &0)
         ==> sum s f = sum t g
Warning: inventing type variables
Warning: inventing type variables
val SUM_RESTRICT_SET : thm =
  |- !P s f. sum {x | x IN s /\ P x} f = sum s (\x. if P x then f x else &0)
Warning: inventing type variables
val SUM_SUM_RESTRICT : thm =
  |- !R f s t.
         FINITE s /\ FINITE t
         ==> sum s (\x. sum {y | y IN t /\ R x y} (\y. f x y)) =
             sum t (\y. sum {x | x IN s /\ R x y} (\x. f x y))
Warning: inventing type variables
val CARD_EQ_SUM : thm = |- !s. FINITE s ==> &(CARD s) = sum s (\x. &1)
val SUM_MULTICOUNT_GEN : thm =
  |- !R s t k.
         FINITE s /\
         FINITE t /\
         (!j. j IN t ==> CARD {i | i IN s /\ R i j} = k j)
         ==> sum s (\i. &(CARD {j | j IN t /\ R i j})) = sum t (\i. &(k i))
val SUM_MULTICOUNT : thm =
  |- !R s t k.
         FINITE s /\
         FINITE t /\
         (!j. j IN t ==> CARD {i | i IN s /\ R i j} = k)
         ==> sum s (\i. &(CARD {j | j IN t /\ R i j})) = &(k * CARD t)
0..0..1..3..solved at 8
0..0..0..solved at 3
0..0..solved at 2
val SUM_IMAGE_GEN : thm =
  |- !f g s.
         FINITE s
         ==> sum s g = sum (IMAGE f s) (\y. sum {x | x IN s /\ f x = y} g)
0..0..1..solved at 5
val SUM_GROUP : thm =
  |- !f g s t.
         FINITE s /\ IMAGE f s SUBSET t
         ==> sum t (\y. sum {x | x IN s /\ f x = y} g) = sum s g
Warning: inventing type variables
val REAL_OF_NUM_SUM : thm =
  |- !f s. FINITE s ==> &(nsum s f) = sum s (\x. &(f x))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val SUM_SUBSET : thm =
  |- !u v f.
         FINITE u /\
         FINITE v /\
         (!x. x IN u DIFF v ==> f x <= &0) /\
         (!x. x IN v DIFF u ==> &0 <= f x)
         ==> sum u f <= sum v f
0..0..1..3..solved at 7
0..0..solved at 2
0..0..1..4..10..25..solved at 41
0..0..1..solved at 4
val SUM_SUBSET_SIMPLE : thm =
  |- !u v f.
         FINITE v /\ u SUBSET v /\ (!x. x IN v DIFF u ==> &0 <= f x)
         ==> sum u f <= sum v f
val SUM_IMAGE_NONZERO : thm =
  |- !d i s.
         FINITE s /\
         (!x y. x IN s /\ y IN s /\ ~(x = y) /\ i x = i y ==> d (i x) = &0)
         ==> sum (IMAGE i s) d = sum s (d o i)
val SUM_BIJECTION : thm =
  |- !f p s.
         (!x. x IN s ==> p x IN s) /\
         (!y. y IN s ==> (?!x. x IN s /\ p x = y))
         ==> sum s f = sum s (f o p)
val SUM_SUM_PRODUCT : thm =
  |- !s t x.
         FINITE s /\ (!i. i IN s ==> FINITE (t i))
         ==> sum s (\i. sum (t i) (x i)) =
             sum {i,j | i IN s /\ j IN t i} (\(i,j). x i j)
val SUM_EQ_GENERAL : thm =
  |- !s t f g h.
         (!y. y IN t ==> (?!x. x IN s /\ h x = y)) /\
         (!x. x IN s ==> h x IN t /\ g (h x) = f x)
         ==> sum s f = sum t g
val SUM_EQ_GENERAL_INVERSES : thm =
  |- !s t f g h k.
         (!y. y IN t ==> k y IN s /\ h (k y) = y) /\
         (!x. x IN s ==> h x IN t /\ k (h x) = x /\ g (h x) = f x)
         ==> sum s f = sum t g
Warning: inventing type variables
val SUM_INJECTION : thm =
  |- !f p s.
         FINITE s /\
         (!x. x IN s ==> p x IN s) /\
         (!x y. x IN s /\ y IN s /\ p x = p y ==> x = y)
         ==> sum s (f o p) = sum s f
Warning: inventing type variables
val SUM_UNION_NONZERO : thm =
  |- !f s t.
         FINITE s /\ FINITE t /\ (!x. x IN s INTER t ==> f x = &0)
         ==> sum (s UNION t) f = sum s f + sum t f
0..0..2..4..10..18..30..solved at 46
0..0..2..4..8..16..28..59..103..173..solved at 214
val SUM_UNIONS_NONZERO : thm =
  |- !f s.
         FINITE s /\
         (!t. t IN s ==> FINITE t) /\
         (!t1 t2 x.
              t1 IN s /\ t2 IN s /\ ~(t1 = t2) /\ x IN t1 /\ x IN t2
              ==> f x = &0)
         ==> sum (UNIONS s) f = sum s (\t. sum t f)
val SUM_CASES : thm =
  |- !s P f g.
         FINITE s
         ==> sum s (\x. if P x then f x else g x) =
             sum {x | x IN s /\ P x} f + sum {x | x IN s /\ ~P x} g
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
val SUM_CASES_1 : thm =
  |- !s a.
         FINITE s /\ a IN s
         ==> sum s (\x. if x = a then y else f x) = sum s f + y - f a
0..0..solved at 2
0..0..solved at 2
0..0..2..solved at 6
0..0..0..1..2..3..8..solved at 16
val SUM_LE_INCLUDED : thm =
  |- !f g s t i.
         FINITE s /\
         FINITE t /\
         (!y. y IN t ==> &0 <= g y) /\
         (!x. x IN s ==> (?y. y IN t /\ i y = x /\ f x <= g y))
         ==> sum s f <= sum t g
0..0..0..0..solved at 4
val SUM_IMAGE_LE : thm =
  |- !f g s.
         FINITE s /\ (!x. x IN s ==> &0 <= g (f x))
         ==> sum (IMAGE f s) g <= sum s (g o f)
val SUM_CLOSED : thm =
  |- !P f s.
         P (&0) /\
         (!x y. P x /\ P y ==> P (x + y)) /\
         (!a. a IN s ==> P (f a))
         ==> P (sum s f)
val REAL_OF_NUM_SUM_GEN : thm =
  |- !f s.
         FINITE {i | i IN s /\ ~(f i = 0)}
         ==> &(nsum s f) = sum s (\x. &(f x))
val SUM_ADD_NUMSEG : thm =
  |- !f g m n. sum (m..n) (\i. f i + g i) = sum (m..n) f + sum (m..n) g
val SUM_SUB_NUMSEG : thm =
  |- !f g m n. sum (m..n) (\i. f i - g i) = sum (m..n) f - sum (m..n) g
val SUM_LE_NUMSEG : thm =
  |- !f g m n.
         (!i. m <= i /\ i <= n ==> f i <= g i)
         ==> sum (m..n) f <= sum (m..n) g
0..0..1..4..13..29..64..122..204..solved at 247
val SUM_EQ_NUMSEG : thm =
  |- !f g m n.
         (!i. m <= i /\ i <= n ==> f i = g i) ==> sum (m..n) f = sum (m..n) g
val SUM_ABS_NUMSEG : thm =
  |- !f m n. abs (sum (m..n) f) <= sum (m..n) (\i. abs (f i))
val SUM_CONST_NUMSEG : thm =
  |- !c m n. sum (m..n) (\n. c) = &((n + 1) - m) * c
val SUM_EQ_0_NUMSEG : thm =
  |- !f m n. (!i. m <= i /\ i <= n ==> f i = &0) ==> sum (m..n) f = &0
0..0..1..7..18..38..78..147..solved at 161
val SUM_TRIV_NUMSEG : thm = |- !f m n. n < m ==> sum (m..n) f = &0
val SUM_POS_LE_NUMSEG : thm =
  |- !m n f. (!p. m <= p /\ p <= n ==> &0 <= f p) ==> &0 <= sum (m..n) f
0..0..1..2..6..12..28..48..72..100..147..195..316..458..652..894..1207..1592..2128..2732..3491..4404..5471..6812..8440..10222..12256..14610..17294..solved at 19757
val SUM_POS_EQ_0_NUMSEG : thm =
  |- !f m n.
         (!p. m <= p /\ p <= n ==> &0 <= f p) /\ sum (m..n) f = &0
         ==> (!p. m <= p /\ p <= n ==> f p = &0)
val SUM_SING_NUMSEG : thm = |- !f n. sum (n..n) f = f n
val SUM_CLAUSES_NUMSEG : thm =
  |- (!m. sum (m..0) f = (if m = 0 then f 0 else &0)) /\
     (!m n.
          sum (m..SUC n) f =
          (if m <= SUC n then sum (m..n) f + f (SUC n) else sum (m..n) f))
val SUM_SWAP_NUMSEG : thm =
  |- !a b c d f.
         sum (a..b) (\i. sum (c..d) (f i)) =
         sum (c..d) (\j. sum (a..b) (\i. f i j))
val SUM_ADD_SPLIT : thm =
  |- !f m n p.
         m <= n + 1
         ==> sum (m..n + p) f = sum (m..n) f + sum (n + 1..n + p) f
val SUM_OFFSET : thm =
  |- !p f m n. sum (m + p..n + p) f = sum (m..n) (\i. f (i + p))
val SUM_OFFSET_0 : thm =
  |- !f m n. m <= n ==> sum (m..n) f = sum (0..n - m) (\i. f (i + m))
val SUM_CLAUSES_LEFT : thm =
  |- !f m n. m <= n ==> sum (m..n) f = f m + sum (m + 1..n) f
val SUM_CLAUSES_RIGHT : thm =
  |- !f m n. 0 < n /\ m <= n ==> sum (m..n) f = sum (m..n - 1) f + f n
val SUM_PAIR : thm =
  |- !f m n.
         sum (2 * m..2 * n + 1) f =
         sum (m..n) (\i. f (2 * i) + f (2 * i + 1))
val REAL_OF_NUM_SUM_NUMSEG : thm =
  |- !f m n. &(nsum (m..n) f) = sum (m..n) (\i. &(f i))
val SUM_PARTIAL_SUC : thm =
  |- !f g m n.
         sum (m..n) (\k. f k * (g (k + 1) - g k)) =
         (if m <= n
          then f (n + 1) * g (n + 1) -
               f m * g m -
               sum (m..n) (\k. g (k + 1) * (f (k + 1) - f k))
          else &0)
val SUM_PARTIAL_PRE : thm =
  |- !f g m n.
         sum (m..n) (\k. f k * (g k - g (k - 1))) =
         (if m <= n
          then f (n + 1) * g n -
               f m * g (m - 1) -
               sum (m..n) (\k. g k * (f (k + 1) - f k))
          else &0)
val SUM_DIFFS : thm =
  |- !m n.
         sum (m..n) (\k. f k - f (k + 1)) =
         (if m <= n then f m - f (n + 1) else &0)
val SUM_DIFFS_ALT : thm =
  |- !m n.
         sum (m..n) (\k. f (k + 1) - f k) =
         (if m <= n then f (n + 1) - f m else &0)
val SUM_COMBINE_R : thm =
  |- !f m n p.
         m <= n + 1 /\ n <= p
         ==> sum (m..n) f + sum (n + 1..p) f = sum (m..p) f
val SUM_COMBINE_L : thm =
  |- !f m n p.
         0 < n /\ m <= n /\ n <= p + 1
         ==> sum (m..n - 1) f + sum (n..p) f = sum (m..p) f
Warning: inventing type variables
- : unit = ()
val EXPAND_SUM_CONV : conv = <fun>
val REAL_SUB_POW : thm =
  |- !x y n.
         1 <= n
         ==> x pow n - y pow n =
             (x - y) * sum (0..n - 1) (\i. x pow i * y pow (n - 1 - i))
val REAL_SUB_POW_R1 : thm =
  |- !x n. 1 <= n ==> x pow n - &1 = (x - &1) * sum (0..n - 1) (\i. x pow i)
val REAL_SUB_POW_L1 : thm =
  |- !x n. 1 <= n ==> &1 - x pow n = (&1 - x) * sum (0..n - 1) (\i. x pow i)
val REAL_SUB_POLYFUN : thm =
  |- !a x y n.
         1 <= n
         ==> sum (0..n) (\i. a i * x pow i) - sum (0..n) (\i. a i * y pow i) =
             (x - y) *
             sum (0..n - 1)
             (\j. sum (j + 1..n) (\i. a i * y pow (i - j - 1)) * x pow j)
val REAL_SUB_POLYFUN_ALT : thm =
  |- !a x y n.
         1 <= n
         ==> sum (0..n) (\i. a i * x pow i) - sum (0..n) (\i. a i * y pow i) =
             (x - y) *
             sum (0..n - 1)
             (\j. sum (0..n - j - 1) (\k. a (j + k + 1) * y pow k) * x pow j)
Warning: inventing type variables
0..0..1..solved at 5
0..0..1..3..5..10..19..31..60..103..157..249..361..504..748..1123..1718..2921..solved at 3656
Warning: inventing type variables
0..0..1..3..7..16..35..68..116..212..392..759..solved at 1033
val REAL_POLYFUN_ROOTBOUND : thm =
  |- !n c.
         ~(!i. i IN 0..n ==> c i = &0)
         ==> FINITE {x | sum (0..n) (\i. c i * x pow i) = &0} /\
             CARD {x | sum (0..n) (\i. c i * x pow i) = &0} <= n
val REAL_POLYFUN_FINITE_ROOTS : thm =
  |- !n c.
         FINITE {x | sum (0..n) (\i. c i * x pow i) = &0} <=>
         (?i. i IN 0..n /\ ~(c i = &0))
val REAL_POLYFUN_EQ_0 : thm =
  |- !n c.
         (!x. sum (0..n) (\i. c i * x pow i) = &0) <=>
         (!i. i IN 0..n ==> c i = &0)
0..0..solved at 2
0..0..solved at 2
0..0..1..3..8..19..39..solved at 69
0..0..solved at 2
0..0..1..5..20..solved at 25
0..0..solved at 2
0..0..2..8..27..solved at 33
val REAL_POLYFUN_EQ_CONST : thm =
  |- !n c k.
         (!x. sum (0..n) (\i. c i * x pow i) = k) <=>
         c 0 = k /\ (!i. i IN 1..n ==> c i = &0)
val polynomial_function : thm =
  |- !p. polynomial_function p <=>
         (?m c. !x. p x = sum (0..m) (\i. c i * x pow i))
val POLYNOMIAL_FUNCTION_CONST : thm = |- !c. polynomial_function (\x. c)
val POLYNOMIAL_FUNCTION_ID : thm = |- polynomial_function (\x. x)
val POLYNOMIAL_FUNCTION_I : thm = |- polynomial_function I
val POLYNOMIAL_FUNCTION_ADD : thm =
  |- !p q.
         polynomial_function p /\ polynomial_function q
         ==> polynomial_function (\x. p x + q x)
val POLYNOMIAL_FUNCTION_LMUL : thm =
  |- !p c. polynomial_function p ==> polynomial_function (\x. c * p x)
val POLYNOMIAL_FUNCTION_RMUL : thm =
  |- !p c. polynomial_function p ==> polynomial_function (\x. p x * c)
val POLYNOMIAL_FUNCTION_NEG : thm =
  |- !p. polynomial_function (\x. --p x) <=> polynomial_function p
val POLYNOMIAL_FUNCTION_SUB : thm =
  |- !p q.
         polynomial_function p /\ polynomial_function q
         ==> polynomial_function (\x. p x - q x)
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
val POLYNOMIAL_FUNCTION_MUL : thm =
  |- !p q.
         polynomial_function p /\ polynomial_function q
         ==> polynomial_function (\x. p x * q x)
val POLYNOMIAL_FUNCTION_SUM : thm =
  |- !s p.
         FINITE s /\ (!i. i IN s ==> polynomial_function (\x. p x i))
         ==> polynomial_function (\x. sum s (p x))
val POLYNOMIAL_FUNCTION_POW : thm =
  |- !p n. polynomial_function p ==> polynomial_function (\x. p x pow n)
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
val POLYNOMIAL_FUNCTION_INDUCT : thm =
  |- !P. P (\x. x) /\
         (!c. P (\x. c)) /\
         (!p q. P p /\ P q ==> P (\x. p x + q x)) /\
         (!p q. P p /\ P q ==> P (\x. p x * q x))
         ==> (!p. polynomial_function p ==> P p)
val POLYNOMIAL_FUNCTION_o : thm =
  |- !p q.
         polynomial_function p /\ polynomial_function q
         ==> polynomial_function (p o q)
val POLYNOMIAL_FUNCTION_FINITE_ROOTS : thm =
  |- !p a.
         polynomial_function p ==> (FINITE {x | p x = a} <=> ~(!x. p x = a))
- : unit = ()
- : unit = ()
File "iterate.ml" already loaded
- : unit = ()
val dimindex : thm =
  |- !s. dimindex s = (if FINITE (:A) then CARD (:A) else 1)
val DIMINDEX_NONZERO : thm = |- !s. ~(dimindex s = 0)
val DIMINDEX_GE_1 : thm = |- !s. 1 <= dimindex s
val DIMINDEX_UNIV : thm = |- !s. dimindex s = dimindex (:A)
0..0..1..2..5..9..15..solved at 32
0..0..2..solved at 6
val DIMINDEX_UNIQUE : thm = |- (:A) HAS_SIZE n ==> dimindex (:A) = n
val finite_image_tybij : thm =
  |- (!a. finite_index (dest_finite_image a) = a) /\
     (!r. r IN 1..dimindex (:A) <=> dest_finite_image (finite_index r) = r)
0..0..0..1..2..3..5..7..9..solved at 16
val FINITE_IMAGE_IMAGE : thm =
  |- (:(A)finite_image) = IMAGE finite_index (1..dimindex (:A))
0..0..1..2..5..9..15..30..47..76..solved at 127
val HAS_SIZE_FINITE_IMAGE : thm =
  |- !s. (:(A)finite_image) HAS_SIZE dimindex s
0..0..1..solved at 4
val CARD_FINITE_IMAGE : thm = |- !s. CARD (:(A)finite_image) = dimindex s
0..0..1..solved at 4
val FINITE_FINITE_IMAGE : thm = |- FINITE (:(A)finite_image)
val DIMINDEX_FINITE_IMAGE : thm = |- !s t. dimindex s = dimindex t
0..0..0..1..4..solved at 9
0..0..1..2..5..9..15..30..47..76..solved at 124
val FINITE_INDEX_WORKS : thm =
  |- !i. ?!n. 1 <= n /\ n <= dimindex (:A) /\ finite_index n = i
0..0..1..2..5..9..15..22..solved at 36
0..0..solved at 2
val FINITE_INDEX_INJ : thm =
  |- !i j.
         1 <= i /\ i <= dimindex (:A) /\ 1 <= j /\ j <= dimindex (:A)
         ==> (finite_index i = finite_index j <=> i = j)
0..0..solved at 2
0..0..1..2..6..10..solved at 16
val FORALL_FINITE_INDEX : thm =
  |- (!k. P k) <=> (!i. 1 <= i /\ i <= dimindex (:N) ==> P (finite_index i))
val cart_tybij : thm =
  |- (!a. mk_cart (dest_cart a) = a) /\ (!r. T <=> dest_cart (mk_cart r) = r)
- : unit = ()
Warning: inventing type variables
val finite_index : thm = |- !x i. x$i = dest_cart x (finite_index i)
0..0..solved at 2
0..0..1..2..6..12..27..solved at 44
val CART_EQ : thm =
  |- !x y. x = y <=> (!i. 1 <= i /\ i <= dimindex (:B) ==> x$i = y$i)
- : unit = ()
val lambda : thm =
  |- !g. (lambda) g = (@f. !i. 1 <= i /\ i <= dimindex (:B) ==> f$i = g i)
0..0..1..2..5..9..15..solved at 30
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val LAMBDA_BETA : thm =
  |- !i. 1 <= i /\ i <= dimindex (:B) ==> (lambda) g$i = g i
0..0..1..2..5..9..solved at 16
0..0..1..2..5..9..solved at 16
val LAMBDA_UNIQUE : thm =
  |- !f g.
         (!i. 1 <= i /\ i <= dimindex (:B) ==> f$i = g i) <=> (lambda) g = f
Warning: inventing type variables
val LAMBDA_ETA : thm = |- !g. (lambda i. g$i) = g
0..0..0..0..4..9..18..30..solved at 42
val FINITE_INDEX_INRANGE : thm =
  |- !i. ?k. 1 <= k /\ k <= dimindex (:N) /\ (!x. x$i = x$k)
0..0..0..0..0..4..10..16..26..36..46..64..82..100..131..162..193..solved at 219
val FINITE_INDEX_INRANGE_2 : thm =
  |- !i. ?k. 1 <= k /\
             k <= dimindex (:N) /\
             (!x. x$i = x$k) /\
             (!y. y$i = y$k)
val CART_EQ_FULL : thm = |- !x y. x = y <=> (!i. x$i = y$i)
val finite_sum_tybij : thm =
  |- (!a. mk_finite_sum (dest_finite_sum a) = a) /\
     (!r. r IN 1..dimindex (:A) + dimindex (:B) <=>
          dest_finite_sum (mk_finite_sum r) = r)
val pastecart : thm =
  |- !f g.
         pastecart f g =
         (lambda i. if i <= dimindex (:M) then f$i else g$(i - dimindex (:M)))
val fstcart : thm = |- !f. fstcart f = (lambda i. f$i)
val sndcart : thm = |- !f. sndcart f = (lambda i. f$(i + dimindex (:M)))
0..0..0..1..2..3..5..7..9..solved at 16
val FINITE_SUM_IMAGE : thm =
  |- (:(A,B)finite_sum) =
     IMAGE mk_finite_sum (1..dimindex (:A) + dimindex (:B))
0..0..1..2..5..9..15..40..67..116..solved at 201
val DIMINDEX_HAS_SIZE_FINITE_SUM : thm =
  |- (:(M,N)finite_sum) HAS_SIZE dimindex (:M) + dimindex (:N)
val DIMINDEX_FINITE_SUM : thm =
  |- dimindex (:(M,N)finite_sum) = dimindex (:M) + dimindex (:N)
val FSTCART_PASTECART : thm = |- !x y. fstcart (pastecart x y) = x
val SNDCART_PASTECART : thm = |- !x y. sndcart (pastecart x y) = y
Warning: inventing type variables
val PASTECART_FST_SND : thm = |- !z. pastecart (fstcart z) (sndcart z) = z
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..1..2..6..12..27..48..solved at 81
val PASTECART_EQ : thm =
  |- !x y. x = y <=> fstcart x = fstcart y /\ sndcart x = sndcart y
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..solved at 6
val FORALL_PASTECART : thm = |- (!p. P p) <=> (!x y. P (pastecart x y))
Warning: inventing type variables
0..0..1..2..8..15..solved at 40
0..0..solved at 2
val EXISTS_PASTECART : thm = |- (?p. P p) <=> (?x y. P (pastecart x y))
val PASTECART_INJ : thm =
  |- !x y w z. pastecart x y = pastecart w z <=> x = w /\ y = z
0..0..0..1..2..3..5..7..9..solved at 16
0..0..1..2..5..9..15..30..47..76..solved at 124
0..0..solved at 2
val define_finite_type : int -> thm = <fun>
val HAS_SIZE_1 : thm = |- (:1) HAS_SIZE 1
val HAS_SIZE_2 : thm = |- (:2) HAS_SIZE 2
val HAS_SIZE_3 : thm = |- (:3) HAS_SIZE 3
val HAS_SIZE_4 : thm = |- (:4) HAS_SIZE 4
val DIMINDEX_1 : thm = |- dimindex (:1) = 1
val DIMINDEX_2 : thm = |- dimindex (:2) = 2
val DIMINDEX_3 : thm = |- dimindex (:3) = 3
val DIMINDEX_4 : thm = |- dimindex (:4) = 4
0..0..solved at 3
0..0..solved at 2
0..0..2..4..7..19..solved at 33
0..0..1..2..3..10..solved at 17
0..0..2..4..7..19..solved at 33
0..0..1..2..3..10..solved at 16
0..0..3..6..17..36..64..solved at 95
0..0..2..4..13..27..47..solved at 60
val FINITE_CART : thm =
  |- !P. (!i. 1 <= i /\ i <= dimindex (:N) ==> FINITE {x | P i x})
         ==> FINITE {v | !i. 1 <= i /\ i <= dimindex (:N) ==> P i (v$i)}
0..0..1..2..6..12..27..solved at 44
0..0..solved at 2
val HAS_SIZE_CART_UNIV : thm =
  |- !m. (:A) HAS_SIZE m ==> (:A^N) HAS_SIZE m EXP dimindex (:N)
0..0..1..3..8..14..solved at 20
val CARD_CART_UNIV : thm =
  |- FINITE (:A) ==> CARD (:A^N) = CARD (:A) EXP dimindex (:N)
0..0..1..3..8..13..solved at 19
val FINITE_CART_UNIV : thm = |- FINITE (:A) ==> FINITE (:A^N)
val vector : thm = |- !l. vector l = (lambda i. EL (i - 1) l)
Warning: inventing type variables
0..0..solved at 2
0..0..0..0..solved at 4
val IN_ELIM_PASTECART_THM : thm =
  |- !P a b. pastecart a b IN {pastecart x y | P x y} <=> P a b
- : unit = ()
val PCROSS : thm = |- !s t. s PCROSS t = {pastecart x y | x IN s /\ y IN t}
Warning: inventing type variables
val FORALL_IN_PCROSS : thm =
  |- (!z. z IN s PCROSS t ==> P z) <=>
     (!x y. x IN s /\ y IN t ==> P (pastecart x y))
Warning: inventing type variables
val EXISTS_IN_PCROSS : thm =
  |- (?z. z IN s PCROSS t /\ P z) <=>
     (?x y. x IN s /\ y IN t /\ P (pastecart x y))
Warning: inventing type variables
val PASTECART_IN_PCROSS : thm =
  |- !s t x y. pastecart x y IN s PCROSS t <=> x IN s /\ y IN t
Warning: inventing type variables
0..0..0..0..solved at 4
0..0..solved at 2
0..0..solved at 2
val PCROSS_EQ_EMPTY : thm = |- !s t. s PCROSS t = {} <=> s = {} \/ t = {}
Warning: inventing type variables
val PCROSS_EMPTY : thm = |- (!s. s PCROSS {} = {}) /\ (!t. {} PCROSS t = {})
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..2..solved at 6
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
val SUBSET_PCROSS : thm =
  |- !s t s' t'.
         s PCROSS t SUBSET s' PCROSS t' <=>
         s = {} \/ t = {} \/ s SUBSET s' /\ t SUBSET t'
Warning: inventing type variables
val PCROSS_MONO : thm =
  |- !s t s' t'.
         s SUBSET s' /\ t SUBSET t' ==> s PCROSS t SUBSET s' PCROSS t'
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 4
0..0..solved at 3
0..0..solved at 4
0..0..solved at 3
0..0..solved at 4
0..0..solved at 3
0..0..solved at 4
0..0..solved at 3
0..0..solved at 4
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 4
0..0..2..solved at 5
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..2..solved at 5
0..0..solved at 3
0..0..2..solved at 6
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 4
0..0..solved at 3
0..0..solved at 4
0..0..solved at 3
0..0..solved at 4
0..0..solved at 3
0..0..solved at 4
0..0..solved at 3
0..0..solved at 4
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 4
0..0..2..solved at 5
0..0..solved at 3
0..0..2..solved at 6
0..0..solved at 3
0..0..2..solved at 5
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..2..solved at 5
0..0..solved at 3
0..0..2..solved at 6
0..0..solved at 3
0..0..2..solved at 5
0..0..solved at 3
0..0..2..solved at 6
0..0..solved at 3
0..0..2..solved at 5
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..2..solved at 5
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..solved at 3
0..0..solved at 3
0..0..solved at 4
0..0..solved at 4
0..0..solved at 3
0..0..solved at 3
0..0..solved at 4
0..0..solved at 4
0..0..solved at 3
0..0..solved at 3
0..0..solved at 4
0..0..solved at 4
0..0..solved at 3
0..0..solved at 3
0..0..solved at 4
0..0..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
val PCROSS_EQ : thm =
  |- !s s' t t'.
         s PCROSS t = s' PCROSS t' <=>
         (s = {} \/ t = {}) /\ (s' = {} \/ t' = {}) \/ s = s' /\ t = t'
val UNIV_PCROSS_UNIV : thm = |- (:A^M) PCROSS (:A^N) = (:A^(M,N)finite_sum)
val HAS_SIZE_PCROSS : thm =
  |- !s t m n. s HAS_SIZE m /\ t HAS_SIZE n ==> s PCROSS t HAS_SIZE m * n
0..0..1..2..5..8..solved at 16
val FINITE_PCROSS : thm =
  |- !s t. FINITE s /\ FINITE t ==> FINITE (s PCROSS t)
0..0..0..0..solved at 4
0..0..0..0..solved at 4
val FINITE_PCROSS_EQ : thm =
  |- !s t. FINITE (s PCROSS t) <=> s = {} \/ t = {} \/ FINITE s /\ FINITE t
0..0..solved at 2
0..0..0..0..solved at 4
val IMAGE_FSTCART_PCROSS : thm =
  |- !s t. IMAGE fstcart (s PCROSS t) = (if t = {} then {} else s)
0..0..solved at 2
0..0..solved at 2
0..0..0..solved at 3
val IMAGE_SNDCART_PCROSS : thm =
  |- !s t. IMAGE sndcart (s PCROSS t) = (if s = {} then {} else t)
Warning: inventing type variables
val PCROSS_INTER : thm =
  |- (!s t u. s PCROSS (t INTER u) = s PCROSS t INTER s PCROSS u) /\
     (!s t u. (s INTER t) PCROSS u = s PCROSS u INTER t PCROSS u)
Warning: inventing type variables
val PCROSS_UNION : thm =
  |- (!s t u. s PCROSS (t UNION u) = s PCROSS t UNION s PCROSS u) /\
     (!s t u. (s UNION t) PCROSS u = s PCROSS u UNION t PCROSS u)
Warning: inventing type variables
val PCROSS_DIFF : thm =
  |- (!s t u. s PCROSS (t DIFF u) = s PCROSS t DIFF s PCROSS u) /\
     (!s t u. (s DIFF t) PCROSS u = s PCROSS u DIFF t PCROSS u)
Warning: inventing type variables
val INTER_PCROSS : thm =
  |- !s s' t t'.
         s PCROSS t INTER s' PCROSS t' = (s INTER s') PCROSS (t INTER t')
Warning: inventing type variables
0..0..0..0..0..solved at 5
0..0..0..solved at 3
0..0..0..solved at 3
0..0..0..0..solved at 4
0..0..solved at 2
0..0..0..solved at 3
0..0..0..0..solved at 4
0..0..0..solved at 3
0..0..solved at 2
val PCROSS_UNIONS_UNIONS : thm =
  |- !f g. UNIONS f PCROSS UNIONS g = UNIONS {s PCROSS t | s IN f /\ t IN g}
val PCROSS_UNIONS : thm =
  |- (!s f. s PCROSS UNIONS f = UNIONS {s PCROSS t | t IN f}) /\
     (!f t. UNIONS f PCROSS t = UNIONS {s PCROSS t | s IN f})
- : unit = ()
File "cart.ml" already loaded
- : unit = ()
Warning: inventing type variables
val CASEWISE_DEF : thm =
  |- CASEWISE [] f x = (@y. T) /\
     CASEWISE (CONS h t) f x =
     (if ?y. FST h y = x then SND h f (@y. FST h y = x) else CASEWISE t f x)
Warning: inventing type variables
val CASEWISE : thm =
  |- CASEWISE [] f x = (@y. T) /\
     CASEWISE (CONS (s,t) clauses) f x =
     (if ?y. s y = x then t f (@y. s y = x) else CASEWISE clauses f x)
Warning: inventing type variables
0..0..0..0..1..9..solved at 20
0..0..0..0..3..12..solved at 27
0..0..1..2..6..16..solved at 31
0..0..solved at 2
0..0..1..2..10..23..45..73..109..150..237..341..solved at 482
0..0..2..7..17..57..111..252..solved at 259
val CASEWISE_CASES : thm =
  |- !clauses c x.
         (?s t a.
              MEM (s,t) clauses /\ s a = x /\ CASEWISE clauses c x = t c a) \/
         ~(?s t a. MEM (s,t) clauses /\ s a = x) /\
         CASEWISE clauses c x = (@y. T)
0..0..1..2..5..9..15..24..33..44..67..90..125..186..247..334..524..solved at 604
val CASEWISE_WORKS : thm =
  |- !clauses c.
         (!s t s' t' x y.
              MEM (s,t) clauses /\ MEM (s',t') clauses /\ s x = s' y
              ==> t c x = t' c y)
         ==> ALL (\(s,t). !x. CASEWISE clauses c (s x) = t c x) clauses
Warning: inventing type variables
val admissible : thm =
  |- !p (<<) s t.
         admissible (<<) p s t <=>
         (!f g a.
              p f a /\ p g a /\ (!z. z << s a ==> f z = g z)
              ==> t f a = t g a)
val tailadmissible : thm =
  |- !(<<) s p t.
         tailadmissible (<<) p s t <=>
         (?P G H.
              (!f a y. P f a /\ y << G f a ==> y << s a) /\
              (!f g a.
                   (!z. z << s a ==> f z = g z)
                   ==> (P f a <=> P g a) /\ G f a = G g a /\ H f a = H g a) /\
              (!f a. p f a ==> t f a = (if P f a then f (G f a) else H f a)))
Warning: inventing type variables
val superadmissible : thm =
  |- !(<<) p s t.
         superadmissible (<<) p s t <=>
         admissible (<<) (\f a. T) s p ==> tailadmissible (<<) p s t
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 3
0..0..solved at 4
0..0..solved at 5
val MATCH_SEQPATTERN : thm =
  |- _MATCH x (_SEQPATTERN r s) =
     (if ?y. r x y then _MATCH x r else _MATCH x s)
Warning: inventing type variables
val ADMISSIBLE_CONST : thm = |- !p s c. admissible (<<) p s (\f. c)
0..0..1..3..solved at 7
val ADMISSIBLE_BASE : thm =
  |- !(<<) p s t.
         (!f a. p f a ==> t a << s a) ==> admissible (<<) p s (\f x. f (t x))
0..0..1..2..6..11..19..28..37..46..73..100..145..212..279..368..509..650..841..1124..1407..1782..2305..2828..3499..solved at 4403
val ADMISSIBLE_COMB : thm =
  |- !(<<) p s g y.
         admissible (<<) p s g /\ admissible (<<) p s y
         ==> admissible (<<) p s (\f x. g f x (y f x))
0..0..1..2..6..12..25..47..84..141..245..solved at 353
val ADMISSIBLE_RAND : thm =
  |- !(<<) p s g y.
         admissible (<<) p s y ==> admissible (<<) p s (\f x. g x (y f x))
0..0..1..2..3..7..35..80..139..252..387..solved at 519
0..0..1..2..3..7..35..80..139..252..387..solved at 463
val ADMISSIBLE_LAMBDA : thm =
  |- !(<<) p s t.
         admissible (<<) (\f (u,x). p f x) (\(u,x). s x) (\f (u,x). t f u x)
         ==> admissible (<<) p s (\f x u. t f u x)
0..0..1..2..6..11..19..29..39..50..91..141..235..375..577..845..1399..solved at 1533
val ADMISSIBLE_NEST : thm =
  |- !(<<) p s t.
         admissible (<<) p s t /\ (!f a. p f a ==> t f a << s a)
         ==> admissible (<<) p s (\f x. f (t f x))
Warning: inventing type variables
val ADMISSIBLE_COND : thm =
  |- !(<<) p P s h k.
         admissible (<<) p s P /\
         admissible (<<) (\f x. p f x /\ P f x) s h /\
         admissible (<<) (\f x. p f x /\ ~P f x) s k
         ==> admissible (<<) p s (\f x. if P f x then h f x else k f x)
Warning: inventing type variables
0..0..1..2..6..12..24..45..76..125..208..solved at 288
0..0..2..4..8..16..28..44..69..101..151..223..solved at 286
0..0..2..4..8..16..28..44..69..100..149..220..309..441..solved at 521
0..0..solved at 2
val ADMISSIBLE_MATCH : thm =
  |- !(<<) p s e c.
         admissible (<<) p s e /\ admissible (<<) p s (\f x. c f x (e f x))
         ==> admissible (<<) p s (\f x. _MATCH (e f x) (c f x))
Warning: inventing type variables
0..0..1..2..6..11..19..38..65..106..192..292..436..solved at 553
0..0..2..4..9..18..52..121..210..359..620..solved at 701
0..0..2..4..9..18..52..121..210..359..620..solved at 878
0..0..3..6..12..25..83..212..381..638..1118..1786..2598..solved at 2715
val ADMISSIBLE_SEQPATTERN : thm =
  |- !(<<) p s c1 c2 e.
         admissible (<<) p s (\f x. ?y. c1 f x (e f x) y) /\
         admissible (<<) (\f x. p f x /\ (?y. c1 f x (e f x) y)) s
         (\f x. c1 f x (e f x)) /\
         admissible (<<) (\f x. p f x /\ ~(?y. c1 f x (e f x) y)) s
         (\f x. c2 f x (e f x))
         ==> admissible (<<) p s
             (\f x. _SEQPATTERN (c1 f x) (c2 f x) (e f x))
Warning: inventing type variables
0..0..1..2..7..13..27..43..69..98..153..212..305..432..589..787..1065..1365..1753..2218..2731..3327..4085..4879..5831..solved at 6125
0..0..1..2..7..13..27..43..69..98..153..212..305..432..589..787..1063..1361..1745..2206..2715..3307..4060..4849..5795..6839..7919..9094..10526..11984..13723..solved at 14089
0..0..1..2..7..13..27..43..69..98..153..212..305..410..545..699..915..1153..1461..1852..2291..2819..3481..4179..5007..5941..6911..7984..9353..10748..12463..14302..16229..18272..20734..23204..26101..solved at 26928
0..0..1..2..7..13..27..43..69..98..153..212..305..410..545..699..915..1153..1461..1852..2291..2819..3479..4175..4999..5929..6895..7964..9326..10714..12419..14242..16153..18174..20613..23060..25933..29025..32229..35676..39609..43606..48073..solved at 49267
val ADMISSIBLE_UNGUARDED_PATTERN : thm =
  |- !(<<) p s pat e t y.
         admissible (<<) p s pat /\
         admissible (<<) p s e /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x) s t /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x) s y
         ==> admissible (<<) p s
             (\f x.
                  _UNGUARDED_PATTERN (GEQ (pat f x) (e f x))
                  (GEQ (t f x) (y f x)))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..1..2..7..19..42..78..137..solved at 187
0..0..1..2..7..19..42..78..137..solved at 187
0..0..1..2..3..7..15..33..92..182..286..491..717..1000..1344..solved at 1660
0..0..1..2..3..7..15..33..92..182..286..491..717..1000..1344..solved at 1547
0..0..1..2..7..13..26..42..66..109..184..282..450..645..906..1214..1585..solved at 1922
0..0..1..2..7..13..26..42..66..109..184..282..450..645..906..1214..1585..solved at 1922
val ADMISSIBLE_GUARDED_PATTERN : thm =
  |- !(<<) p s pat q e t y.
         admissible (<<) p s pat /\
         admissible (<<) p s e /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x /\ q f x) s t /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x) s q /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x /\ q f x) s y
         ==> admissible (<<) p s
             (\f x.
                  _GUARDED_PATTERN (GEQ (pat f x) (e f x)) (q f x)
                  (GEQ (t f x) (y f x)))
0..0..1..2..6..12..25..41..68..113..197..307..500..726..1041..1410..1881..solved at 2329
val ADMISSIBLE_NSUM : thm =
  |- !(<<) p s h a b.
         admissible (<<) (\f (k,x). a x <= k /\ k <= b x /\ p f x)
         (\(k,x). s x)
         (\f (k,x). h f x k)
         ==> admissible (<<) p s (\f x. nsum (a x..b x) (h f x))
0..0..1..2..6..12..25..41..68..113..197..307..500..726..1041..1410..1881..solved at 2329
val ADMISSIBLE_SUM : thm =
  |- !(<<) p s h a b.
         admissible (<<) (\f (k,x). a x <= k /\ k <= b x /\ p f x)
         (\(k,x). s x)
         (\f (k,x). h f x k)
         ==> admissible (<<) p s (\f x. sum (a x..b x) (h f x))
Warning: inventing type variables
0..0..solved at 2
Warning: inventing type variables
0..0..1..2..7..19..42..78..137..solved at 187
0..0..1..2..3..7..13..23..41..70..112..191..solved at 250
val ADMISSIBLE_MAP : thm =
  |- !(<<) p s h l.
         admissible (<<) p s l /\
         admissible (<<) (\f (y,x). p f x /\ MEM y (l f x)) (\(y,x). s x)
         (\f (y,x). h f x y)
         ==> admissible (<<) p s (\f x. MAP (h f x) (l f x))
Warning: inventing type variables
val ADMISSIBLE_MATCH_SEQPATTERN : thm =
  |- !(<<) p s c1 c2 e.
         admissible (<<) p s (\f x. ?y. c1 f x (e f x) y) /\
         admissible (<<) (\f x. p f x /\ (?y. c1 f x (e f x) y)) s
         (\f x. _MATCH (e f x) (c1 f x)) /\
         admissible (<<) (\f x. p f x /\ ~(?y. c1 f x (e f x) y)) s
         (\f x. _MATCH (e f x) (c2 f x))
         ==> admissible (<<) p s
             (\f x. _MATCH (e f x) (_SEQPATTERN (c1 f x) (c2 f x)))
0..0..1..2..7..19..42..78..137..solved at 187
0..0..2..4..14..35..68..solved at 84
0..0..2..4..14..35..68..solved at 104
val ADMISSIBLE_IMP_SUPERADMISSIBLE : thm =
  |- !(<<) p s t. admissible (<<) p s t ==> superadmissible (<<) p s t
Warning: inventing type variables
val SUPERADMISSIBLE_CONST : thm = |- !p s c. superadmissible (<<) p s (\f. c)
0..0..1..2..solved at 6
0..0..1..2..7..19..42..78..140..solved at 193
0..0..2..4..16..39..78..solved at 101
0..0..2..4..16..39..78..solved at 121
val SUPERADMISSIBLE_TAIL : thm =
  |- !(<<) p s t.
         admissible (<<) p s t /\
         (!f a. p f a ==> (!y. y << t f a ==> y << s a))
         ==> superadmissible (<<) p s (\f x. f (t f x))
0..0..2..4..12..33..80..solved at 109
0..0..1..2..3..7..28..58..93..156..224..320..452..612..798..1098..1416..1822..2337..2900..3583..solved at 4191
0..0..2..4..12..33..80..solved at 89
0..0..1..2..3..7..28..58..93..156..224..320..452..612..798..1098..1416..1822..2337..2900..3583..solved at 4521
0..0..1..2..9..26..54..solved at 83
0..0..1..2..3..7..20..41..67..110..157..227..331..463..620..867..1133..1468..1887..2352..2941..solved at 3821
0..0..1..2..9..26..54..solved at 63
0..0..1..2..3..7..20..41..67..110..157..227..331..463..620..867..1133..1468..1887..2352..2941..solved at 3463
0..0..1..2..solved at 6
0..0..2..4..solved at 9
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 6
0..0..solved at 5
0..0..solved at 2
0..0..solved at 2
val SUPERADMISSIBLE_COND : thm =
  |- !(<<) p P s h k.
         admissible (<<) p s P /\
         superadmissible (<<) (\f x. p f x /\ P f x) s h /\
         superadmissible (<<) (\f x. p f x /\ ~P f x) s k
         ==> superadmissible (<<) p s (\f x. if P f x then h f x else k f x)
Warning: inventing type variables
val SUPERADMISSIBLE_MATCH_SEQPATTERN : thm =
  |- !(<<) p s c1 c2 e.
         admissible (<<) p s (\f x. ?y. c1 f x (e f x) y) /\
         superadmissible (<<) (\f x. p f x /\ (?y. c1 f x (e f x) y)) s
         (\f x. _MATCH (e f x) (c1 f x)) /\
         superadmissible (<<) (\f x. p f x /\ ~(?y. c1 f x (e f x) y)) s
         (\f x. _MATCH (e f x) (c2 f x))
         ==> superadmissible (<<) p s
             (\f x. _MATCH (e f x) (_SEQPATTERN (c1 f x) (c2 f x)))
0..0..solved at 2
0..0..0..solved at 3
0..0..1..2..6..12..25..solved at 45
0..0..1..2..3..10..solved at 17
0..0..1..2..9..26..53..solved at 82
0..0..solved at 2
0..0..1..2..9..26..53..solved at 62
0..0..solved at 2
0..0..1..2..5..9..15..22..29..36..67..104..175..273..solved at 350
val SUPERADMISSIBLE_MATCH_UNGUARDED_PATTERN : thm =
  |- !(<<) p s e pat arg.
         (!f a t u.
              p f a /\ pat t = e a /\ pat u = e a ==> arg a t = arg a u) /\
         (!f a t. p f a /\ pat t = e a ==> (!y. y << arg a t ==> y << s a))
         ==> superadmissible (<<) p s
             (\f x. match e x with pat t -> f (arg x t))
0..0..0..solved at 3
0..0..0..0..solved at 4
0..0..1..2..6..12..25..41..67..solved at 102
0..0..1..2..3..7..17..30..46..70..97..140..solved at 190
0..0..1..2..9..26..53..solved at 82
0..0..0..solved at 3
0..0..1..2..9..26..53..solved at 62
0..0..0..solved at 3
0..0..1..2..5..9..15..22..29..36..53..70..97..161..232..370..554..815..1134..1579..2071..2741..3531..4571..5783..7374..solved at 8357
val SUPERADMISSIBLE_MATCH_GUARDED_PATTERN : thm =
  |- !(<<) p s e pat q arg.
         (!f a t u.
              p f a /\ pat t = e a /\ q a t /\ pat u = e a /\ q a u
              ==> arg a t = arg a u) /\
         (!f a t.
              p f a /\ q a t /\ pat t = e a
              ==> (!y. y << arg a t ==> y << s a))
         ==> superadmissible (<<) p s
             (\f x. match e x with pat t when q x t -> f (arg x t))
Warning: inventing type variables
0..0..solved at 2
0..0..1..3..11..33..69..solved at 111
0..0..1..3..11..33..69..solved at 89
0..0..1..4..13..solved at 18
0..0..1..4..13..solved at 19
0..0..1..4..13..solved at 19
0..0..1..2..solved at 6
val WF_REC_TAIL_GENERAL' : thm =
  |- !P G H H'.
         WF (<<) /\
         (!f g x.
              (!z. z << x ==> f z = g z)
              ==> (P f x <=> P g x) /\ G f x = G g x /\ H' f x = H' g x) /\
         (!f x y. P f x /\ y << G f x ==> y << x) /\
         (!f x. H f x = (if P f x then f (G f x) else H' f x))
         ==> (?f. !x. f x = H f x)
0..0..1..3..11..31..61..114..201..302..473..solved at 633
0..0..1..3..11..31..61..114..201..302..473..solved at 562
0..0..1..4..12..27..55..116..196..solved at 236
0..0..1..4..12..27..55..108..178..solved at 219
0..0..2..6..19..50..101..solved at 143
0..0..2..6..19..50..101..solved at 121
0..0..2..7..21..solved at 26
0..0..2..7..21..solved at 27
0..0..1..2..5..11..19..32..solved at 51
0..0..2..5..solved at 9
val WF_REC_CASES : thm =
  |- !(<<) clauses.
         WF (<<) /\
         ALL
         (\(s,t). ?P G H.
                      (!f a y. P f a /\ y << G f a ==> y << s a) /\
                      (!f g a.
                           (!z. z << s a ==> f z = g z)
                           ==> (P f a <=> P g a) /\
                               G f a = G g a /\
                               H f a = H g a) /\
                      (!f a. t f a = (if P f a then f (G f a) else H f a)))
         clauses
         ==> (?f. !x. f x = CASEWISE clauses f x)
Warning: inventing type variables
val WF_REC_CASES' : thm =
  |- !(<<) clauses.
         WF (<<) /\ ALL (\(s,t). tailadmissible (<<) (\f a. T) s t) clauses
         ==> (?f. !x. f x = CASEWISE clauses f x)
0..0..1..6..11..28..59..115..212..391..solved at 471
val RECURSION_CASEWISE : thm =
  |- !clauses. (?(<<). WF (<<) /\
                       ALL (\(s,t). tailadmissible (<<) (\f a. T) s t)
                       clauses) /\
               (!s t s' t' f x y.
                    MEM (s,t) clauses /\ MEM (s',t') clauses
                    ==> s x = s' y
                    ==> t f x = t' f y)
               ==> (?f. ALL (\(s,t). !x. f (s x) = t f x) clauses)
Warning: inventing type variables
0..0..1..3..solved at 9
0..0..1..solved at 4
0..0..1..3..solved at 12
0..0..solved at 2
0..0..1..solved at 5
0..0..1..3..solved at 7
0..0..1..solved at 4
0..0..1..3..solved at 8
0..0..3..7..solved at 12
0..0..3..7..solved at 14
0..0..3..8..solved at 17
0..0..3..7..solved at 15
0..0..3..solved at 7
0..0..3..solved at 8
0..0..3..solved at 6
0..0..3..solved at 8
0..0..3..7..solved at 12
0..0..3..7..solved at 14
0..0..3..8..solved at 17
0..0..2..5..solved at 14
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
Warning: inventing type variables
Warning: inventing type variables
0..0..1..2..5..10..17..solved at 26
Warning: inventing type variables
val RECURSION_CASEWISE_PAIRWISE : thm =
  |- !clauses. (?(<<). WF (<<) /\
                       ALL (\(s,t). tailadmissible (<<) (\f a. T) s t)
                       clauses) /\
               ALL (\(s,t). !f x y. s x = s y ==> t f x = t f y) clauses /\
               PAIRWISE
               (\(s,t) (s',t'). !f x y. s x = s' y ==> t f x = t' f y)
               clauses
               ==> (?f. ALL (\(s,t). !x. f (s x) = t f x) clauses)
Warning: inventing type variables
val SUPERADMISSIBLE_T : thm =
  |- superadmissible (<<) (\f x. T) s t <=> tailadmissible (<<) (\f x. T) s t
val RECURSION_SUPERADMISSIBLE : thm =
  |- !clauses. (?(<<). WF (<<) /\
                       ALL (\(s,t). superadmissible (<<) (\f a. T) s t)
                       clauses) /\
               ALL (\(s,t). !f x y. s x = s y ==> t f x = t f y) clauses /\
               PAIRWISE
               (\(s,t) (s',t'). !f x y. s x = s' y ==> t f x = t' f y)
               clauses
               ==> (?f. ALL (\(s,t). !x. f (s x) = t f x) clauses)
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
Warning: inventing type variables
0..0..0..solved at 3
val instantiate_casewise_recursion : term -> thm = <fun>
val pure_prove_recursive_function_exists : term -> thm = <fun>
val prove_general_recursive_function_exists : term -> thm = <fun>
val define : term -> thm = <fun>
- : unit = ()
File "define.ml" already loaded
- : unit = ()
val help_path : string list ref = {contents = ["$/Help"]}
val help : string -> unit = <fun>
val theorems : (string * thm) list ref = {contents = []}
val omit : term -> term = <fun>
val exactly : term -> term = <fun>
val name : string -> term = <fun>
val search : term list -> (string * thm) list = <fun>
- : unit = ()
File "help.ml" already loaded
- : unit = ()
- : unit = ()
- : unit = ()
# val PARI : thm = |- !n. PARI n <=> (?m. n = 2 * m)
# val DISPARI : thm = |- !n. DISPARI n <=> (?m. n = SUC (2 * m))
#   val PARI_CONV : term -> thm = <fun>
# val DISPARI_CONV : term -> thm = <fun>
#         val PARI_EVEN_LINK : thm = |- PARI n <=> EVEN n
#       val DISPARI_ODD_LINK : thm = |- DISPARI n <=> ODD n
#           val ZERO_IS_PARI : thm = |- PARI 0
#             val ZERO_IS_NOT_DISPARI : thm = |- ~DISPARI 0
#               val N_PARI_IMP_SUC_N_DISPARI : thm = |- !n. PARI n ==> DISPARI (SUC n)
#                         val PARI_DIV_BY_2_CANCEL : thm = |- !n. (?q. n = 2 * q) ==> n = 2 * n DIV 2
#                                               val N_DISPARI_IMP_SUC_N_PARI : thm = |- !n. DISPARI n ==> PARI (SUC n)
#               val EVEN_MOD : thm = |- !n. EVEN n <=> n MOD 2 = 0
#                                                                     val NOT_DISPARI_THEN_PARI : thm = |- !n. ~DISPARI n ==> PARI n
#                 0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..1..2..solved at 6
val ODD_MOD : thm = |- !n. ODD n <=> n MOD 2 = 1
#             val NOT_PARI_THEN_DISPARI : thm = |- !n. ~PARI n ==> DISPARI n
#                                     val PARI_OR_DISPARI : thm = |- !n. PARI n \/ DISPARI n
# val it : goalstack = 1 subgoal (1 total)

`!n. PARI (n + 2) <=> PARI n`

# val it : goalstack = 1 subgoal (1 total)

`PARI (n + 2) <=> PARI n`

# val it : goalstack = 1 subgoal (1 total)

`PARI (SUC (SUC n)) <=> PARI n`

# val it : goalstack = 2 subgoals (2 total)

`PARI n ==> PARI (SUC (SUC n))`

`PARI (SUC (SUC n)) ==> PARI n`

# -------------------------------------------------------------------

EQ_TAC : tactic

SYNOPSIS

Reduces goal of equality of boolean terms to forward and backward implication.

DESCRIPTION

When applied to a goal A ?- t1 <=> t2, where t1 and t2 have type bool,
the tactic EQ_TAC returns the subgoals A ?- t1 ==> t2 and
A ?- t2 ==> t1.

             A ?- t1 <=> t2
   =================================  EQ_TAC
    A ?- t1 ==> t2   A ?- t2 ==> t1


FAILURE CONDITIONS

Fails unless the conclusion of the goal is an equation between boolean terms.

SEE ALSO
EQ_IMP_RULE, IMP_ANTISYM_RULE.

--------------------------------------------------------------------
val it : unit = ()
# val val_goalstack_ : goalstack = 2 subgoals (2 total)

`PARI n ==> PARI (SUC (SUC n))`

`PARI (SUC (SUC n)) ==> PARI n`

# val it : goalstack = 1 subgoal (2 total)

`!m. PARI m ==> PARI n`

# val it : goalstack = 2 subgoals (2 total)

`PARI n ==> PARI (SUC (SUC n))`

`PARI (SUC (SUC n)) ==> PARI n`

#     val it : goalstack = 1 subgoal (2 total)

`~PARI n ==> ~PARI (SUC (SUC n))`

# -------------------------------------------------------------------

IMP_ANTISYM_RULE : thm -> thm -> thm

SYNOPSIS

Deduces equality of boolean terms from forward and backward implications.

DESCRIPTION

When applied to the theorems A1 |- t1 ==> t2 and A2 |- t2 ==> t1, the
inference rule IMP_ANTISYM_RULE returns the theorem A1 u A2 |- t1 <=> t2.

   A1 |- t1 ==> t2     A2 |- t2 ==> t1
  -------------------------------------  IMP_ANTISYM_RULE
           A1 u A2 |- t1 <=> t2


FAILURE CONDITIONS

Fails unless the theorems supplied are a complementary implicative
pair as indicated above.

EXAMPLES


  # let th1 = TAUT `p /\ q ==> q /\ p`
    and th2 = TAUT `q /\ p ==> p /\ q`;;
  val th1 : thm = |- p /\ q ==> q /\ p
  val th2 : thm = |- q /\ p ==> p /\ q

  # IMP_ANTISYM_RULE th1 th2;;
  val it : thm = |- p /\ q <=> q /\ p


SEE ALSO
EQ_IMP_RULE, EQ_MP, EQ_TAC.

--------------------------------------------------------------------
val it : unit = ()
# -------------------------------------------------------------------

EQ_IMP_RULE : thm -> thm * thm

SYNOPSIS

Derives forward and backward implication from equality of boolean terms.

DESCRIPTION

When applied to a theorem A |- t1 <=> t2, where t1 and t2 both have
type bool, the inference rule EQ_IMP_RULE returns the
theorems A |- t1 ==> t2 and A |- t2 ==> t1.

              A |- t1 <=> t2
   -----------------------------------  EQ_IMP_RULE
    A |- t1 ==> t2     A |- t2 ==> t1


FAILURE CONDITIONS

Fails unless the conclusion of the given theorem is an equation between
boolean terms.

EXAMPLES


  # SPEC_ALL CONJ_SYM;;
  val it : thm = |- t1 /\ t2 <=> t2 /\ t1

  # EQ_IMP_RULE it;;
  val it : thm * thm = (|- t1 /\ t2 ==> t2 /\ t1, |- t2 /\ t1 ==> t1 /\ t2)


SEE ALSO
EQ_MP, EQ_TAC, IMP_ANTISYM_RULE.

--------------------------------------------------------------------
val it : unit = ()
# -------------------------------------------------------------------

IMP_TRANS : thm -> thm -> thm

SYNOPSIS

Implements the transitivity of implication.

DESCRIPTION

When applied to theorems A1 |- t1 ==> t2 and A2 |- t2 ==> t3,
the inference rule IMP_TRANS returns the theorem A1 u A2 |- t1 ==> t3.

    A1 |- t1 ==> t2   A2 |- t2 ==> t3
   -----------------------------------  IMP_TRANS
         A1 u A2 |- t1 ==> t3


FAILURE CONDITIONS

Fails unless the theorems are both implicative, with the consequent of the
first being the same as the antecedent of the  second (up to alpha-conversion).

EXAMPLES


  # let th1 = TAUT `p /\ q /\ r ==> p /\ q`
    and th2 = TAUT `p /\ q ==> p`;;
  val th1 : thm = |- p /\ q /\ r ==> p /\ q
  val th2 : thm = |- p /\ q ==> p

  # IMP_TRANS th1 th2;;
  val it : thm = |- p /\ q /\ r ==> p


SEE ALSO
IMP_ANTISYM_RULE, SYM, TRANS.

--------------------------------------------------------------------
val it : unit = ()
#   Exception: Failure "dest_binary".
# val val_N_PARI_IMP_SUC_N_DISPARI : thm = |- !n. PARI n ==> DISPARI (SUC n)
#   Exception: Failure "IMP_TRANS".
# val val_SPEC : term -> thm -> thm = <fun>
#   val PARI_N_IMP_PARI_SUC_SUC_N : thm = |- PARI n ==> PARI (SUC (SUC n))
# val val_goalstack_ : goalstack = 1 subgoal (2 total)

`~PARI n ==> ~PARI (SUC (SUC n))`

# val val_goalstack_ : goalstack = 1 subgoal (2 total)

`~PARI n ==> ~PARI (SUC (SUC n))`

# val it : goalstack = 2 subgoals (2 total)

`PARI n ==> PARI (SUC (SUC n))`

`PARI (SUC (SUC n)) ==> PARI n`

#     val it : goalstack = 1 subgoal (2 total)

`~PARI n ==> ~PARI (SUC (SUC n))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`DISPARI n`]

`~PARI (SUC (SUC n))`

# val it : goalstack = 1 subgoal (2 total)

`~PARI n ==> ~PARI (SUC (SUC n))`

# val it : goalstack = 2 subgoals (2 total)

`PARI n ==> PARI (SUC (SUC n))`

`PARI (SUC (SUC n)) ==> PARI n`

# val val_CONTRAPOS_THM : thm = |- !t1 t2. ~t1 ==> ~t2 <=> t2 ==> t1
# val it : goalstack = 1 subgoal (2 total)

  0 [`PARI (SUC (SUC n))`]

`PARI n`

# val val_MATCH_MP_TAC : thm_tactic = <fun>
# val it : goalstack = 1 subgoal (2 total)

  0 [`PARI (SUC (SUC n))`]

`~DISPARI n`

# val it : goalstack = 1 subgoal (2 total)

  0 [`PARI (SUC (SUC n))`]

`PARI n`

# val it : goalstack = 2 subgoals (2 total)

`PARI n ==> PARI (SUC (SUC n))`

`PARI (SUC (SUC n)) ==> PARI n`

#     val it : goalstack = 1 subgoal (2 total)

`~PARI n ==> ~PARI (SUC (SUC n))`

# val val_GSYM : thm -> thm = <fun>
# val val_CONTRAPOS_THM : thm = |- !t1 t2. ~t1 ==> ~t2 <=> t2 ==> t1
# val it : goalstack = 2 subgoals (2 total)

`PARI n ==> PARI (SUC (SUC n))`

`PARI (SUC (SUC n)) ==> PARI n`

#     val it : goalstack = 1 subgoal (2 total)

`~PARI n ==> ~PARI (SUC (SUC n))`

#   val DISPARI_N_IMP_DISPARI_SUC_SUC_N : thm =
  |- DISPARI n ==> DISPARI (SUC (SUC n))
# val val_goalstack_ : goalstack = 1 subgoal (2 total)

`~PARI n ==> ~PARI (SUC (SUC n))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`DISPARI n`]

`~PARI (SUC (SUC n))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`DISPARI (SUC (SUC n))`]

`~PARI (SUC (SUC n))`

# val val_NOT_PARI_THEN_DISPARI : thm = |- !n. ~PARI n ==> DISPARI n
# val val_CONTR : term -> thm -> thm = <fun>
# val val_EQF_INTRO : thm -> thm = <fun>
# -------------------------------------------------------------------

EQF_INTRO : thm -> thm

SYNOPSIS

Converts negation to equality with F.

DESCRIPTION


     A |- ~tm
   ---------------  EQF_INTRO
    A |- tm <=> F


FAILURE CONDITIONS

Fails if the argument theorem is not a negation.

EXAMPLES


  # let th = ASSUME `~p`;;
  val th : thm = ~p |- ~p

  # EQF_INTRO th;;
  val it : thm = ~p |- p <=> F


SEE ALSO
EQF_ELIM, EQT_ELIM, EQT_INTRO, NOT_ELIM, NOT_INTRO.

--------------------------------------------------------------------
val it : unit = ()
# val val_EQF_ELIM : thm -> thm = <fun>
# -------------------------------------------------------------------

EQF_ELIM : thm -> thm

SYNOPSIS

Replaces equality with F by negation.

DESCRIPTION


    A |- tm <=> F
   ---------------  EQF_ELIM
     A |- ~tm


FAILURE CONDITIONS

Fails if the argument theorem is not of the form A |- tm <=> F.

EXAMPLES


  # EQF_ELIM(REFL `F`);;
  val it : thm = |- ~F


SEE ALSO
EQF_INTRO, EQT_ELIM, EQT_INTRO, NOT_ELIM, NOT_INTRO.

--------------------------------------------------------------------
val it : unit = ()
# -------------------------------------------------------------------

NOT_ELIM : thm -> thm

SYNOPSIS

Transforms |- ~t into |- t ==> F.

DESCRIPTION

When applied to a theorem A |- ~t, the inference rule NOT_ELIM returns the
theorem A |- t ==> F.

      A |- ~t
   --------------  NOT_ELIM
    A |- t ==> F


FAILURE CONDITIONS

Fails unless the theorem has a negated conclusion.

EXAMPLES


  # let th = UNDISCH(TAUT `p ==> ~ ~p`);;
  val th : thm = p |- ~ ~p

  # NOT_ELIM th;;
  val it : thm = p |- ~p ==> F


SEE ALSO
EQF_ELIM, EQF_INTRO, NOT_INTRO.

--------------------------------------------------------------------
val it : unit = ()
# val val_goalstack_ : goalstack = 1 subgoal (2 total)

  0 [`DISPARI (SUC (SUC n))`]

`~PARI (SUC (SUC n))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`DISPARI (SUC (SUC n))`]
  1 [`PARI (SUC (SUC n))`]

`F`

# val it : goalstack = 1 subgoal (1 total)

`!n. PARI n <=> ~DISPARI n`

#   val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

# val it : goalstack = 1 subgoal (1 total)

`!n. PARI (n + 2) <=> PARI n`

# val it : goalstack = 1 subgoal (1 total)

`PARI (n + 2) <=> PARI n`

# val it : goalstack = 1 subgoal (1 total)

`PARI (SUC (SUC n)) <=> PARI n`

# val it : goalstack = 2 subgoals (2 total)

`PARI n ==> PARI (SUC (SUC n))`

`PARI (SUC (SUC n)) ==> PARI n`

#     val it : goalstack = 1 subgoal (2 total)

`~PARI n ==> ~PARI (SUC (SUC n))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`DISPARI n`]

`~PARI (SUC (SUC n))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`DISPARI (SUC (SUC n))`]

`~PARI (SUC (SUC n))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`DISPARI (SUC (SUC n))`]
  1 [`PARI (SUC (SUC n))`]

`F`

# val it : goalstack = 1 subgoal (2 total)

  0 [`DISPARI (SUC (SUC n))`]

`~PARI (SUC (SUC n))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`DISPARI (SUC (SUC n))`]
  1 [`PARI (SUC (SUC n))`]

`F`

# val it : goalstack = 1 subgoal (1 total)

`!n. PARI n <=> ~DISPARI n`

# val it : goalstack = 1 subgoal (1 total)

`PARI n <=> ~DISPARI n`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

# M# e ( REWRITE_TAC [[4mPARI, DISPARI[24m]);;
[24mError: This expression has type 'a * 'b
       but an expression was expected of type thm = Hol.thm
# val it : goalstack = 1 subgoal (2 total)

`(?m. n = 2 * m) ==> ~(?m. n = SUC (2 * m))`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

# val it : goalstack = 1 subgoal (2 total)

  0 [`PARI n`]

`~DISPARI n`

# val it : goalstack = 1 subgoal (2 total)

  0 [`PARI n`]
  1 [`DISPARI n`]

`F`

# val it : goalstack = 1 subgoal (2 total)

  0 [`PARI n`]

`~DISPARI n`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

# val it : goalstack = 1 subgoal (2 total)

  0 [`PARI n`]
  1 [`DISPARI n`]

`F`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

# Warning: Benign redefinition
val PARI : thm = |- !n. PARI n <=> (?m. n = 2 * m)
# Warning: Benign redefinition
val DISPARI : thm = |- !n. DISPARI n <=> (?m. n = SUC (2 * m))
# val PARI_CONV : term -> thm = <fun>
# val DISPARI_CONV : term -> thm = <fun>
#         val PARI_EVEN_LINK : thm = |- PARI n <=> EVEN n
#       val DISPARI_ODD_LINK : thm = |- DISPARI n <=> ODD n
#           val ZERO_IS_PARI : thm = |- PARI 0
#           val ZERO_IS_NOT_DISPARI : thm = |- ~DISPARI 0
# val it : goalstack = 1 subgoal (1 total)

`~DISPARI 0`

# val it : goalstack = 1 subgoal (1 total)

`~(?m. 0 = SUC (2 * m))`

# val it : goalstack = No subgoals

#             val N_PARI_IMP_SUC_N_DISPARI : thm = |- !n. PARI n ==> DISPARI (SUC n)
# Warning: Free variables in goal: a, b, c
val it : goalstack = 1 subgoal (1 total)

`~(c = 0) ==> (a * b) DIV c = a * b DIV c`

# val it : goalstack = 1 subgoal (1 total)

  0 [`~(c = 0)`]

`(a * b) DIV c = a * b DIV c`

# val it : goalstack = 1 subgoal (1 total)

  0 [`~(c = 0)`]

`?r. a * b = (a * b DIV c) * c + r /\ r < c`

# val it : goalstack = 1 subgoal (1 total)

  0 [`~(c = 0)`]

`a * b = (a * b DIV c) * c + 0 /\ 0 < c`

# val it : goalstack = 2 subgoals (2 total)

  0 [`~(c = 0)`]

`0 < c`

  0 [`~(c = 0)`]

`a * b = (a * b DIV c) * c + 0`

# val it : goalstack = 1 subgoal (2 total)

  0 [`~(c = 0)`]

`a * b = (a * b DIV c) * c`

# val it : goalstack = 1 subgoal (1 total)

`!n. (?q. n = 2 * q) ==> n = 2 * n DIV 2`

# val it : goalstack = 1 subgoal (1 total)

`(?q. n = 2 * q) ==> n = 2 * n DIV 2`

# val it : goalstack = 1 subgoal (1 total)

  0 [`?q. n = 2 * q`]

`n = 2 * n DIV 2`

# val it : goalstack = 1 subgoal (1 total)

  0 [`?q. n = 2 * q`]
  1 [`~(2 = 0)`]

`n = 2 * n DIV 2`

# val it : goalstack = 1 subgoal (1 total)

  0 [`?q. n = 2 * q`]
  1 [`~(2 = 0)`]
  2 [`(?q. n = q * 2) <=> n MOD 2 = 0`]

`n = 2 * n DIV 2`

# val it : goalstack = 1 subgoal (1 total)

  0 [`?q. n = 2 * q`]
  1 [`~(2 = 0)`]

`n = 2 * n DIV 2`

# val it : goalstack = 1 subgoal (1 total)

  0 [`?q. n = 2 * q`]

`n = 2 * n DIV 2`

# val it : goalstack = 1 subgoal (1 total)

  0 [`?q. n = 2 * q`]
  1 [`(?q. n = q * 2) <=> n MOD 2 = 0`]

`n = 2 * n DIV 2`

#                       val PARI_DIV_BY_2_CANCEL : thm = |- !n. (?q. n = 2 * q) ==> n = 2 * n DIV 2
#                                             val it : thm = |- !n. DISPARI n ==> PARI (SUC n)
#       val it : term * tactic = (`!n. EVEN n <=> n MOD 2 = 0`, <fun>)
#                                                                   val it : thm = |- !n. ~DISPARI n ==> PARI n
#           val it : thm = |- !n. ~PARI n ==> DISPARI n
#   val val_EVEN_EXISTS_LEMMA : thm =
  |- !n. (EVEN n ==> (?m. n = 2 * m)) /\ (~EVEN n ==> (?m. n = SUC (2 * m)))
#                                   val it : thm = |- !n. PARI n \/ DISPARI n
#   val it : thm = |- PARI n ==> PARI (SUC (SUC n))
#     val DISPARI_N_IMP_DISPARI_SUC_SUC_N : thm =
  |- DISPARI n ==> DISPARI (SUC (SUC n))
#   val it : goalstack = 1 subgoal (1 total)

`!n. PARI n <=> ~DISPARI n`

# val it : goalstack = 1 subgoal (1 total)

`PARI n <=> ~DISPARI n`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

# val it : goalstack = 1 subgoal (2 total)

`(?m. n = 2 * m) ==> ~(?m. n = SUC (2 * m))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`n = 2 * m`]
  1 [`n = SUC (2 * m')`]

`F`

# M# let val_POP_ASSUME = [4m(POP_ASSUME)[24m;;
[24mError: Unbound value POP_ASSUME
# M# let val_POPASSUME = [4m(POPASSUME)[24m;;
[24mError: Unbound value POPASSUME
# val val_POP_ASSUM : thm_tactic -> tactic = <fun>
# val val_SUBST_VAR_TAC : thm -> tactic = <fun>
# val it : goalstack = 1 subgoal (2 total)

  0 [`SUC (2 * m') = 2 * m`]

`F`

# val it : goalstack = 1 subgoal (2 total)

  0 [`SUC (2 * m') = 2 * m`]

`F`

# Toplevel input:
#     );;
      ^
Parse error: illegal begin of top_phrase
# Toplevel input:
#     );;
      ^
Parse error: illegal begin of top_phrase
# val val_search : term list -> (string * thm) list = <fun>
# val it : (string * thm) list = []
# val val_goalstack_ : goalstack = 1 subgoal (2 total)

  0 [`SUC (2 * m') = 2 * m`]

`F`

# val it : goalstack = 1 subgoal (2 total)

  0 [`SUC (2 * m') = 2 * m`]

`F`

# val it : goalstack = 1 subgoal (2 total)

  0 [`n = 2 * m`]
  1 [`n = SUC (2 * m')`]

`F`

# val it : goalstack = 1 subgoal (2 total)

`(?m. n = 2 * m) ==> ~(?m. n = SUC (2 * m))`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

# Exception: Failure "POP_ASSUM: No assumption to pop".
# val it : goalstack = 1 subgoal (2 total)

  0 [`PARI n`]
  1 [`DISPARI n`]

`F`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

# val it : goalstack = 1 subgoal (1 total)

`PARI n <=> ~DISPARI n`

# val it : goalstack = 1 subgoal (1 total)

`!n. PARI n <=> ~DISPARI n`

# Exception: Failure "Can't back up any more".
# val it : goalstack = 1 subgoal (1 total)

`PARI n <=> ~DISPARI n`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

# val it : goalstack = 1 subgoal (2 total)

`(?m. n = 2 * m) ==> ~(?m. n = SUC (2 * m))`

# Exception: Failure "linear_ineqs: no contradiction".
# 0..0..1..2..6..11..20..32..48..68..120..180..291..474..741..1184..2572..4303..7635..19492..36732..65760..Interrupted.
# Interrupted.
# 0..0..1..2..solved at 6
val it : goalstack = 1 subgoal (2 total)

`!m m'. ~(2 * m = SUC (2 * m'))`

# val it : goalstack = 2 subgoals (3 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`!m'. ~(2 * SUC m = SUC (2 * m'))`

`!m'. ~(2 * 0 = SUC (2 * m'))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`!m'. ~(2 * SUC m = SUC (2 * m'))`

# val it : goalstack = 2 subgoals (3 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]
  1 [`~(2 * SUC m = SUC (2 * m'))`]

`~(2 * SUC m = SUC (2 * SUC m'))`

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`~(2 * SUC m = SUC (2 * 0))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]
  1 [`~(2 * SUC m = SUC (2 * m'))`]

`~(2 * SUC m = SUC (2 * SUC m'))`

# val it : thm = |- 2 * SUC m = SUC (SUC (2 * m))
# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]
  1 [`~(2 * SUC m = SUC (2 * m'))`]

`~(SUC (SUC (2 * m)) = SUC (SUC (SUC (2 * m'))))`

# val val_STRUCT_CASES_TAC : thm_tactic = <fun>
# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]
  1 [`~(2 * SUC m = SUC (2 * m'))`]

`~(2 * m = SUC (2 * m'))`

# val it : goalstack = 1 subgoal (1 total)

`~DISPARI n ==> PARI n`

# Exception: Failure "ACCEPT_TAC".
# val it : goalstack = No subgoals

# val it : (string * thm) list = []
# val it : (string * thm) list = []
# val it : (string * thm) list = []
#                                                 MMMMMMMMMMMMMMMMMMMMMMMMM# let _ = prove (`!n. PARI n <=> ~DISPARI n`,
              GEN_TAC
          THEN EQ_TAC
          THENL [
              [4mREWRITE_TAC[24m [PARI; DISPARI]
              SUBGOAL_THEN `!m m'. ~(2*m = SUC (2*m'))` (fun th -> MESON_TAC [th])
              INDUCT_TAC
              THENL [
                  ARITH_TAC;
                  INDUCT_TAC
                  THENL [
                      ARITH_TAC;
                      REWRITE_TAC [ARITH_RULE `2 * SUC m = SUC (SUC (2 * m))`]
                      REWRITE_TAC [SUC_INJ]
                      ASM_REWRITE_TAC[]
                  ];
              MATCH_ACCEPT_TAC NOT_DISPARI_THEN_PARI
  
              ]
  
  
              REPEAT STRIP_TAC
              POP_ASSUM SUBST_VAR_TAC 
          ]
      );;
[24mError: This function is applied to too many arguments;
maybe you forgot a `;'
#                                                 MMMMMMMMMMMMMMMMMMMMMMMMM# let _ = prove (`!n. PARI n <=> ~DISPARI n`,
              GEN_TAC
          THEN EQ_TAC
          THENL [
              [4mREWRITE_TAC[24m [PARI; DISPARI]
              SUBGOAL_THEN `!m m'. ~(2*m = SUC (2*m'))` (fun th -> MESON_TAC [th])
              INDUCT_TAC
              THENL [
                  ARITH_TAC;
                  INDUCT_TAC
                  THENL [
                      ARITH_TAC;
                      REWRITE_TAC [ARITH_RULE `2 * SUC m = SUC (SUC (2 * m))`]
                      REWRITE_TAC [SUC_INJ]
                      ASM_REWRITE_TAC[]
                  ];
              MATCH_ACCEPT_TAC NOT_DISPARI_THEN_PARI
  
              ]
  
  
              REPEAT STRIP_TAC
              POP_ASSUM SUBST_VAR_TAC 
          ]
      );;
[24mError: This function is applied to too many arguments;
maybe you forgot a `;'
#                                             MMMMMMMMMMMMMMMMMMMMMMM# let _ = prove (`!n. PARI n <=> ~DISPARI n`,
              GEN_TAC
          THEN EQ_TAC
          THENL [
              [4mREWRITE_TAC[24m [PARI; DISPARI]
              SUBGOAL_THEN `!m m'. ~(2*m = SUC (2*m'))` (fun th -> MESON_TAC [th])
              INDUCT_TAC
              THENL [
                  ARITH_TAC;
                  INDUCT_TAC
                  THENL [
                      ARITH_TAC;
                      REWRITE_TAC [ARITH_RULE `2 * SUC m = SUC (SUC (2 * m))`]
                      REWRITE_TAC [SUC_INJ]
                      ASM_REWRITE_TAC[]
                  ];
              MATCH_ACCEPT_TAC NOT_DISPARI_THEN_PARI
  
              ]
  
  
          ]
      );;
[24mError: This function is applied to too many arguments;
maybe you forgot a `;'
# val it : goalstack = 1 subgoal (1 total)

`!n. PARI n <=> ~DISPARI n`

# val it : goalstack = 1 subgoal (1 total)

`PARI n <=> ~DISPARI n`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

# val it : goalstack = 1 subgoal (2 total)

`(?m. n = 2 * m) ==> ~(?m. n = SUC (2 * m))`

# 0..0..1..2..solved at 6
val it : goalstack = 1 subgoal (2 total)

`!m m'. ~(2 * m = SUC (2 * m'))`

# val it : goalstack = 2 subgoals (3 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`!m'. ~(2 * SUC m = SUC (2 * m'))`

`!m'. ~(2 * 0 = SUC (2 * m'))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`!m'. ~(2 * SUC m = SUC (2 * m'))`

# val it : goalstack = 2 subgoals (3 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]
  1 [`~(2 * SUC m = SUC (2 * m'))`]

`~(2 * SUC m = SUC (2 * SUC m'))`

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`~(2 * SUC m = SUC (2 * 0))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]
  1 [`~(2 * SUC m = SUC (2 * m'))`]

`~(2 * SUC m = SUC (2 * SUC m'))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]
  1 [`~(2 * SUC m = SUC (2 * m'))`]

`~(SUC (SUC (2 * m)) = SUC (SUC (SUC (2 * m'))))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]
  1 [`~(2 * SUC m = SUC (2 * m'))`]

`~(2 * m = SUC (2 * m'))`

# val it : goalstack = 1 subgoal (1 total)

`~DISPARI n ==> PARI n`

# val it : goalstack = No subgoals

#                                           MMMMMMMMMMMMMMMMMMMMMM# let _ = prove (`!n. PARI n <=> ~DISPARI n`,
              GEN_TAC
          THEN EQ_TAC
          THENL [
              [4mREWRITE_TAC[24m [PARI; DISPARI]
              SUBGOAL_THEN `!m m'. ~(2*m = SUC (2*m'))` (fun th -> MESON_TAC [th])
              INDUCT_TAC
              THENL [
                  ARITH_TAC;
                  INDUCT_TAC
                  THENL [
                      ARITH_TAC;
                      REWRITE_TAC [ARITH_RULE `2 * SUC m = SUC (SUC (2 * m))`]
                      REWRITE_TAC [SUC_INJ]
                      ASM_REWRITE_TAC[]
                  ];
              (MATCH_ACCEPT_TAC NOT_DISPARI_THEN_PARI)
  
              ]
  
          ]
      );;
[24mError: This function is applied to too many arguments;
maybe you forgot a `;'
#                 Toplevel input:
# let _ = prove (`!n. PARI n <=> ~DISPARI n`,
              GEN_TAC
          THEN EQ_TAC
          THENL [
              REWRITE_TAC [PARI; DISPARI]
              THEN SUBGOAL_THEN `!m m'. ~(2*m = SUC (2*m'))` (fun th -> MESON_TAC [th])
              THEN INDUCT_TAC
              THENL [
                  THEN ARITH_TAC;
                  ^^^^
Parse error: ']' or [expr1_semi_list] expected after '[' (in [expr])
# Toplevel input:
#                 THEN INDUCT_TAC
                  ^^^^
Parse error: illegal begin of top_phrase
# Toplevel input:
#                 THENL [
                  ^^^^^
Parse error: illegal begin of top_phrase
#         Toplevel input:
#                     ARITH_TAC;
                      THEN REWRITE_TAC [ARITH_RULE `2 * SUC m = SUC (SUC (2 * m))`]
                      THEN REWRITE_TAC [SUC_INJ]
                      THEN ASM_REWRITE_TAC[]
                  ];
                  ^
Parse error: ';;' expected after [str_item] (in [top_phrase])
#     Toplevel input:
#             (MATCH_ACCEPT_TAC NOT_DISPARI_THEN_PARI)
  
              ]
              ^
Parse error: ';;' expected after [str_item] (in [top_phrase])
#   Toplevel input:
# 
          ]
          ^
Parse error: illegal begin of top_phrase
# Toplevel input:
#     );;
      ^
Parse error: illegal begin of top_phrase
#                   Toplevel input:
# let _ = prove (`!n. PARI n <=> ~DISPARI n`,
              GEN_TAC
          THEN EQ_TAC
          THENL [
              REWRITE_TAC [PARI; DISPARI]
              THEN SUBGOAL_THEN `!m m'. ~(2*m = SUC (2*m'))` (fun th -> MESON_TAC [th])
              THEN INDUCT_TAC
              THENL [
                  ARITH_TAC;
                  THEN INDUCT_TAC
                  ^^^^
Parse error: ']' expected after [expr1_semi_list] (in [expr])
# Toplevel input:
#                 THENL [
                  ^^^^^
Parse error: illegal begin of top_phrase
#         Toplevel input:
#                     ARITH_TAC;
                      THEN REWRITE_TAC [ARITH_RULE `2 * SUC m = SUC (SUC (2 * m))`]
                      THEN REWRITE_TAC [SUC_INJ]
                      THEN ASM_REWRITE_TAC[]
                  ];
                  ^
Parse error: ';;' expected after [str_item] (in [top_phrase])
#     Toplevel input:
#             (MATCH_ACCEPT_TAC NOT_DISPARI_THEN_PARI)
  
              ]
              ^
Parse error: ';;' expected after [str_item] (in [top_phrase])
#   Toplevel input:
# 
          ]
          ^
Parse error: illegal begin of top_phrase
# Toplevel input:
#     );;
      ^
Parse error: illegal begin of top_phrase
#                   Toplevel input:
# let _ = prove (`!n. PARI n <=> ~DISPARI n`,
              GEN_TAC
          THEN EQ_TAC
          THENL [
              REWRITE_TAC [PARI; DISPARI]
              THEN SUBGOAL_THEN `!m m'. ~(2*m = SUC (2*m'))` (fun th -> MESON_TAC [th])
              THEN INDUCT_TAC
              THENL [
                  ARITH_TAC;
                  THEN INDUCT_TAC
                  ^^^^
Parse error: ']' expected after [expr1_semi_list] (in [expr])
# Toplevel input:
#                 THENL [
                  ^^^^^
Parse error: illegal begin of top_phrase
#         Toplevel input:
#                     ARITH_TAC;
                      REWRITE_TAC [ARITH_RULE `2 * SUC m = SUC (SUC (2 * m))`]
                      THEN REWRITE_TAC [SUC_INJ]
                      THEN ASM_REWRITE_TAC[]
                  ];
                  ^
Parse error: ';;' expected after [str_item] (in [top_phrase])
#     Toplevel input:
#             (MATCH_ACCEPT_TAC NOT_DISPARI_THEN_PARI)
  
              ]
              ^
Parse error: ';;' expected after [str_item] (in [top_phrase])
#   Toplevel input:
# 
          ]
          ^
Parse error: illegal begin of top_phrase
# Toplevel input:
#     );;
      ^
Parse error: illegal begin of top_phrase
#                                           0..0..1..2..solved at 6
Exception: Failure "seqapply: Length mismatch".
#                                               MMMMMMMMMMMMMMMMMMMMMMMM# let SUC_SUC_N_PARI_IFF_N_PARI = 
      prove (`!n. PARI (n+2) <=> PARI n`,
              [4mGEN_TAC[24m
              REWRITE_TAC [TWO; ADD_SUC; (GSYM ADD1)]
  
  (*            CONV_TAC (RAND_CONV o (REWR_CONV N_PARI_IMP_SUC_N_DISPARI)) *)
  
  
      
  
              EQ_TAC
  
  
  
  
              THENL [
                      CONV_TAC (fun pari_suc_suc_n_IMP_pari_n_tm -> 
                          let ant, cons = dest_imp pari_suc_suc_n_IMP_pari_n_tm in
                          SPECL [cons; ant] (GSYM CONTRAPOS_THM))
                  THEN DISCH_THEN (ASSUME_TAC o MATCH_MP NOT_PARI_THEN_DISPARI)
                  THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP DISPARI_N_IMP_DISPARI_SUC_SUC_N)
                  STRIP_TAC
              ]
      );;
[24mError: This function is applied to too many arguments;
maybe you forgot a `;'
#                                           0..0..1..2..solved at 6
Exception: Failure "seqapply: Length mismatch".
# val it : goalstack = 1 subgoal (1 total)

`!n. PARI n <=> ~DISPARI n`

# val it : goalstack = 1 subgoal (1 total)

`PARI n <=> ~DISPARI n`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

# val it : goalstack = 1 subgoal (2 total)

`(?m. n = 2 * m) ==> ~(?m. n = SUC (2 * m))`

# 0..0..1..2..solved at 6
val it : goalstack = 1 subgoal (2 total)

`!m m'. ~(2 * m = SUC (2 * m'))`

# val it : goalstack = 2 subgoals (3 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`!m'. ~(2 * SUC m = SUC (2 * m'))`

`!m'. ~(2 * 0 = SUC (2 * m'))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`!m'. ~(2 * SUC m = SUC (2 * m'))`

# val it : goalstack = 2 subgoals (3 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]
  1 [`~(2 * SUC m = SUC (2 * m'))`]

`~(2 * SUC m = SUC (2 * SUC m'))`

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`~(2 * SUC m = SUC (2 * 0))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`!m'. ~(2 * SUC m = SUC (2 * m'))`

# val it : goalstack = 2 subgoals (3 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`!m'. ~(2 * SUC m = SUC (2 * m'))`

`!m'. ~(2 * 0 = SUC (2 * m'))`

# val it : goalstack = 1 subgoal (2 total)

`!m m'. ~(2 * m = SUC (2 * m'))`

# val it : goalstack = 1 subgoal (2 total)

`(?m. n = 2 * m) ==> ~(?m. n = SUC (2 * m))`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

# val it : goalstack = 1 subgoal (1 total)

`PARI n <=> ~DISPARI n`

# val it : goalstack = 1 subgoal (1 total)

`!n. PARI n <=> ~DISPARI n`

# Exception: Failure "Can't back up any more".
# Exception: Failure "Can't back up any more".
# val it : goalstack = 1 subgoal (1 total)

`PARI n <=> ~DISPARI n`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

#                       Toplevel input:
# g (            REWRITE_TAC [PARI; DISPARI]
              THEN SUBGOAL_THEN `!m m'. ~(2*m = SUC (2*m'))` (fun th -> MESON_TAC [th])
              THEN INDUCT_TAC
              THENL [
                  ARITH_TAC;
                  INDUCT_TAC
                  THENL [
                      ARITH_TAC;
                      REWRITE_TAC [ARITH_RULE `2 * SUC m = SUC (SUC (2 * m))`]
                      THEN REWRITE_TAC [SUC_INJ]
                      THEN ASM_REWRITE_TAC[]
                  ];);;
                    ^
Parse error: ']' expected after [expr1_semi_list] (in [expr])
#                       Toplevel input:
# e ( REWRITE_TAC [PARI; DISPARI]
   THEN SUBGOAL_THEN `!m m'. ~(2*m = SUC (2*m'))` (fun th -> MESON_TAC [th])
   THEN INDUCT_TAC
   THENL [
   ARITH_TAC;
   INDUCT_TAC
   THENL [
   ARITH_TAC;
   REWRITE_TAC [ARITH_RULE `2 * SUC m = SUC (SUC (2 * m))`]
   THEN REWRITE_TAC [SUC_INJ]
   THEN ASM_REWRITE_TAC[]
   ]);;
    ^
Parse error: ']' expected after [expr1_semi_list] (in [expr])
#                       Toplevel input:
# e ( REWRITE_TAC [PARI; DISPARI]
   THEN SUBGOAL_THEN `!m m'. ~(2*m = SUC (2*m'))` (fun th -> MESON_TAC [th])
   THEN INDUCT_TAC
   THENL [
   ARITH_TAC;
   INDUCT_TAC
   THENL [
   ARITH_TAC;
   REWRITE_TAC [ARITH_RULE `2 * SUC m = SUC (SUC (2 * m))`]
   THEN REWRITE_TAC [SUC_INJ]
   THEN ASM_REWRITE_TAC[]
   ]);;
    ^
Parse error: ']' expected after [expr1_semi_list] (in [expr])
#                     Toplevel input:
# e ( REWRITE_TAC [PARI; DISPARI]
   THEN SUBGOAL_THEN `!m m'. ~(2*m = SUC (2*m'))` (fun th -> MESON_TAC [th])
   THEN INDUCT_TAC
   THENL [
   ARITH_TAC;
   INDUCT_TAC
   THENL [
   ARITH_TAC;
   REWRITE_TAC [ARITH_RULE `2 * SUC m = SUC (SUC (2 * m))`]
   THEN REWRITE_TAC [SUC_INJ]
   THEN ASM_REWRITE_TAC[]);;
                         ^
Parse error: ']' expected after [expr1_semi_list] (in [expr])
#                       Toplevel input:
#             REWRITE_TAC [PARI; DISPARI]
              THEN SUBGOAL_THEN `!m m'. ~(2*m = SUC (2*m'))` (fun th -> MESON_TAC [th])
              THEN INDUCT_TAC
              THENL [
                  ARITH_TAC;
                  INDUCT_TAC
                  THENL [
                      ARITH_TAC;
                      REWRITE_TAC [ARITH_RULE `2 * SUC m = SUC (SUC (2 * m))`]
                      THEN REWRITE_TAC [SUC_INJ]
                      THEN ASM_REWRITE_TAC[]
                  ];;;
                   ^^
Parse error: ']' expected after [expr1_semi_list] (in [expr])
#                       Toplevel input:
#             REWRITE_TAC [PARI; DISPARI]
              THEN SUBGOAL_THEN `!m m'. ~(2*m = SUC (2*m'))` (fun th -> MESON_TAC [th])
              THEN INDUCT_TAC
              THENL [
                  ARITH_TAC;
                  INDUCT_TAC
                  THENL [
                      ARITH_TAC;
                      REWRITE_TAC [ARITH_RULE `2 * SUC m = SUC (SUC (2 * m))`]
                      THEN REWRITE_TAC [SUC_INJ]
                      THEN ASM_REWRITE_TAC[]
                  ];;
                   ^^
Parse error: ']' expected after [expr1_semi_list] (in [expr])
#     0..0..1..2..solved at 6
val it : goalstack = 2 subgoals (3 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`!m'. ~(2 * SUC m = SUC (2 * m'))`

`!m'. ~(2 * 0 = SUC (2 * m'))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`!m'. ~(2 * SUC m = SUC (2 * m'))`

# val it : goalstack = 2 subgoals (3 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`!m'. ~(2 * SUC m = SUC (2 * m'))`

`!m'. ~(2 * 0 = SUC (2 * m'))`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

# val it : goalstack = 1 subgoal (1 total)

`PARI n <=> ~DISPARI n`

# val it : goalstack = 1 subgoal (1 total)

`!n. PARI n <=> ~DISPARI n`

# Exception: Failure "Can't back up any more".
# Exception: Failure "Can't back up any more".
# Exception: Failure "Can't back up any more".
# Exception: Failure "Can't back up any more".
# Exception: Failure "Can't back up any more".
# val it : goalstack = 1 subgoal (1 total)

`PARI n <=> ~DISPARI n`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

#                                           0..0..1..2..solved at 6
val it : thm = |- !n. PARI n <=> ~DISPARI n
# val it : goalstack = 1 subgoal (1 total)

`!n. PARI n <=> ~DISPARI n`

# val it : goalstack = 1 subgoal (1 total)

`PARI n <=> ~DISPARI n`

# val it : goalstack = 2 subgoals (2 total)

`~DISPARI n ==> PARI n`

`PARI n ==> ~DISPARI n`

# val it : goalstack = 1 subgoal (2 total)

`(?m. n = 2 * m) ==> ~(?m. n = SUC (2 * m))`

# 0..0..1..2..solved at 6
val it : goalstack = 1 subgoal (2 total)

`!m m'. ~(2 * m = SUC (2 * m'))`

# val it : goalstack = 2 subgoals (3 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`!m'. ~(2 * SUC m = SUC (2 * m'))`

`!m'. ~(2 * 0 = SUC (2 * m'))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`!m'. ~(2 * SUC m = SUC (2 * m'))`

# val it : goalstack = 2 subgoals (3 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]
  1 [`~(2 * SUC m = SUC (2 * m'))`]

`~(2 * SUC m = SUC (2 * SUC m'))`

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]

`~(2 * SUC m = SUC (2 * 0))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]
  1 [`~(2 * SUC m = SUC (2 * m'))`]

`~(2 * SUC m = SUC (2 * SUC m'))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]
  1 [`~(2 * SUC m = SUC (2 * m'))`]

`~(SUC (SUC (2 * m)) = SUC (SUC (SUC (2 * m'))))`

# val it : goalstack = 1 subgoal (2 total)

  0 [`!m'. ~(2 * m = SUC (2 * m'))`]
  1 [`~(2 * SUC m = SUC (2 * m'))`]

`~(2 * m = SUC (2 * m'))`

# val it : goalstack = 1 subgoal (1 total)

`~DISPARI n ==> PARI n`

# val it : goalstack = No subgoals

#                                       0..0..1..2..solved at 6
val PARI_n_EQ_NOT_DISPARI_n : thm = |- !n. PARI n <=> ~DISPARI n
# 